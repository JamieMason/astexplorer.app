(window.webpackJsonp=window.webpackJsonp||[]).push([[78],{"./node_modules/@webassemblyjs/wast-parser/esm/index.js":function(module,__webpack_exports__,__webpack_require__){"use strict";eval('// ESM COMPAT FLAG\n__webpack_require__.r(__webpack_exports__);\n\n// EXPORTS\n__webpack_require__.d(__webpack_exports__, "parse", function() { return /* binding */ esm_parse; });\n__webpack_require__.d(__webpack_exports__, "parse32F", function() { return /* reexport */ parse32F; });\n__webpack_require__.d(__webpack_exports__, "parse64F", function() { return /* reexport */ parse64F; });\n__webpack_require__.d(__webpack_exports__, "parse32I", function() { return /* reexport */ parse32I; });\n__webpack_require__.d(__webpack_exports__, "parseU32", function() { return /* reexport */ parseU32; });\n__webpack_require__.d(__webpack_exports__, "parse64I", function() { return /* reexport */ parse64I; });\n__webpack_require__.d(__webpack_exports__, "isInfLiteral", function() { return /* reexport */ isInfLiteral; });\n__webpack_require__.d(__webpack_exports__, "isNanLiteral", function() { return /* reexport */ isNanLiteral; });\n\n// CONCATENATED MODULE: ./node_modules/@webassemblyjs/ast/esm/nodes.js\nfunction _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }\n\n// THIS FILE IS AUTOGENERATED\n// see scripts/generateNodeUtils.js\nfunction isTypeOf(t) {\n  return function (n) {\n    return n.type === t;\n  };\n}\n\nfunction assertTypeOf(t) {\n  return function (n) {\n    return function () {\n      if (!(n.type === t)) {\n        throw new Error(\'n.type === t\' + " error: " + (undefined || "unknown"));\n      }\n    }();\n  };\n}\n\nfunction nodes_module(id, fields, metadata) {\n  if (id !== null && id !== undefined) {\n    if (!(typeof id === "string")) {\n      throw new Error(\'typeof id === "string"\' + " error: " + ("Argument id must be of type string, given: " + _typeof(id) || false));\n    }\n  }\n\n  if (!(_typeof(fields) === "object" && typeof fields.length !== "undefined")) {\n    throw new Error(\'typeof fields === "object" && typeof fields.length !== "undefined"\' + " error: " + (undefined || "unknown"));\n  }\n\n  var node = {\n    type: "Module",\n    id: id,\n    fields: fields\n  };\n\n  if (typeof metadata !== "undefined") {\n    node.metadata = metadata;\n  }\n\n  return node;\n}\nfunction moduleMetadata(sections, functionNames, localNames, producers) {\n  if (!(_typeof(sections) === "object" && typeof sections.length !== "undefined")) {\n    throw new Error(\'typeof sections === "object" && typeof sections.length !== "undefined"\' + " error: " + (undefined || "unknown"));\n  }\n\n  if (functionNames !== null && functionNames !== undefined) {\n    if (!(_typeof(functionNames) === "object" && typeof functionNames.length !== "undefined")) {\n      throw new Error(\'typeof functionNames === "object" && typeof functionNames.length !== "undefined"\' + " error: " + (undefined || "unknown"));\n    }\n  }\n\n  if (localNames !== null && localNames !== undefined) {\n    if (!(_typeof(localNames) === "object" && typeof localNames.length !== "undefined")) {\n      throw new Error(\'typeof localNames === "object" && typeof localNames.length !== "undefined"\' + " error: " + (undefined || "unknown"));\n    }\n  }\n\n  if (producers !== null && producers !== undefined) {\n    if (!(_typeof(producers) === "object" && typeof producers.length !== "undefined")) {\n      throw new Error(\'typeof producers === "object" && typeof producers.length !== "undefined"\' + " error: " + (undefined || "unknown"));\n    }\n  }\n\n  var node = {\n    type: "ModuleMetadata",\n    sections: sections\n  };\n\n  if (typeof functionNames !== "undefined" && functionNames.length > 0) {\n    node.functionNames = functionNames;\n  }\n\n  if (typeof localNames !== "undefined" && localNames.length > 0) {\n    node.localNames = localNames;\n  }\n\n  if (typeof producers !== "undefined" && producers.length > 0) {\n    node.producers = producers;\n  }\n\n  return node;\n}\nfunction moduleNameMetadata(value) {\n  if (!(typeof value === "string")) {\n    throw new Error(\'typeof value === "string"\' + " error: " + ("Argument value must be of type string, given: " + _typeof(value) || false));\n  }\n\n  var node = {\n    type: "ModuleNameMetadata",\n    value: value\n  };\n  return node;\n}\nfunction functionNameMetadata(value, index) {\n  if (!(typeof value === "string")) {\n    throw new Error(\'typeof value === "string"\' + " error: " + ("Argument value must be of type string, given: " + _typeof(value) || false));\n  }\n\n  if (!(typeof index === "number")) {\n    throw new Error(\'typeof index === "number"\' + " error: " + ("Argument index must be of type number, given: " + _typeof(index) || false));\n  }\n\n  var node = {\n    type: "FunctionNameMetadata",\n    value: value,\n    index: index\n  };\n  return node;\n}\nfunction localNameMetadata(value, localIndex, functionIndex) {\n  if (!(typeof value === "string")) {\n    throw new Error(\'typeof value === "string"\' + " error: " + ("Argument value must be of type string, given: " + _typeof(value) || false));\n  }\n\n  if (!(typeof localIndex === "number")) {\n    throw new Error(\'typeof localIndex === "number"\' + " error: " + ("Argument localIndex must be of type number, given: " + _typeof(localIndex) || false));\n  }\n\n  if (!(typeof functionIndex === "number")) {\n    throw new Error(\'typeof functionIndex === "number"\' + " error: " + ("Argument functionIndex must be of type number, given: " + _typeof(functionIndex) || false));\n  }\n\n  var node = {\n    type: "LocalNameMetadata",\n    value: value,\n    localIndex: localIndex,\n    functionIndex: functionIndex\n  };\n  return node;\n}\nfunction binaryModule(id, blob) {\n  if (id !== null && id !== undefined) {\n    if (!(typeof id === "string")) {\n      throw new Error(\'typeof id === "string"\' + " error: " + ("Argument id must be of type string, given: " + _typeof(id) || false));\n    }\n  }\n\n  if (!(_typeof(blob) === "object" && typeof blob.length !== "undefined")) {\n    throw new Error(\'typeof blob === "object" && typeof blob.length !== "undefined"\' + " error: " + (undefined || "unknown"));\n  }\n\n  var node = {\n    type: "BinaryModule",\n    id: id,\n    blob: blob\n  };\n  return node;\n}\nfunction quoteModule(id, string) {\n  if (id !== null && id !== undefined) {\n    if (!(typeof id === "string")) {\n      throw new Error(\'typeof id === "string"\' + " error: " + ("Argument id must be of type string, given: " + _typeof(id) || false));\n    }\n  }\n\n  if (!(_typeof(string) === "object" && typeof string.length !== "undefined")) {\n    throw new Error(\'typeof string === "object" && typeof string.length !== "undefined"\' + " error: " + (undefined || "unknown"));\n  }\n\n  var node = {\n    type: "QuoteModule",\n    id: id,\n    string: string\n  };\n  return node;\n}\nfunction sectionMetadata(section, startOffset, size, vectorOfSize) {\n  if (!(typeof startOffset === "number")) {\n    throw new Error(\'typeof startOffset === "number"\' + " error: " + ("Argument startOffset must be of type number, given: " + _typeof(startOffset) || false));\n  }\n\n  var node = {\n    type: "SectionMetadata",\n    section: section,\n    startOffset: startOffset,\n    size: size,\n    vectorOfSize: vectorOfSize\n  };\n  return node;\n}\nfunction producersSectionMetadata(producers) {\n  if (!(_typeof(producers) === "object" && typeof producers.length !== "undefined")) {\n    throw new Error(\'typeof producers === "object" && typeof producers.length !== "undefined"\' + " error: " + (undefined || "unknown"));\n  }\n\n  var node = {\n    type: "ProducersSectionMetadata",\n    producers: producers\n  };\n  return node;\n}\nfunction producerMetadata(language, processedBy, sdk) {\n  if (!(_typeof(language) === "object" && typeof language.length !== "undefined")) {\n    throw new Error(\'typeof language === "object" && typeof language.length !== "undefined"\' + " error: " + (undefined || "unknown"));\n  }\n\n  if (!(_typeof(processedBy) === "object" && typeof processedBy.length !== "undefined")) {\n    throw new Error(\'typeof processedBy === "object" && typeof processedBy.length !== "undefined"\' + " error: " + (undefined || "unknown"));\n  }\n\n  if (!(_typeof(sdk) === "object" && typeof sdk.length !== "undefined")) {\n    throw new Error(\'typeof sdk === "object" && typeof sdk.length !== "undefined"\' + " error: " + (undefined || "unknown"));\n  }\n\n  var node = {\n    type: "ProducerMetadata",\n    language: language,\n    processedBy: processedBy,\n    sdk: sdk\n  };\n  return node;\n}\nfunction producerMetadataVersionedName(name, version) {\n  if (!(typeof name === "string")) {\n    throw new Error(\'typeof name === "string"\' + " error: " + ("Argument name must be of type string, given: " + _typeof(name) || false));\n  }\n\n  if (!(typeof version === "string")) {\n    throw new Error(\'typeof version === "string"\' + " error: " + ("Argument version must be of type string, given: " + _typeof(version) || false));\n  }\n\n  var node = {\n    type: "ProducerMetadataVersionedName",\n    name: name,\n    version: version\n  };\n  return node;\n}\nfunction loopInstruction(label, resulttype, instr) {\n  if (!(_typeof(instr) === "object" && typeof instr.length !== "undefined")) {\n    throw new Error(\'typeof instr === "object" && typeof instr.length !== "undefined"\' + " error: " + (undefined || "unknown"));\n  }\n\n  var node = {\n    type: "LoopInstruction",\n    id: "loop",\n    label: label,\n    resulttype: resulttype,\n    instr: instr\n  };\n  return node;\n}\nfunction nodes_instr(id, object, args, namedArgs) {\n  if (!(typeof id === "string")) {\n    throw new Error(\'typeof id === "string"\' + " error: " + ("Argument id must be of type string, given: " + _typeof(id) || false));\n  }\n\n  if (!(_typeof(args) === "object" && typeof args.length !== "undefined")) {\n    throw new Error(\'typeof args === "object" && typeof args.length !== "undefined"\' + " error: " + (undefined || "unknown"));\n  }\n\n  var node = {\n    type: "Instr",\n    id: id,\n    args: args\n  };\n\n  if (typeof object !== "undefined") {\n    node.object = object;\n  }\n\n  if (typeof namedArgs !== "undefined" && Object.keys(namedArgs).length !== 0) {\n    node.namedArgs = namedArgs;\n  }\n\n  return node;\n}\nfunction ifInstruction(testLabel, test, result, consequent, alternate) {\n  if (!(_typeof(test) === "object" && typeof test.length !== "undefined")) {\n    throw new Error(\'typeof test === "object" && typeof test.length !== "undefined"\' + " error: " + (undefined || "unknown"));\n  }\n\n  if (!(_typeof(consequent) === "object" && typeof consequent.length !== "undefined")) {\n    throw new Error(\'typeof consequent === "object" && typeof consequent.length !== "undefined"\' + " error: " + (undefined || "unknown"));\n  }\n\n  if (!(_typeof(alternate) === "object" && typeof alternate.length !== "undefined")) {\n    throw new Error(\'typeof alternate === "object" && typeof alternate.length !== "undefined"\' + " error: " + (undefined || "unknown"));\n  }\n\n  var node = {\n    type: "IfInstruction",\n    id: "if",\n    testLabel: testLabel,\n    test: test,\n    result: result,\n    consequent: consequent,\n    alternate: alternate\n  };\n  return node;\n}\nfunction stringLiteral(value) {\n  if (!(typeof value === "string")) {\n    throw new Error(\'typeof value === "string"\' + " error: " + ("Argument value must be of type string, given: " + _typeof(value) || false));\n  }\n\n  var node = {\n    type: "StringLiteral",\n    value: value\n  };\n  return node;\n}\nfunction nodes_numberLiteral(value, raw) {\n  if (!(typeof value === "number")) {\n    throw new Error(\'typeof value === "number"\' + " error: " + ("Argument value must be of type number, given: " + _typeof(value) || false));\n  }\n\n  if (!(typeof raw === "string")) {\n    throw new Error(\'typeof raw === "string"\' + " error: " + ("Argument raw must be of type string, given: " + _typeof(raw) || false));\n  }\n\n  var node = {\n    type: "NumberLiteral",\n    value: value,\n    raw: raw\n  };\n  return node;\n}\nfunction longNumberLiteral(value, raw) {\n  if (!(typeof raw === "string")) {\n    throw new Error(\'typeof raw === "string"\' + " error: " + ("Argument raw must be of type string, given: " + _typeof(raw) || false));\n  }\n\n  var node = {\n    type: "LongNumberLiteral",\n    value: value,\n    raw: raw\n  };\n  return node;\n}\nfunction floatLiteral(value, nan, inf, raw) {\n  if (!(typeof value === "number")) {\n    throw new Error(\'typeof value === "number"\' + " error: " + ("Argument value must be of type number, given: " + _typeof(value) || false));\n  }\n\n  if (nan !== null && nan !== undefined) {\n    if (!(typeof nan === "boolean")) {\n      throw new Error(\'typeof nan === "boolean"\' + " error: " + ("Argument nan must be of type boolean, given: " + _typeof(nan) || false));\n    }\n  }\n\n  if (inf !== null && inf !== undefined) {\n    if (!(typeof inf === "boolean")) {\n      throw new Error(\'typeof inf === "boolean"\' + " error: " + ("Argument inf must be of type boolean, given: " + _typeof(inf) || false));\n    }\n  }\n\n  if (!(typeof raw === "string")) {\n    throw new Error(\'typeof raw === "string"\' + " error: " + ("Argument raw must be of type string, given: " + _typeof(raw) || false));\n  }\n\n  var node = {\n    type: "FloatLiteral",\n    value: value,\n    raw: raw\n  };\n\n  if (nan === true) {\n    node.nan = true;\n  }\n\n  if (inf === true) {\n    node.inf = true;\n  }\n\n  return node;\n}\nfunction elem(table, offset, funcs) {\n  if (!(_typeof(offset) === "object" && typeof offset.length !== "undefined")) {\n    throw new Error(\'typeof offset === "object" && typeof offset.length !== "undefined"\' + " error: " + (undefined || "unknown"));\n  }\n\n  if (!(_typeof(funcs) === "object" && typeof funcs.length !== "undefined")) {\n    throw new Error(\'typeof funcs === "object" && typeof funcs.length !== "undefined"\' + " error: " + (undefined || "unknown"));\n  }\n\n  var node = {\n    type: "Elem",\n    table: table,\n    offset: offset,\n    funcs: funcs\n  };\n  return node;\n}\nfunction indexInFuncSection(index) {\n  var node = {\n    type: "IndexInFuncSection",\n    index: index\n  };\n  return node;\n}\nfunction valtypeLiteral(name) {\n  var node = {\n    type: "ValtypeLiteral",\n    name: name\n  };\n  return node;\n}\nfunction typeInstruction(id, functype) {\n  var node = {\n    type: "TypeInstruction",\n    id: id,\n    functype: functype\n  };\n  return node;\n}\nfunction nodes_start(index) {\n  var node = {\n    type: "Start",\n    index: index\n  };\n  return node;\n}\nfunction globalType(valtype, mutability) {\n  var node = {\n    type: "GlobalType",\n    valtype: valtype,\n    mutability: mutability\n  };\n  return node;\n}\nfunction leadingComment(value) {\n  if (!(typeof value === "string")) {\n    throw new Error(\'typeof value === "string"\' + " error: " + ("Argument value must be of type string, given: " + _typeof(value) || false));\n  }\n\n  var node = {\n    type: "LeadingComment",\n    value: value\n  };\n  return node;\n}\nfunction blockComment(value) {\n  if (!(typeof value === "string")) {\n    throw new Error(\'typeof value === "string"\' + " error: " + ("Argument value must be of type string, given: " + _typeof(value) || false));\n  }\n\n  var node = {\n    type: "BlockComment",\n    value: value\n  };\n  return node;\n}\nfunction data(memoryIndex, offset, init) {\n  var node = {\n    type: "Data",\n    memoryIndex: memoryIndex,\n    offset: offset,\n    init: init\n  };\n  return node;\n}\nfunction global(globalType, init, name) {\n  if (!(_typeof(init) === "object" && typeof init.length !== "undefined")) {\n    throw new Error(\'typeof init === "object" && typeof init.length !== "undefined"\' + " error: " + (undefined || "unknown"));\n  }\n\n  var node = {\n    type: "Global",\n    globalType: globalType,\n    init: init,\n    name: name\n  };\n  return node;\n}\nfunction table(elementType, limits, name, elements) {\n  if (!(limits.type === "Limit")) {\n    throw new Error(\'limits.type === "Limit"\' + " error: " + ("Argument limits must be of type Limit, given: " + limits.type || false));\n  }\n\n  if (elements !== null && elements !== undefined) {\n    if (!(_typeof(elements) === "object" && typeof elements.length !== "undefined")) {\n      throw new Error(\'typeof elements === "object" && typeof elements.length !== "undefined"\' + " error: " + (undefined || "unknown"));\n    }\n  }\n\n  var node = {\n    type: "Table",\n    elementType: elementType,\n    limits: limits,\n    name: name\n  };\n\n  if (typeof elements !== "undefined" && elements.length > 0) {\n    node.elements = elements;\n  }\n\n  return node;\n}\nfunction memory(limits, id) {\n  var node = {\n    type: "Memory",\n    limits: limits,\n    id: id\n  };\n  return node;\n}\nfunction funcImportDescr(id, signature) {\n  var node = {\n    type: "FuncImportDescr",\n    id: id,\n    signature: signature\n  };\n  return node;\n}\nfunction moduleImport(module, name, descr) {\n  if (!(typeof module === "string")) {\n    throw new Error(\'typeof module === "string"\' + " error: " + ("Argument module must be of type string, given: " + _typeof(module) || false));\n  }\n\n  if (!(typeof name === "string")) {\n    throw new Error(\'typeof name === "string"\' + " error: " + ("Argument name must be of type string, given: " + _typeof(name) || false));\n  }\n\n  var node = {\n    type: "ModuleImport",\n    module: module,\n    name: name,\n    descr: descr\n  };\n  return node;\n}\nfunction nodes_moduleExportDescr(exportType, id) {\n  var node = {\n    type: "ModuleExportDescr",\n    exportType: exportType,\n    id: id\n  };\n  return node;\n}\nfunction moduleExport(name, descr) {\n  if (!(typeof name === "string")) {\n    throw new Error(\'typeof name === "string"\' + " error: " + ("Argument name must be of type string, given: " + _typeof(name) || false));\n  }\n\n  var node = {\n    type: "ModuleExport",\n    name: name,\n    descr: descr\n  };\n  return node;\n}\nfunction nodes_limit(min, max) {\n  if (!(typeof min === "number")) {\n    throw new Error(\'typeof min === "number"\' + " error: " + ("Argument min must be of type number, given: " + _typeof(min) || false));\n  }\n\n  if (max !== null && max !== undefined) {\n    if (!(typeof max === "number")) {\n      throw new Error(\'typeof max === "number"\' + " error: " + ("Argument max must be of type number, given: " + _typeof(max) || false));\n    }\n  }\n\n  var node = {\n    type: "Limit",\n    min: min\n  };\n\n  if (typeof max !== "undefined") {\n    node.max = max;\n  }\n\n  return node;\n}\nfunction nodes_signature(params, results) {\n  if (!(_typeof(params) === "object" && typeof params.length !== "undefined")) {\n    throw new Error(\'typeof params === "object" && typeof params.length !== "undefined"\' + " error: " + (undefined || "unknown"));\n  }\n\n  if (!(_typeof(results) === "object" && typeof results.length !== "undefined")) {\n    throw new Error(\'typeof results === "object" && typeof results.length !== "undefined"\' + " error: " + (undefined || "unknown"));\n  }\n\n  var node = {\n    type: "Signature",\n    params: params,\n    results: results\n  };\n  return node;\n}\nfunction program(body) {\n  if (!(_typeof(body) === "object" && typeof body.length !== "undefined")) {\n    throw new Error(\'typeof body === "object" && typeof body.length !== "undefined"\' + " error: " + (undefined || "unknown"));\n  }\n\n  var node = {\n    type: "Program",\n    body: body\n  };\n  return node;\n}\nfunction identifier(value, raw) {\n  if (!(typeof value === "string")) {\n    throw new Error(\'typeof value === "string"\' + " error: " + ("Argument value must be of type string, given: " + _typeof(value) || false));\n  }\n\n  if (raw !== null && raw !== undefined) {\n    if (!(typeof raw === "string")) {\n      throw new Error(\'typeof raw === "string"\' + " error: " + ("Argument raw must be of type string, given: " + _typeof(raw) || false));\n    }\n  }\n\n  var node = {\n    type: "Identifier",\n    value: value\n  };\n\n  if (typeof raw !== "undefined") {\n    node.raw = raw;\n  }\n\n  return node;\n}\nfunction blockInstruction(label, instr, result) {\n  if (!(_typeof(instr) === "object" && typeof instr.length !== "undefined")) {\n    throw new Error(\'typeof instr === "object" && typeof instr.length !== "undefined"\' + " error: " + (undefined || "unknown"));\n  }\n\n  var node = {\n    type: "BlockInstruction",\n    id: "block",\n    label: label,\n    instr: instr,\n    result: result\n  };\n  return node;\n}\nfunction callInstruction(index, instrArgs, numeric) {\n  if (instrArgs !== null && instrArgs !== undefined) {\n    if (!(_typeof(instrArgs) === "object" && typeof instrArgs.length !== "undefined")) {\n      throw new Error(\'typeof instrArgs === "object" && typeof instrArgs.length !== "undefined"\' + " error: " + (undefined || "unknown"));\n    }\n  }\n\n  var node = {\n    type: "CallInstruction",\n    id: "call",\n    index: index\n  };\n\n  if (typeof instrArgs !== "undefined" && instrArgs.length > 0) {\n    node.instrArgs = instrArgs;\n  }\n\n  if (typeof numeric !== "undefined") {\n    node.numeric = numeric;\n  }\n\n  return node;\n}\nfunction callIndirectInstruction(signature, intrs) {\n  if (intrs !== null && intrs !== undefined) {\n    if (!(_typeof(intrs) === "object" && typeof intrs.length !== "undefined")) {\n      throw new Error(\'typeof intrs === "object" && typeof intrs.length !== "undefined"\' + " error: " + (undefined || "unknown"));\n    }\n  }\n\n  var node = {\n    type: "CallIndirectInstruction",\n    id: "call_indirect",\n    signature: signature\n  };\n\n  if (typeof intrs !== "undefined" && intrs.length > 0) {\n    node.intrs = intrs;\n  }\n\n  return node;\n}\nfunction nodes_byteArray(values) {\n  if (!(_typeof(values) === "object" && typeof values.length !== "undefined")) {\n    throw new Error(\'typeof values === "object" && typeof values.length !== "undefined"\' + " error: " + (undefined || "unknown"));\n  }\n\n  var node = {\n    type: "ByteArray",\n    values: values\n  };\n  return node;\n}\nfunction func(name, signature, body, isExternal, metadata) {\n  if (!(_typeof(body) === "object" && typeof body.length !== "undefined")) {\n    throw new Error(\'typeof body === "object" && typeof body.length !== "undefined"\' + " error: " + (undefined || "unknown"));\n  }\n\n  if (isExternal !== null && isExternal !== undefined) {\n    if (!(typeof isExternal === "boolean")) {\n      throw new Error(\'typeof isExternal === "boolean"\' + " error: " + ("Argument isExternal must be of type boolean, given: " + _typeof(isExternal) || false));\n    }\n  }\n\n  var node = {\n    type: "Func",\n    name: name,\n    signature: signature,\n    body: body\n  };\n\n  if (isExternal === true) {\n    node.isExternal = true;\n  }\n\n  if (typeof metadata !== "undefined") {\n    node.metadata = metadata;\n  }\n\n  return node;\n}\nfunction internalBrUnless(target) {\n  if (!(typeof target === "number")) {\n    throw new Error(\'typeof target === "number"\' + " error: " + ("Argument target must be of type number, given: " + _typeof(target) || false));\n  }\n\n  var node = {\n    type: "InternalBrUnless",\n    target: target\n  };\n  return node;\n}\nfunction internalGoto(target) {\n  if (!(typeof target === "number")) {\n    throw new Error(\'typeof target === "number"\' + " error: " + ("Argument target must be of type number, given: " + _typeof(target) || false));\n  }\n\n  var node = {\n    type: "InternalGoto",\n    target: target\n  };\n  return node;\n}\nfunction internalCallExtern(target) {\n  if (!(typeof target === "number")) {\n    throw new Error(\'typeof target === "number"\' + " error: " + ("Argument target must be of type number, given: " + _typeof(target) || false));\n  }\n\n  var node = {\n    type: "InternalCallExtern",\n    target: target\n  };\n  return node;\n}\nfunction internalEndAndReturn() {\n  var node = {\n    type: "InternalEndAndReturn"\n  };\n  return node;\n}\nvar isModule = isTypeOf("Module");\nvar isModuleMetadata = isTypeOf("ModuleMetadata");\nvar isModuleNameMetadata = isTypeOf("ModuleNameMetadata");\nvar isFunctionNameMetadata = isTypeOf("FunctionNameMetadata");\nvar isLocalNameMetadata = isTypeOf("LocalNameMetadata");\nvar isBinaryModule = isTypeOf("BinaryModule");\nvar isQuoteModule = isTypeOf("QuoteModule");\nvar isSectionMetadata = isTypeOf("SectionMetadata");\nvar isProducersSectionMetadata = isTypeOf("ProducersSectionMetadata");\nvar isProducerMetadata = isTypeOf("ProducerMetadata");\nvar isProducerMetadataVersionedName = isTypeOf("ProducerMetadataVersionedName");\nvar isLoopInstruction = isTypeOf("LoopInstruction");\nvar isInstr = isTypeOf("Instr");\nvar isIfInstruction = isTypeOf("IfInstruction");\nvar isStringLiteral = isTypeOf("StringLiteral");\nvar isNumberLiteral = isTypeOf("NumberLiteral");\nvar isLongNumberLiteral = isTypeOf("LongNumberLiteral");\nvar isFloatLiteral = isTypeOf("FloatLiteral");\nvar isElem = isTypeOf("Elem");\nvar isIndexInFuncSection = isTypeOf("IndexInFuncSection");\nvar isValtypeLiteral = isTypeOf("ValtypeLiteral");\nvar isTypeInstruction = isTypeOf("TypeInstruction");\nvar isStart = isTypeOf("Start");\nvar isGlobalType = isTypeOf("GlobalType");\nvar isLeadingComment = isTypeOf("LeadingComment");\nvar isBlockComment = isTypeOf("BlockComment");\nvar isData = isTypeOf("Data");\nvar isGlobal = isTypeOf("Global");\nvar isTable = isTypeOf("Table");\nvar isMemory = isTypeOf("Memory");\nvar isFuncImportDescr = isTypeOf("FuncImportDescr");\nvar isModuleImport = isTypeOf("ModuleImport");\nvar isModuleExportDescr = isTypeOf("ModuleExportDescr");\nvar isModuleExport = isTypeOf("ModuleExport");\nvar isLimit = isTypeOf("Limit");\nvar isSignature = isTypeOf("Signature");\nvar isProgram = isTypeOf("Program");\nvar isIdentifier = isTypeOf("Identifier");\nvar isBlockInstruction = isTypeOf("BlockInstruction");\nvar isCallInstruction = isTypeOf("CallInstruction");\nvar isCallIndirectInstruction = isTypeOf("CallIndirectInstruction");\nvar isByteArray = isTypeOf("ByteArray");\nvar isFunc = isTypeOf("Func");\nvar isInternalBrUnless = isTypeOf("InternalBrUnless");\nvar isInternalGoto = isTypeOf("InternalGoto");\nvar isInternalCallExtern = isTypeOf("InternalCallExtern");\nvar isInternalEndAndReturn = isTypeOf("InternalEndAndReturn");\nvar isNode = function isNode(node) {\n  return isModule(node) || isModuleMetadata(node) || isModuleNameMetadata(node) || isFunctionNameMetadata(node) || isLocalNameMetadata(node) || isBinaryModule(node) || isQuoteModule(node) || isSectionMetadata(node) || isProducersSectionMetadata(node) || isProducerMetadata(node) || isProducerMetadataVersionedName(node) || isLoopInstruction(node) || isInstr(node) || isIfInstruction(node) || isStringLiteral(node) || isNumberLiteral(node) || isLongNumberLiteral(node) || isFloatLiteral(node) || isElem(node) || isIndexInFuncSection(node) || isValtypeLiteral(node) || isTypeInstruction(node) || isStart(node) || isGlobalType(node) || isLeadingComment(node) || isBlockComment(node) || isData(node) || isGlobal(node) || isTable(node) || isMemory(node) || isFuncImportDescr(node) || isModuleImport(node) || isModuleExportDescr(node) || isModuleExport(node) || isLimit(node) || isSignature(node) || isProgram(node) || isIdentifier(node) || isBlockInstruction(node) || isCallInstruction(node) || isCallIndirectInstruction(node) || isByteArray(node) || isFunc(node) || isInternalBrUnless(node) || isInternalGoto(node) || isInternalCallExtern(node) || isInternalEndAndReturn(node);\n};\nvar isBlock = function isBlock(node) {\n  return isLoopInstruction(node) || isBlockInstruction(node) || isFunc(node);\n};\nvar isInstruction = function isInstruction(node) {\n  return isLoopInstruction(node) || isInstr(node) || isIfInstruction(node) || isTypeInstruction(node) || isBlockInstruction(node) || isCallInstruction(node) || isCallIndirectInstruction(node);\n};\nvar isExpression = function isExpression(node) {\n  return isInstr(node) || isStringLiteral(node) || isNumberLiteral(node) || isLongNumberLiteral(node) || isFloatLiteral(node) || isValtypeLiteral(node) || isIdentifier(node);\n};\nvar isNumericLiteral = function isNumericLiteral(node) {\n  return isNumberLiteral(node) || isLongNumberLiteral(node) || isFloatLiteral(node);\n};\nvar isImportDescr = function isImportDescr(node) {\n  return isGlobalType(node) || isTable(node) || isMemory(node) || isFuncImportDescr(node);\n};\nvar isIntrinsic = function isIntrinsic(node) {\n  return isInternalBrUnless(node) || isInternalGoto(node) || isInternalCallExtern(node) || isInternalEndAndReturn(node);\n};\nvar assertModule = assertTypeOf("Module");\nvar assertModuleMetadata = assertTypeOf("ModuleMetadata");\nvar assertModuleNameMetadata = assertTypeOf("ModuleNameMetadata");\nvar assertFunctionNameMetadata = assertTypeOf("FunctionNameMetadata");\nvar assertLocalNameMetadata = assertTypeOf("LocalNameMetadata");\nvar assertBinaryModule = assertTypeOf("BinaryModule");\nvar assertQuoteModule = assertTypeOf("QuoteModule");\nvar assertSectionMetadata = assertTypeOf("SectionMetadata");\nvar assertProducersSectionMetadata = assertTypeOf("ProducersSectionMetadata");\nvar assertProducerMetadata = assertTypeOf("ProducerMetadata");\nvar assertProducerMetadataVersionedName = assertTypeOf("ProducerMetadataVersionedName");\nvar assertLoopInstruction = assertTypeOf("LoopInstruction");\nvar assertInstr = assertTypeOf("Instr");\nvar assertIfInstruction = assertTypeOf("IfInstruction");\nvar assertStringLiteral = assertTypeOf("StringLiteral");\nvar assertNumberLiteral = assertTypeOf("NumberLiteral");\nvar assertLongNumberLiteral = assertTypeOf("LongNumberLiteral");\nvar assertFloatLiteral = assertTypeOf("FloatLiteral");\nvar assertElem = assertTypeOf("Elem");\nvar assertIndexInFuncSection = assertTypeOf("IndexInFuncSection");\nvar assertValtypeLiteral = assertTypeOf("ValtypeLiteral");\nvar assertTypeInstruction = assertTypeOf("TypeInstruction");\nvar assertStart = assertTypeOf("Start");\nvar assertGlobalType = assertTypeOf("GlobalType");\nvar assertLeadingComment = assertTypeOf("LeadingComment");\nvar assertBlockComment = assertTypeOf("BlockComment");\nvar assertData = assertTypeOf("Data");\nvar assertGlobal = assertTypeOf("Global");\nvar assertTable = assertTypeOf("Table");\nvar assertMemory = assertTypeOf("Memory");\nvar assertFuncImportDescr = assertTypeOf("FuncImportDescr");\nvar assertModuleImport = assertTypeOf("ModuleImport");\nvar assertModuleExportDescr = assertTypeOf("ModuleExportDescr");\nvar assertModuleExport = assertTypeOf("ModuleExport");\nvar assertLimit = assertTypeOf("Limit");\nvar assertSignature = assertTypeOf("Signature");\nvar assertProgram = assertTypeOf("Program");\nvar assertIdentifier = assertTypeOf("Identifier");\nvar assertBlockInstruction = assertTypeOf("BlockInstruction");\nvar assertCallInstruction = assertTypeOf("CallInstruction");\nvar assertCallIndirectInstruction = assertTypeOf("CallIndirectInstruction");\nvar assertByteArray = assertTypeOf("ByteArray");\nvar assertFunc = assertTypeOf("Func");\nvar assertInternalBrUnless = assertTypeOf("InternalBrUnless");\nvar assertInternalGoto = assertTypeOf("InternalGoto");\nvar assertInternalCallExtern = assertTypeOf("InternalCallExtern");\nvar assertInternalEndAndReturn = assertTypeOf("InternalEndAndReturn");\nvar unionTypesMap = {\n  Module: ["Node"],\n  ModuleMetadata: ["Node"],\n  ModuleNameMetadata: ["Node"],\n  FunctionNameMetadata: ["Node"],\n  LocalNameMetadata: ["Node"],\n  BinaryModule: ["Node"],\n  QuoteModule: ["Node"],\n  SectionMetadata: ["Node"],\n  ProducersSectionMetadata: ["Node"],\n  ProducerMetadata: ["Node"],\n  ProducerMetadataVersionedName: ["Node"],\n  LoopInstruction: ["Node", "Block", "Instruction"],\n  Instr: ["Node", "Expression", "Instruction"],\n  IfInstruction: ["Node", "Instruction"],\n  StringLiteral: ["Node", "Expression"],\n  NumberLiteral: ["Node", "NumericLiteral", "Expression"],\n  LongNumberLiteral: ["Node", "NumericLiteral", "Expression"],\n  FloatLiteral: ["Node", "NumericLiteral", "Expression"],\n  Elem: ["Node"],\n  IndexInFuncSection: ["Node"],\n  ValtypeLiteral: ["Node", "Expression"],\n  TypeInstruction: ["Node", "Instruction"],\n  Start: ["Node"],\n  GlobalType: ["Node", "ImportDescr"],\n  LeadingComment: ["Node"],\n  BlockComment: ["Node"],\n  Data: ["Node"],\n  Global: ["Node"],\n  Table: ["Node", "ImportDescr"],\n  Memory: ["Node", "ImportDescr"],\n  FuncImportDescr: ["Node", "ImportDescr"],\n  ModuleImport: ["Node"],\n  ModuleExportDescr: ["Node"],\n  ModuleExport: ["Node"],\n  Limit: ["Node"],\n  Signature: ["Node"],\n  Program: ["Node"],\n  Identifier: ["Node", "Expression"],\n  BlockInstruction: ["Node", "Block", "Instruction"],\n  CallInstruction: ["Node", "Instruction"],\n  CallIndirectInstruction: ["Node", "Instruction"],\n  ByteArray: ["Node"],\n  Func: ["Node", "Block"],\n  InternalBrUnless: ["Node", "Intrinsic"],\n  InternalGoto: ["Node", "Intrinsic"],\n  InternalCallExtern: ["Node", "Intrinsic"],\n  InternalEndAndReturn: ["Node", "Intrinsic"]\n};\nvar nodeAndUnionTypes = ["Module", "ModuleMetadata", "ModuleNameMetadata", "FunctionNameMetadata", "LocalNameMetadata", "BinaryModule", "QuoteModule", "SectionMetadata", "ProducersSectionMetadata", "ProducerMetadata", "ProducerMetadataVersionedName", "LoopInstruction", "Instr", "IfInstruction", "StringLiteral", "NumberLiteral", "LongNumberLiteral", "FloatLiteral", "Elem", "IndexInFuncSection", "ValtypeLiteral", "TypeInstruction", "Start", "GlobalType", "LeadingComment", "BlockComment", "Data", "Global", "Table", "Memory", "FuncImportDescr", "ModuleImport", "ModuleExportDescr", "ModuleExport", "Limit", "Signature", "Program", "Identifier", "BlockInstruction", "CallInstruction", "CallIndirectInstruction", "ByteArray", "Func", "InternalBrUnless", "InternalGoto", "InternalCallExtern", "InternalEndAndReturn", "Node", "Block", "Instruction", "Expression", "NumericLiteral", "ImportDescr", "Intrinsic"];\n// CONCATENATED MODULE: ./node_modules/@webassemblyjs/ast/esm/node-helpers.js\n\n\nfunction numberLiteralFromRaw(rawValue) {\n  var instructionType = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : "i32";\n  var original = rawValue; // Remove numeric separators _\n\n  if (typeof rawValue === "string") {\n    rawValue = rawValue.replace(/_/g, "");\n  }\n\n  if (typeof rawValue === "number") {\n    return nodes_numberLiteral(rawValue, String(original));\n  } else {\n    switch (instructionType) {\n      case "i32":\n        {\n          return nodes_numberLiteral(parse32I(rawValue), String(original));\n        }\n\n      case "u32":\n        {\n          return nodes_numberLiteral(parseU32(rawValue), String(original));\n        }\n\n      case "i64":\n        {\n          return longNumberLiteral(parse64I(rawValue), String(original));\n        }\n\n      case "f32":\n        {\n          return floatLiteral(parse32F(rawValue), isNanLiteral(rawValue), isInfLiteral(rawValue), String(original));\n        }\n      // f64\n\n      default:\n        {\n          return floatLiteral(parse64F(rawValue), isNanLiteral(rawValue), isInfLiteral(rawValue), String(original));\n        }\n    }\n  }\n}\nfunction node_helpers_instruction(id) {\n  var args = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n  var namedArgs = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  return nodes_instr(id, undefined, args, namedArgs);\n}\nfunction objectInstruction(id, object) {\n  var args = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];\n  var namedArgs = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n  return nodes_instr(id, object, args, namedArgs);\n}\n/**\n * Decorators\n */\n\nfunction withLoc(n, end, start) {\n  var loc = {\n    start: start,\n    end: end\n  };\n  n.loc = loc;\n  return n;\n}\nfunction withRaw(n, raw) {\n  n.raw = raw;\n  return n;\n}\nfunction funcParam(valtype, id) {\n  return {\n    id: id,\n    valtype: valtype\n  };\n}\nfunction indexLiteral(value) {\n  // $FlowIgnore\n  var x = numberLiteralFromRaw(value, "u32");\n  return x;\n}\nfunction memIndexLiteral(value) {\n  // $FlowIgnore\n  var x = numberLiteralFromRaw(value, "u32");\n  return x;\n}\n// CONCATENATED MODULE: ./node_modules/@webassemblyjs/ast/esm/node-path.js\nfunction _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction findParent(_ref, cb) {\n  var parentPath = _ref.parentPath;\n\n  if (parentPath == null) {\n    throw new Error("node is root");\n  }\n\n  var currentPath = parentPath;\n\n  while (cb(currentPath) !== false) {\n    // Hit the root node, stop\n    // $FlowIgnore\n    if (currentPath.parentPath == null) {\n      return null;\n    } // $FlowIgnore\n\n\n    currentPath = currentPath.parentPath;\n  }\n\n  return currentPath.node;\n}\n\nfunction insertBefore(context, newNode) {\n  return insert(context, newNode);\n}\n\nfunction insertAfter(context, newNode) {\n  return insert(context, newNode, 1);\n}\n\nfunction insert(_ref2, newNode) {\n  var node = _ref2.node,\n      inList = _ref2.inList,\n      parentPath = _ref2.parentPath,\n      parentKey = _ref2.parentKey;\n  var indexOffset = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n\n  if (!inList) {\n    throw new Error(\'inList\' + " error: " + ("insert can only be used for nodes that are within lists" || false));\n  }\n\n  if (!(parentPath != null)) {\n    throw new Error(\'parentPath != null\' + " error: " + ("Can not remove root node" || false));\n  }\n\n  // $FlowIgnore\n  var parentList = parentPath.node[parentKey];\n  var indexInList = parentList.findIndex(function (n) {\n    return n === node;\n  });\n  parentList.splice(indexInList + indexOffset, 0, newNode);\n}\n\nfunction remove(_ref3) {\n  var node = _ref3.node,\n      parentKey = _ref3.parentKey,\n      parentPath = _ref3.parentPath;\n\n  if (!(parentPath != null)) {\n    throw new Error(\'parentPath != null\' + " error: " + ("Can not remove root node" || false));\n  }\n\n  // $FlowIgnore\n  var parentNode = parentPath.node; // $FlowIgnore\n\n  var parentProperty = parentNode[parentKey];\n\n  if (Array.isArray(parentProperty)) {\n    // $FlowIgnore\n    parentNode[parentKey] = parentProperty.filter(function (n) {\n      return n !== node;\n    });\n  } else {\n    // $FlowIgnore\n    delete parentNode[parentKey];\n  }\n\n  node._deleted = true;\n}\n\nfunction node_path_stop(context) {\n  context.shouldStop = true;\n}\n\nfunction replaceWith(context, newNode) {\n  // $FlowIgnore\n  var parentNode = context.parentPath.node; // $FlowIgnore\n\n  var parentProperty = parentNode[context.parentKey];\n\n  if (Array.isArray(parentProperty)) {\n    var indexInList = parentProperty.findIndex(function (n) {\n      return n === context.node;\n    });\n    parentProperty.splice(indexInList, 1, newNode);\n  } else {\n    // $FlowIgnore\n    parentNode[context.parentKey] = newNode;\n  }\n\n  context.node._deleted = true;\n  context.node = newNode;\n} // bind the context to the first argument of node operations\n\n\nfunction bindNodeOperations(operations, context) {\n  var keys = Object.keys(operations);\n  var boundOperations = {};\n  keys.forEach(function (key) {\n    boundOperations[key] = operations[key].bind(null, context);\n  });\n  return boundOperations;\n}\n\nfunction createPathOperations(context) {\n  // $FlowIgnore\n  return bindNodeOperations({\n    findParent: findParent,\n    replaceWith: replaceWith,\n    remove: remove,\n    insertBefore: insertBefore,\n    insertAfter: insertAfter,\n    stop: node_path_stop\n  }, context);\n}\n\nfunction createPath(context) {\n  var path = _extends({}, context); // $FlowIgnore\n\n\n  Object.assign(path, createPathOperations(path)); // $FlowIgnore\n\n  return path;\n}\n// CONCATENATED MODULE: ./node_modules/@webassemblyjs/ast/esm/traverse.js\n\n // recursively walks the AST starting at the given node. The callback is invoked for\n// and object that has a \'type\' property.\n\nfunction traverse_walk(context, callback) {\n  var stop = false;\n\n  function innerWalk(context, callback) {\n    if (stop) {\n      return;\n    }\n\n    var node = context.node;\n\n    if (node === undefined) {\n      console.warn("traversing with an empty context");\n      return;\n    }\n\n    if (node._deleted === true) {\n      return;\n    }\n\n    var path = createPath(context);\n    callback(node.type, path);\n\n    if (path.shouldStop) {\n      stop = true;\n      return;\n    }\n\n    Object.keys(node).forEach(function (prop) {\n      var value = node[prop];\n\n      if (value === null || value === undefined) {\n        return;\n      }\n\n      var valueAsArray = Array.isArray(value) ? value : [value];\n      valueAsArray.forEach(function (childNode) {\n        if (typeof childNode.type === "string") {\n          var childContext = {\n            node: childNode,\n            parentKey: prop,\n            parentPath: path,\n            shouldStop: false,\n            inList: Array.isArray(value)\n          };\n          innerWalk(childContext, callback);\n        }\n      });\n    });\n  }\n\n  innerWalk(context, callback);\n}\n\nvar noop = function noop() {};\n\nfunction traverse(node, visitors) {\n  var before = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : noop;\n  var after = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : noop;\n  Object.keys(visitors).forEach(function (visitor) {\n    if (!nodeAndUnionTypes.includes(visitor)) {\n      throw new Error("Unexpected visitor ".concat(visitor));\n    }\n  });\n  var context = {\n    node: node,\n    inList: false,\n    shouldStop: false,\n    parentPath: null,\n    parentKey: null\n  };\n  traverse_walk(context, function (type, path) {\n    if (typeof visitors[type] === "function") {\n      before(type, path);\n      visitors[type](path);\n      after(type, path);\n    }\n\n    var unionTypes = unionTypesMap[type];\n\n    if (!unionTypes) {\n      throw new Error("Unexpected node type ".concat(type));\n    }\n\n    unionTypes.forEach(function (unionType) {\n      if (typeof visitors[unionType] === "function") {\n        before(unionType, path);\n        visitors[unionType](path);\n        after(unionType, path);\n      }\n    });\n  });\n}\n// CONCATENATED MODULE: ./node_modules/@webassemblyjs/ast/esm/signatures.js\nfunction signatures_sign(input, output) {\n  return [input, output];\n}\n\nvar u32 = "u32";\nvar i32 = "i32";\nvar i64 = "i64";\nvar f32 = "f32";\nvar f64 = "f64";\n\nvar vector = function vector(t) {\n  var vecType = [t]; // $FlowIgnore\n\n  vecType.vector = true;\n  return vecType;\n};\n\nvar controlInstructions = {\n  unreachable: signatures_sign([], []),\n  nop: signatures_sign([], []),\n  // block ?\n  // loop ?\n  // if ?\n  // if else ?\n  br: signatures_sign([u32], []),\n  br_if: signatures_sign([u32], []),\n  br_table: signatures_sign(vector(u32), []),\n  return: signatures_sign([], []),\n  call: signatures_sign([u32], []),\n  call_indirect: signatures_sign([u32], [])\n};\nvar parametricInstructions = {\n  drop: signatures_sign([], []),\n  select: signatures_sign([], [])\n};\nvar variableInstructions = {\n  get_local: signatures_sign([u32], []),\n  set_local: signatures_sign([u32], []),\n  tee_local: signatures_sign([u32], []),\n  get_global: signatures_sign([u32], []),\n  set_global: signatures_sign([u32], [])\n};\nvar memoryInstructions = {\n  "i32.load": signatures_sign([u32, u32], [i32]),\n  "i64.load": signatures_sign([u32, u32], []),\n  "f32.load": signatures_sign([u32, u32], []),\n  "f64.load": signatures_sign([u32, u32], []),\n  "i32.load8_s": signatures_sign([u32, u32], [i32]),\n  "i32.load8_u": signatures_sign([u32, u32], [i32]),\n  "i32.load16_s": signatures_sign([u32, u32], [i32]),\n  "i32.load16_u": signatures_sign([u32, u32], [i32]),\n  "i64.load8_s": signatures_sign([u32, u32], [i64]),\n  "i64.load8_u": signatures_sign([u32, u32], [i64]),\n  "i64.load16_s": signatures_sign([u32, u32], [i64]),\n  "i64.load16_u": signatures_sign([u32, u32], [i64]),\n  "i64.load32_s": signatures_sign([u32, u32], [i64]),\n  "i64.load32_u": signatures_sign([u32, u32], [i64]),\n  "i32.store": signatures_sign([u32, u32], []),\n  "i64.store": signatures_sign([u32, u32], []),\n  "f32.store": signatures_sign([u32, u32], []),\n  "f64.store": signatures_sign([u32, u32], []),\n  "i32.store8": signatures_sign([u32, u32], []),\n  "i32.store16": signatures_sign([u32, u32], []),\n  "i64.store8": signatures_sign([u32, u32], []),\n  "i64.store16": signatures_sign([u32, u32], []),\n  "i64.store32": signatures_sign([u32, u32], []),\n  current_memory: signatures_sign([], []),\n  grow_memory: signatures_sign([], [])\n};\nvar numericInstructions = {\n  "i32.const": signatures_sign([i32], [i32]),\n  "i64.const": signatures_sign([i64], [i64]),\n  "f32.const": signatures_sign([f32], [f32]),\n  "f64.const": signatures_sign([f64], [f64]),\n  "i32.eqz": signatures_sign([i32], [i32]),\n  "i32.eq": signatures_sign([i32, i32], [i32]),\n  "i32.ne": signatures_sign([i32, i32], [i32]),\n  "i32.lt_s": signatures_sign([i32, i32], [i32]),\n  "i32.lt_u": signatures_sign([i32, i32], [i32]),\n  "i32.gt_s": signatures_sign([i32, i32], [i32]),\n  "i32.gt_u": signatures_sign([i32, i32], [i32]),\n  "i32.le_s": signatures_sign([i32, i32], [i32]),\n  "i32.le_u": signatures_sign([i32, i32], [i32]),\n  "i32.ge_s": signatures_sign([i32, i32], [i32]),\n  "i32.ge_u": signatures_sign([i32, i32], [i32]),\n  "i64.eqz": signatures_sign([i64], [i64]),\n  "i64.eq": signatures_sign([i64, i64], [i32]),\n  "i64.ne": signatures_sign([i64, i64], [i32]),\n  "i64.lt_s": signatures_sign([i64, i64], [i32]),\n  "i64.lt_u": signatures_sign([i64, i64], [i32]),\n  "i64.gt_s": signatures_sign([i64, i64], [i32]),\n  "i64.gt_u": signatures_sign([i64, i64], [i32]),\n  "i64.le_s": signatures_sign([i64, i64], [i32]),\n  "i64.le_u": signatures_sign([i64, i64], [i32]),\n  "i64.ge_s": signatures_sign([i64, i64], [i32]),\n  "i64.ge_u": signatures_sign([i64, i64], [i32]),\n  "f32.eq": signatures_sign([f32, f32], [i32]),\n  "f32.ne": signatures_sign([f32, f32], [i32]),\n  "f32.lt": signatures_sign([f32, f32], [i32]),\n  "f32.gt": signatures_sign([f32, f32], [i32]),\n  "f32.le": signatures_sign([f32, f32], [i32]),\n  "f32.ge": signatures_sign([f32, f32], [i32]),\n  "f64.eq": signatures_sign([f64, f64], [i32]),\n  "f64.ne": signatures_sign([f64, f64], [i32]),\n  "f64.lt": signatures_sign([f64, f64], [i32]),\n  "f64.gt": signatures_sign([f64, f64], [i32]),\n  "f64.le": signatures_sign([f64, f64], [i32]),\n  "f64.ge": signatures_sign([f64, f64], [i32]),\n  "i32.clz": signatures_sign([i32], [i32]),\n  "i32.ctz": signatures_sign([i32], [i32]),\n  "i32.popcnt": signatures_sign([i32], [i32]),\n  "i32.add": signatures_sign([i32, i32], [i32]),\n  "i32.sub": signatures_sign([i32, i32], [i32]),\n  "i32.mul": signatures_sign([i32, i32], [i32]),\n  "i32.div_s": signatures_sign([i32, i32], [i32]),\n  "i32.div_u": signatures_sign([i32, i32], [i32]),\n  "i32.rem_s": signatures_sign([i32, i32], [i32]),\n  "i32.rem_u": signatures_sign([i32, i32], [i32]),\n  "i32.and": signatures_sign([i32, i32], [i32]),\n  "i32.or": signatures_sign([i32, i32], [i32]),\n  "i32.xor": signatures_sign([i32, i32], [i32]),\n  "i32.shl": signatures_sign([i32, i32], [i32]),\n  "i32.shr_s": signatures_sign([i32, i32], [i32]),\n  "i32.shr_u": signatures_sign([i32, i32], [i32]),\n  "i32.rotl": signatures_sign([i32, i32], [i32]),\n  "i32.rotr": signatures_sign([i32, i32], [i32]),\n  "i64.clz": signatures_sign([i64], [i64]),\n  "i64.ctz": signatures_sign([i64], [i64]),\n  "i64.popcnt": signatures_sign([i64], [i64]),\n  "i64.add": signatures_sign([i64, i64], [i64]),\n  "i64.sub": signatures_sign([i64, i64], [i64]),\n  "i64.mul": signatures_sign([i64, i64], [i64]),\n  "i64.div_s": signatures_sign([i64, i64], [i64]),\n  "i64.div_u": signatures_sign([i64, i64], [i64]),\n  "i64.rem_s": signatures_sign([i64, i64], [i64]),\n  "i64.rem_u": signatures_sign([i64, i64], [i64]),\n  "i64.and": signatures_sign([i64, i64], [i64]),\n  "i64.or": signatures_sign([i64, i64], [i64]),\n  "i64.xor": signatures_sign([i64, i64], [i64]),\n  "i64.shl": signatures_sign([i64, i64], [i64]),\n  "i64.shr_s": signatures_sign([i64, i64], [i64]),\n  "i64.shr_u": signatures_sign([i64, i64], [i64]),\n  "i64.rotl": signatures_sign([i64, i64], [i64]),\n  "i64.rotr": signatures_sign([i64, i64], [i64]),\n  "f32.abs": signatures_sign([f32], [f32]),\n  "f32.neg": signatures_sign([f32], [f32]),\n  "f32.ceil": signatures_sign([f32], [f32]),\n  "f32.floor": signatures_sign([f32], [f32]),\n  "f32.trunc": signatures_sign([f32], [f32]),\n  "f32.nearest": signatures_sign([f32], [f32]),\n  "f32.sqrt": signatures_sign([f32], [f32]),\n  "f32.add": signatures_sign([f32, f32], [f32]),\n  "f32.sub": signatures_sign([f32, f32], [f32]),\n  "f32.mul": signatures_sign([f32, f32], [f32]),\n  "f32.div": signatures_sign([f32, f32], [f32]),\n  "f32.min": signatures_sign([f32, f32], [f32]),\n  "f32.max": signatures_sign([f32, f32], [f32]),\n  "f32.copysign": signatures_sign([f32, f32], [f32]),\n  "f64.abs": signatures_sign([f64], [f64]),\n  "f64.neg": signatures_sign([f64], [f64]),\n  "f64.ceil": signatures_sign([f64], [f64]),\n  "f64.floor": signatures_sign([f64], [f64]),\n  "f64.trunc": signatures_sign([f64], [f64]),\n  "f64.nearest": signatures_sign([f64], [f64]),\n  "f64.sqrt": signatures_sign([f64], [f64]),\n  "f64.add": signatures_sign([f64, f64], [f64]),\n  "f64.sub": signatures_sign([f64, f64], [f64]),\n  "f64.mul": signatures_sign([f64, f64], [f64]),\n  "f64.div": signatures_sign([f64, f64], [f64]),\n  "f64.min": signatures_sign([f64, f64], [f64]),\n  "f64.max": signatures_sign([f64, f64], [f64]),\n  "f64.copysign": signatures_sign([f64, f64], [f64]),\n  "i32.wrap/i64": signatures_sign([i64], [i32]),\n  "i32.trunc_s/f32": signatures_sign([f32], [i32]),\n  "i32.trunc_u/f32": signatures_sign([f32], [i32]),\n  "i32.trunc_s/f64": signatures_sign([f32], [i32]),\n  "i32.trunc_u/f64": signatures_sign([f64], [i32]),\n  "i64.extend_s/i32": signatures_sign([i32], [i64]),\n  "i64.extend_u/i32": signatures_sign([i32], [i64]),\n  "i64.trunc_s/f32": signatures_sign([f32], [i64]),\n  "i64.trunc_u/f32": signatures_sign([f32], [i64]),\n  "i64.trunc_s/f64": signatures_sign([f64], [i64]),\n  "i64.trunc_u/f64": signatures_sign([f64], [i64]),\n  "f32.convert_s/i32": signatures_sign([i32], [f32]),\n  "f32.convert_u/i32": signatures_sign([i32], [f32]),\n  "f32.convert_s/i64": signatures_sign([i64], [f32]),\n  "f32.convert_u/i64": signatures_sign([i64], [f32]),\n  "f32.demote/f64": signatures_sign([f64], [f32]),\n  "f64.convert_s/i32": signatures_sign([i32], [f64]),\n  "f64.convert_u/i32": signatures_sign([i32], [f64]),\n  "f64.convert_s/i64": signatures_sign([i64], [f64]),\n  "f64.convert_u/i64": signatures_sign([i64], [f64]),\n  "f64.promote/f32": signatures_sign([f32], [f64]),\n  "i32.reinterpret/f32": signatures_sign([f32], [i32]),\n  "i64.reinterpret/f64": signatures_sign([f64], [i64]),\n  "f32.reinterpret/i32": signatures_sign([i32], [f32]),\n  "f64.reinterpret/i64": signatures_sign([i64], [f64])\n};\nvar signatures = Object.assign({}, controlInstructions, parametricInstructions, variableInstructions, memoryInstructions, numericInstructions);\n// CONCATENATED MODULE: ./node_modules/@webassemblyjs/helper-wasm-bytecode/esm/section.js\nfunction getSectionForNode(n) {\n  switch (n.type) {\n    case "ModuleImport":\n      return "import";\n\n    case "CallInstruction":\n    case "CallIndirectInstruction":\n    case "Func":\n    case "Instr":\n      return "code";\n\n    case "ModuleExport":\n      return "export";\n\n    case "Start":\n      return "start";\n\n    case "TypeInstruction":\n      return "type";\n\n    case "IndexInFuncSection":\n      return "func";\n\n    case "Global":\n      return "global";\n    // No section\n\n    default:\n      return;\n  }\n}\n// CONCATENATED MODULE: ./node_modules/@webassemblyjs/helper-wasm-bytecode/esm/index.js\nvar illegalop = "illegal";\nvar magicModuleHeader = [0x00, 0x61, 0x73, 0x6d];\nvar moduleVersion = [0x01, 0x00, 0x00, 0x00];\n\nfunction invertMap(obj) {\n  var keyModifierFn = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : function (k) {\n    return k;\n  };\n  var result = {};\n  var keys = Object.keys(obj);\n\n  for (var i = 0, length = keys.length; i < length; i++) {\n    result[keyModifierFn(obj[keys[i]])] = keys[i];\n  }\n\n  return result;\n}\n\nfunction createSymbolObject(name\n/*: string */\n, object\n/*: string */\n)\n/*: Symbol*/\n{\n  var numberOfArgs\n  /*: number*/\n  = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n  return {\n    name: name,\n    object: object,\n    numberOfArgs: numberOfArgs\n  };\n}\n\nfunction createSymbol(name\n/*: string */\n)\n/*: Symbol*/\n{\n  var numberOfArgs\n  /*: number*/\n  = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n  return {\n    name: name,\n    numberOfArgs: numberOfArgs\n  };\n}\n\nvar types = {\n  func: 0x60,\n  result: 0x40\n};\nvar exportTypes = {\n  0x00: "Func",\n  0x01: "Table",\n  0x02: "Mem",\n  0x03: "Global"\n};\nvar exportTypesByName = invertMap(exportTypes);\nvar valtypes = {\n  0x7f: "i32",\n  0x7e: "i64",\n  0x7d: "f32",\n  0x7c: "f64",\n  0x7b: "v128"\n};\nvar valtypesByString = invertMap(valtypes);\nvar tableTypes = {\n  0x70: "anyfunc"\n};\nvar blockTypes = Object.assign({}, valtypes, {\n  // https://webassembly.github.io/spec/core/binary/types.html#binary-blocktype\n  0x40: null,\n  // https://webassembly.github.io/spec/core/binary/types.html#binary-valtype\n  0x7f: "i32",\n  0x7e: "i64",\n  0x7d: "f32",\n  0x7c: "f64"\n});\nvar globalTypes = {\n  0x00: "const",\n  0x01: "var"\n};\nvar globalTypesByString = invertMap(globalTypes);\nvar importTypes = {\n  0x00: "func",\n  0x01: "table",\n  0x02: "mem",\n  0x03: "global"\n};\nvar esm_sections = {\n  custom: 0,\n  type: 1,\n  import: 2,\n  func: 3,\n  table: 4,\n  memory: 5,\n  global: 6,\n  export: 7,\n  start: 8,\n  element: 9,\n  code: 10,\n  data: 11\n};\nvar symbolsByByte = {\n  0x00: createSymbol("unreachable"),\n  0x01: createSymbol("nop"),\n  0x02: createSymbol("block"),\n  0x03: createSymbol("loop"),\n  0x04: createSymbol("if"),\n  0x05: createSymbol("else"),\n  0x06: illegalop,\n  0x07: illegalop,\n  0x08: illegalop,\n  0x09: illegalop,\n  0x0a: illegalop,\n  0x0b: createSymbol("end"),\n  0x0c: createSymbol("br", 1),\n  0x0d: createSymbol("br_if", 1),\n  0x0e: createSymbol("br_table"),\n  0x0f: createSymbol("return"),\n  0x10: createSymbol("call", 1),\n  0x11: createSymbol("call_indirect", 2),\n  0x12: illegalop,\n  0x13: illegalop,\n  0x14: illegalop,\n  0x15: illegalop,\n  0x16: illegalop,\n  0x17: illegalop,\n  0x18: illegalop,\n  0x19: illegalop,\n  0x1a: createSymbol("drop"),\n  0x1b: createSymbol("select"),\n  0x1c: illegalop,\n  0x1d: illegalop,\n  0x1e: illegalop,\n  0x1f: illegalop,\n  0x20: createSymbol("get_local", 1),\n  0x21: createSymbol("set_local", 1),\n  0x22: createSymbol("tee_local", 1),\n  0x23: createSymbol("get_global", 1),\n  0x24: createSymbol("set_global", 1),\n  0x25: illegalop,\n  0x26: illegalop,\n  0x27: illegalop,\n  0x28: createSymbolObject("load", "u32", 1),\n  0x29: createSymbolObject("load", "u64", 1),\n  0x2a: createSymbolObject("load", "f32", 1),\n  0x2b: createSymbolObject("load", "f64", 1),\n  0x2c: createSymbolObject("load8_s", "u32", 1),\n  0x2d: createSymbolObject("load8_u", "u32", 1),\n  0x2e: createSymbolObject("load16_s", "u32", 1),\n  0x2f: createSymbolObject("load16_u", "u32", 1),\n  0x30: createSymbolObject("load8_s", "u64", 1),\n  0x31: createSymbolObject("load8_u", "u64", 1),\n  0x32: createSymbolObject("load16_s", "u64", 1),\n  0x33: createSymbolObject("load16_u", "u64", 1),\n  0x34: createSymbolObject("load32_s", "u64", 1),\n  0x35: createSymbolObject("load32_u", "u64", 1),\n  0x36: createSymbolObject("store", "u32", 1),\n  0x37: createSymbolObject("store", "u64", 1),\n  0x38: createSymbolObject("store", "f32", 1),\n  0x39: createSymbolObject("store", "f64", 1),\n  0x3a: createSymbolObject("store8", "u32", 1),\n  0x3b: createSymbolObject("store16", "u32", 1),\n  0x3c: createSymbolObject("store8", "u64", 1),\n  0x3d: createSymbolObject("store16", "u64", 1),\n  0x3e: createSymbolObject("store32", "u64", 1),\n  0x3f: createSymbolObject("current_memory"),\n  0x40: createSymbolObject("grow_memory"),\n  0x41: createSymbolObject("const", "i32", 1),\n  0x42: createSymbolObject("const", "i64", 1),\n  0x43: createSymbolObject("const", "f32", 1),\n  0x44: createSymbolObject("const", "f64", 1),\n  0x45: createSymbolObject("eqz", "i32"),\n  0x46: createSymbolObject("eq", "i32"),\n  0x47: createSymbolObject("ne", "i32"),\n  0x48: createSymbolObject("lt_s", "i32"),\n  0x49: createSymbolObject("lt_u", "i32"),\n  0x4a: createSymbolObject("gt_s", "i32"),\n  0x4b: createSymbolObject("gt_u", "i32"),\n  0x4c: createSymbolObject("le_s", "i32"),\n  0x4d: createSymbolObject("le_u", "i32"),\n  0x4e: createSymbolObject("ge_s", "i32"),\n  0x4f: createSymbolObject("ge_u", "i32"),\n  0x50: createSymbolObject("eqz", "i64"),\n  0x51: createSymbolObject("eq", "i64"),\n  0x52: createSymbolObject("ne", "i64"),\n  0x53: createSymbolObject("lt_s", "i64"),\n  0x54: createSymbolObject("lt_u", "i64"),\n  0x55: createSymbolObject("gt_s", "i64"),\n  0x56: createSymbolObject("gt_u", "i64"),\n  0x57: createSymbolObject("le_s", "i64"),\n  0x58: createSymbolObject("le_u", "i64"),\n  0x59: createSymbolObject("ge_s", "i64"),\n  0x5a: createSymbolObject("ge_u", "i64"),\n  0x5b: createSymbolObject("eq", "f32"),\n  0x5c: createSymbolObject("ne", "f32"),\n  0x5d: createSymbolObject("lt", "f32"),\n  0x5e: createSymbolObject("gt", "f32"),\n  0x5f: createSymbolObject("le", "f32"),\n  0x60: createSymbolObject("ge", "f32"),\n  0x61: createSymbolObject("eq", "f64"),\n  0x62: createSymbolObject("ne", "f64"),\n  0x63: createSymbolObject("lt", "f64"),\n  0x64: createSymbolObject("gt", "f64"),\n  0x65: createSymbolObject("le", "f64"),\n  0x66: createSymbolObject("ge", "f64"),\n  0x67: createSymbolObject("clz", "i32"),\n  0x68: createSymbolObject("ctz", "i32"),\n  0x69: createSymbolObject("popcnt", "i32"),\n  0x6a: createSymbolObject("add", "i32"),\n  0x6b: createSymbolObject("sub", "i32"),\n  0x6c: createSymbolObject("mul", "i32"),\n  0x6d: createSymbolObject("div_s", "i32"),\n  0x6e: createSymbolObject("div_u", "i32"),\n  0x6f: createSymbolObject("rem_s", "i32"),\n  0x70: createSymbolObject("rem_u", "i32"),\n  0x71: createSymbolObject("and", "i32"),\n  0x72: createSymbolObject("or", "i32"),\n  0x73: createSymbolObject("xor", "i32"),\n  0x74: createSymbolObject("shl", "i32"),\n  0x75: createSymbolObject("shr_s", "i32"),\n  0x76: createSymbolObject("shr_u", "i32"),\n  0x77: createSymbolObject("rotl", "i32"),\n  0x78: createSymbolObject("rotr", "i32"),\n  0x79: createSymbolObject("clz", "i64"),\n  0x7a: createSymbolObject("ctz", "i64"),\n  0x7b: createSymbolObject("popcnt", "i64"),\n  0x7c: createSymbolObject("add", "i64"),\n  0x7d: createSymbolObject("sub", "i64"),\n  0x7e: createSymbolObject("mul", "i64"),\n  0x7f: createSymbolObject("div_s", "i64"),\n  0x80: createSymbolObject("div_u", "i64"),\n  0x81: createSymbolObject("rem_s", "i64"),\n  0x82: createSymbolObject("rem_u", "i64"),\n  0x83: createSymbolObject("and", "i64"),\n  0x84: createSymbolObject("or", "i64"),\n  0x85: createSymbolObject("xor", "i64"),\n  0x86: createSymbolObject("shl", "i64"),\n  0x87: createSymbolObject("shr_s", "i64"),\n  0x88: createSymbolObject("shr_u", "i64"),\n  0x89: createSymbolObject("rotl", "i64"),\n  0x8a: createSymbolObject("rotr", "i64"),\n  0x8b: createSymbolObject("abs", "f32"),\n  0x8c: createSymbolObject("neg", "f32"),\n  0x8d: createSymbolObject("ceil", "f32"),\n  0x8e: createSymbolObject("floor", "f32"),\n  0x8f: createSymbolObject("trunc", "f32"),\n  0x90: createSymbolObject("nearest", "f32"),\n  0x91: createSymbolObject("sqrt", "f32"),\n  0x92: createSymbolObject("add", "f32"),\n  0x93: createSymbolObject("sub", "f32"),\n  0x94: createSymbolObject("mul", "f32"),\n  0x95: createSymbolObject("div", "f32"),\n  0x96: createSymbolObject("min", "f32"),\n  0x97: createSymbolObject("max", "f32"),\n  0x98: createSymbolObject("copysign", "f32"),\n  0x99: createSymbolObject("abs", "f64"),\n  0x9a: createSymbolObject("neg", "f64"),\n  0x9b: createSymbolObject("ceil", "f64"),\n  0x9c: createSymbolObject("floor", "f64"),\n  0x9d: createSymbolObject("trunc", "f64"),\n  0x9e: createSymbolObject("nearest", "f64"),\n  0x9f: createSymbolObject("sqrt", "f64"),\n  0xa0: createSymbolObject("add", "f64"),\n  0xa1: createSymbolObject("sub", "f64"),\n  0xa2: createSymbolObject("mul", "f64"),\n  0xa3: createSymbolObject("div", "f64"),\n  0xa4: createSymbolObject("min", "f64"),\n  0xa5: createSymbolObject("max", "f64"),\n  0xa6: createSymbolObject("copysign", "f64"),\n  0xa7: createSymbolObject("wrap/i64", "i32"),\n  0xa8: createSymbolObject("trunc_s/f32", "i32"),\n  0xa9: createSymbolObject("trunc_u/f32", "i32"),\n  0xaa: createSymbolObject("trunc_s/f64", "i32"),\n  0xab: createSymbolObject("trunc_u/f64", "i32"),\n  0xac: createSymbolObject("extend_s/i32", "i64"),\n  0xad: createSymbolObject("extend_u/i32", "i64"),\n  0xae: createSymbolObject("trunc_s/f32", "i64"),\n  0xaf: createSymbolObject("trunc_u/f32", "i64"),\n  0xb0: createSymbolObject("trunc_s/f64", "i64"),\n  0xb1: createSymbolObject("trunc_u/f64", "i64"),\n  0xb2: createSymbolObject("convert_s/i32", "f32"),\n  0xb3: createSymbolObject("convert_u/i32", "f32"),\n  0xb4: createSymbolObject("convert_s/i64", "f32"),\n  0xb5: createSymbolObject("convert_u/i64", "f32"),\n  0xb6: createSymbolObject("demote/f64", "f32"),\n  0xb7: createSymbolObject("convert_s/i32", "f64"),\n  0xb8: createSymbolObject("convert_u/i32", "f64"),\n  0xb9: createSymbolObject("convert_s/i64", "f64"),\n  0xba: createSymbolObject("convert_u/i64", "f64"),\n  0xbb: createSymbolObject("promote/f32", "f64"),\n  0xbc: createSymbolObject("reinterpret/f32", "i32"),\n  0xbd: createSymbolObject("reinterpret/f64", "i64"),\n  0xbe: createSymbolObject("reinterpret/i32", "f32"),\n  0xbf: createSymbolObject("reinterpret/i64", "f64")\n};\nvar symbolsByName = invertMap(symbolsByByte, function (obj) {\n  if (typeof obj.object === "string") {\n    return "".concat(obj.object, ".").concat(obj.name);\n  }\n\n  return obj.name;\n});\n/* harmony default export */ var esm = ({\n  symbolsByByte: symbolsByByte,\n  sections: esm_sections,\n  magicModuleHeader: magicModuleHeader,\n  moduleVersion: moduleVersion,\n  types: types,\n  valtypes: valtypes,\n  exportTypes: exportTypes,\n  blockTypes: blockTypes,\n  tableTypes: tableTypes,\n  globalTypes: globalTypes,\n  importTypes: importTypes,\n  valtypesByString: valtypesByString,\n  globalTypesByString: globalTypesByString,\n  exportTypesByName: exportTypesByName,\n  symbolsByName: symbolsByName\n});\n\n// CONCATENATED MODULE: ./node_modules/@webassemblyjs/ast/esm/utils.js\nfunction _sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }\n\nfunction _slicedToArray(arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return _sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }\n\nfunction utils_typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { utils_typeof = function _typeof(obj) { return typeof obj; }; } else { utils_typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return utils_typeof(obj); }\n\n\n\n\n\nfunction isAnonymous(ident) {\n  return ident.raw === "";\n}\nfunction getSectionMetadata(ast, name) {\n  var section;\n  traverse(ast, {\n    SectionMetadata: function (_SectionMetadata) {\n      function SectionMetadata(_x) {\n        return _SectionMetadata.apply(this, arguments);\n      }\n\n      SectionMetadata.toString = function () {\n        return _SectionMetadata.toString();\n      };\n\n      return SectionMetadata;\n    }(function (_ref) {\n      var node = _ref.node;\n\n      if (node.section === name) {\n        section = node;\n      }\n    })\n  });\n  return section;\n}\nfunction getSectionMetadatas(ast, name) {\n  var sections = [];\n  traverse(ast, {\n    SectionMetadata: function (_SectionMetadata2) {\n      function SectionMetadata(_x2) {\n        return _SectionMetadata2.apply(this, arguments);\n      }\n\n      SectionMetadata.toString = function () {\n        return _SectionMetadata2.toString();\n      };\n\n      return SectionMetadata;\n    }(function (_ref2) {\n      var node = _ref2.node;\n\n      if (node.section === name) {\n        sections.push(node);\n      }\n    })\n  });\n  return sections;\n}\nfunction sortSectionMetadata(m) {\n  if (m.metadata == null) {\n    console.warn("sortSectionMetadata: no metadata to sort");\n    return;\n  } // $FlowIgnore\n\n\n  m.metadata.sections.sort(function (a, b) {\n    var aId = esm.sections[a.section];\n    var bId = esm.sections[b.section];\n\n    if (typeof aId !== "number" || typeof bId !== "number") {\n      throw new Error("Section id not found");\n    }\n\n    return aId - bId;\n  });\n}\nfunction orderedInsertNode(m, n) {\n  assertHasLoc(n);\n  var didInsert = false;\n\n  if (n.type === "ModuleExport") {\n    m.fields.push(n);\n    return;\n  }\n\n  m.fields = m.fields.reduce(function (acc, field) {\n    var fieldEndCol = Infinity;\n\n    if (field.loc != null) {\n      // $FlowIgnore\n      fieldEndCol = field.loc.end.column;\n    } // $FlowIgnore: assertHasLoc ensures that\n\n\n    if (didInsert === false && n.loc.start.column < fieldEndCol) {\n      didInsert = true;\n      acc.push(n);\n    }\n\n    acc.push(field);\n    return acc;\n  }, []); // Handles empty modules or n is the last element\n\n  if (didInsert === false) {\n    m.fields.push(n);\n  }\n}\nfunction assertHasLoc(n) {\n  if (n.loc == null || n.loc.start == null || n.loc.end == null) {\n    throw new Error("Internal failure: node (".concat(JSON.stringify(n.type), ") has no location information"));\n  }\n}\nfunction getEndOfSection(s) {\n  assertHasLoc(s.size);\n  return s.startOffset + s.size.value + ( // $FlowIgnore\n  s.size.loc.end.column - s.size.loc.start.column);\n}\nfunction shiftLoc(node, delta) {\n  // $FlowIgnore\n  node.loc.start.column += delta; // $FlowIgnore\n\n  node.loc.end.column += delta;\n}\nfunction shiftSection(ast, node, delta) {\n  if (node.type !== "SectionMetadata") {\n    throw new Error("Can not shift node " + JSON.stringify(node.type));\n  }\n\n  node.startOffset += delta;\n\n  if (utils_typeof(node.size.loc) === "object") {\n    shiftLoc(node.size, delta);\n  } // Custom sections doesn\'t have vectorOfSize\n\n\n  if (utils_typeof(node.vectorOfSize) === "object" && utils_typeof(node.vectorOfSize.loc) === "object") {\n    shiftLoc(node.vectorOfSize, delta);\n  }\n\n  var sectionName = node.section; // shift node locations within that section\n\n  traverse(ast, {\n    Node: function Node(_ref3) {\n      var node = _ref3.node;\n      var section = getSectionForNode(node);\n\n      if (section === sectionName && utils_typeof(node.loc) === "object") {\n        shiftLoc(node, delta);\n      }\n    }\n  });\n}\nfunction signatureForOpcode(object, name) {\n  var opcodeName = name;\n\n  if (object !== undefined && object !== "") {\n    opcodeName = object + "." + name;\n  }\n\n  var sign = signatures[opcodeName];\n\n  if (sign == undefined) {\n    // TODO: Uncomment this when br_table and others has been done\n    //throw new Error("Invalid opcode: "+opcodeName);\n    return [object, object];\n  }\n\n  return sign[0];\n}\nfunction getUniqueNameGenerator() {\n  var inc = {};\n  return function () {\n    var prefix = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : "temp";\n\n    if (!(prefix in inc)) {\n      inc[prefix] = 0;\n    } else {\n      inc[prefix] = inc[prefix] + 1;\n    }\n\n    return prefix + "_" + inc[prefix];\n  };\n}\nfunction getStartByteOffset(n) {\n  // $FlowIgnore\n  if (typeof n.loc === "undefined" || typeof n.loc.start === "undefined") {\n    throw new Error( // $FlowIgnore\n    "Can not get byte offset without loc informations, node: " + String(n.id));\n  }\n\n  return n.loc.start.column;\n}\nfunction getEndByteOffset(n) {\n  // $FlowIgnore\n  if (typeof n.loc === "undefined" || typeof n.loc.end === "undefined") {\n    throw new Error("Can not get byte offset without loc informations, node: " + n.type);\n  }\n\n  return n.loc.end.column;\n}\nfunction getFunctionBeginingByteOffset(n) {\n  if (!(n.body.length > 0)) {\n    throw new Error(\'n.body.length > 0\' + " error: " + (undefined || "unknown"));\n  }\n\n  var _n$body = _slicedToArray(n.body, 1),\n      firstInstruction = _n$body[0];\n\n  return getStartByteOffset(firstInstruction);\n}\nfunction getEndBlockByteOffset(n) {\n  // $FlowIgnore\n  if (!(n.instr.length > 0 || n.body.length > 0)) {\n    throw new Error(\'n.instr.length > 0 || n.body.length > 0\' + " error: " + (undefined || "unknown"));\n  }\n\n  var lastInstruction;\n\n  if (n.instr) {\n    // $FlowIgnore\n    lastInstruction = n.instr[n.instr.length - 1];\n  }\n\n  if (n.body) {\n    // $FlowIgnore\n    lastInstruction = n.body[n.body.length - 1];\n  }\n\n  if (!(utils_typeof(lastInstruction) === "object")) {\n    throw new Error(\'typeof lastInstruction === "object"\' + " error: " + (undefined || "unknown"));\n  }\n\n  // $FlowIgnore\n  return getStartByteOffset(lastInstruction);\n}\nfunction getStartBlockByteOffset(n) {\n  // $FlowIgnore\n  if (!(n.instr.length > 0 || n.body.length > 0)) {\n    throw new Error(\'n.instr.length > 0 || n.body.length > 0\' + " error: " + (undefined || "unknown"));\n  }\n\n  var fistInstruction;\n\n  if (n.instr) {\n    // $FlowIgnore\n    var _n$instr = _slicedToArray(n.instr, 1);\n\n    fistInstruction = _n$instr[0];\n  }\n\n  if (n.body) {\n    // $FlowIgnore\n    var _n$body2 = _slicedToArray(n.body, 1);\n\n    fistInstruction = _n$body2[0];\n  }\n\n  if (!(utils_typeof(fistInstruction) === "object")) {\n    throw new Error(\'typeof fistInstruction === "object"\' + " error: " + (undefined || "unknown"));\n  }\n\n  // $FlowIgnore\n  return getStartByteOffset(fistInstruction);\n}\n// CONCATENATED MODULE: ./node_modules/@webassemblyjs/ast/esm/clone.js\nfunction cloneNode(n) {\n  // $FlowIgnore\n  var newObj = {};\n\n  for (var k in n) {\n    newObj[k] = n[k];\n  }\n\n  return newObj;\n}\n// CONCATENATED MODULE: ./node_modules/@webassemblyjs/ast/esm/index.js\n\n\n\n\n\n\n// EXTERNAL MODULE: ./node_modules/@xtuc/long/src/long.js\nvar src_long = __webpack_require__("./node_modules/@xtuc/long/src/long.js");\nvar long_default = /*#__PURE__*/__webpack_require__.n(src_long);\n\n// CONCATENATED MODULE: ./node_modules/@webassemblyjs/wast-printer/esm/index.js\nfunction esm_typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { esm_typeof = function _typeof(obj) { return typeof obj; }; } else { esm_typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return esm_typeof(obj); }\n\nfunction esm_sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }\n\nfunction esm_slicedToArray(arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return esm_sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }\n\n\n\nvar compact = false;\nvar space = " ";\n\nvar quote = function quote(str) {\n  return "\\"".concat(str, "\\"");\n};\n\nfunction indent(nb) {\n  return Array(nb).fill(space + space).join("");\n} // TODO(sven): allow arbitrary ast nodes\n\n\nfunction print(n) {\n  if (n.type === "Program") {\n    return printProgram(n, 0);\n  } else {\n    throw new Error("Unsupported node in print of type: " + String(n.type));\n  }\n}\n\nfunction printProgram(n, depth) {\n  return n.body.reduce(function (acc, child) {\n    if (child.type === "Module") {\n      acc += printModule(child, depth + 1);\n    }\n\n    if (child.type === "Func") {\n      acc += printFunc(child, depth + 1);\n    }\n\n    if (child.type === "BlockComment") {\n      acc += printBlockComment(child);\n    }\n\n    if (child.type === "LeadingComment") {\n      acc += printLeadingComment(child);\n    }\n\n    if (compact === false) {\n      acc += "\\n";\n    }\n\n    return acc;\n  }, "");\n}\n\nfunction printTypeInstruction(n) {\n  var out = "";\n  out += "(";\n  out += "type";\n  out += space;\n\n  if (n.id != null) {\n    out += printIndex(n.id);\n    out += space;\n  }\n\n  out += "(";\n  out += "func";\n  n.functype.params.forEach(function (param) {\n    out += space;\n    out += "(";\n    out += "param";\n    out += space;\n    out += printFuncParam(param);\n    out += ")";\n  });\n  n.functype.results.forEach(function (result) {\n    out += space;\n    out += "(";\n    out += "result";\n    out += space;\n    out += result;\n    out += ")";\n  });\n  out += ")"; // func\n\n  out += ")";\n  return out;\n}\n\nfunction printModule(n, depth) {\n  var out = "(";\n  out += "module";\n\n  if (typeof n.id === "string") {\n    out += space;\n    out += n.id;\n  }\n\n  if (compact === false) {\n    out += "\\n";\n  } else {\n    out += space;\n  }\n\n  n.fields.forEach(function (field) {\n    if (compact === false) {\n      out += indent(depth);\n    }\n\n    switch (field.type) {\n      case "Func":\n        {\n          out += printFunc(field, depth + 1);\n          break;\n        }\n\n      case "TypeInstruction":\n        {\n          out += printTypeInstruction(field);\n          break;\n        }\n\n      case "Table":\n        {\n          out += printTable(field);\n          break;\n        }\n\n      case "Global":\n        {\n          out += printGlobal(field, depth + 1);\n          break;\n        }\n\n      case "ModuleExport":\n        {\n          out += printModuleExport(field);\n          break;\n        }\n\n      case "ModuleImport":\n        {\n          out += printModuleImport(field);\n          break;\n        }\n\n      case "Memory":\n        {\n          out += printMemory(field);\n          break;\n        }\n\n      case "BlockComment":\n        {\n          out += printBlockComment(field);\n          break;\n        }\n\n      case "LeadingComment":\n        {\n          out += printLeadingComment(field);\n          break;\n        }\n\n      case "Start":\n        {\n          out += printStart(field);\n          break;\n        }\n\n      case "Elem":\n        {\n          out += printElem(field, depth);\n          break;\n        }\n\n      case "Data":\n        {\n          out += printData(field, depth);\n          break;\n        }\n\n      default:\n        throw new Error("Unsupported node in printModule: " + String(field.type));\n    }\n\n    if (compact === false) {\n      out += "\\n";\n    }\n  });\n  out += ")";\n  return out;\n}\n\nfunction printData(n, depth) {\n  var out = "";\n  out += "(";\n  out += "data";\n  out += space;\n  out += printIndex(n.memoryIndex);\n  out += space;\n  out += printInstruction(n.offset, depth);\n  out += space;\n  out += \'"\';\n  n.init.values.forEach(function (byte) {\n    // Avoid non-displayable characters\n    if (byte <= 31 || byte == 34 || byte == 92 || byte >= 127) {\n      out += "\\\\";\n      out += ("00" + byte.toString(16)).substr(-2);\n    } else if (byte > 255) {\n      throw new Error("Unsupported byte in data segment: " + byte);\n    } else {\n      out += String.fromCharCode(byte);\n    }\n  });\n  out += \'"\';\n  out += ")";\n  return out;\n}\n\nfunction printElem(n, depth) {\n  var out = "";\n  out += "(";\n  out += "elem";\n  out += space;\n  out += printIndex(n.table);\n\n  var _n$offset = esm_slicedToArray(n.offset, 1),\n      firstOffset = _n$offset[0];\n\n  out += space;\n  out += "(";\n  out += "offset";\n  out += space;\n  out += printInstruction(firstOffset, depth);\n  out += ")";\n  n.funcs.forEach(function (func) {\n    out += space;\n    out += printIndex(func);\n  });\n  out += ")";\n  return out;\n}\n\nfunction printStart(n) {\n  var out = "";\n  out += "(";\n  out += "start";\n  out += space;\n  out += printIndex(n.index);\n  out += ")";\n  return out;\n}\n\nfunction printLeadingComment(n) {\n  // Don\'t print leading comments in compact mode\n  if (compact === true) {\n    return "";\n  }\n\n  var out = "";\n  out += ";;";\n  out += n.value;\n  out += "\\n";\n  return out;\n}\n\nfunction printBlockComment(n) {\n  // Don\'t print block comments in compact mode\n  if (compact === true) {\n    return "";\n  }\n\n  var out = "";\n  out += "(;";\n  out += n.value;\n  out += ";)";\n  out += "\\n";\n  return out;\n}\n\nfunction printSignature(n) {\n  var out = "";\n  n.params.forEach(function (param) {\n    out += space;\n    out += "(";\n    out += "param";\n    out += space;\n    out += printFuncParam(param);\n    out += ")";\n  });\n  n.results.forEach(function (result) {\n    out += space;\n    out += "(";\n    out += "result";\n    out += space;\n    out += result;\n    out += ")";\n  });\n  return out;\n}\n\nfunction printModuleImportDescr(n) {\n  var out = "";\n\n  if (n.type === "FuncImportDescr") {\n    out += "(";\n    out += "func";\n\n    if (isAnonymous(n.id) === false) {\n      out += space;\n      out += printIdentifier(n.id);\n    }\n\n    out += printSignature(n.signature);\n    out += ")";\n  }\n\n  if (n.type === "GlobalType") {\n    out += "(";\n    out += "global";\n    out += space;\n    out += printGlobalType(n);\n    out += ")";\n  }\n\n  if (n.type === "Table") {\n    out += printTable(n);\n  }\n\n  return out;\n}\n\nfunction printModuleImport(n) {\n  var out = "";\n  out += "(";\n  out += "import";\n  out += space;\n  out += quote(n.module);\n  out += space;\n  out += quote(n.name);\n  out += space;\n  out += printModuleImportDescr(n.descr);\n  out += ")";\n  return out;\n}\n\nfunction printGlobalType(n) {\n  var out = "";\n\n  if (n.mutability === "var") {\n    out += "(";\n    out += "mut";\n    out += space;\n    out += n.valtype;\n    out += ")";\n  } else {\n    out += n.valtype;\n  }\n\n  return out;\n}\n\nfunction printGlobal(n, depth) {\n  var out = "";\n  out += "(";\n  out += "global";\n  out += space;\n\n  if (n.name != null && isAnonymous(n.name) === false) {\n    out += printIdentifier(n.name);\n    out += space;\n  }\n\n  out += printGlobalType(n.globalType);\n  out += space;\n  n.init.forEach(function (i) {\n    out += printInstruction(i, depth + 1);\n  });\n  out += ")";\n  return out;\n}\n\nfunction printTable(n) {\n  var out = "";\n  out += "(";\n  out += "table";\n  out += space;\n\n  if (n.name != null && isAnonymous(n.name) === false) {\n    out += printIdentifier(n.name);\n    out += space;\n  }\n\n  out += printLimit(n.limits);\n  out += space;\n  out += n.elementType;\n  out += ")";\n  return out;\n}\n\nfunction printFuncParam(n) {\n  var out = "";\n\n  if (typeof n.id === "string") {\n    out += "$" + n.id;\n    out += space;\n  }\n\n  out += n.valtype;\n  return out;\n}\n\nfunction printFunc(n, depth) {\n  var out = "";\n  out += "(";\n  out += "func";\n\n  if (n.name != null) {\n    if (n.name.type === "Identifier" && isAnonymous(n.name) === false) {\n      out += space;\n      out += printIdentifier(n.name);\n    }\n  }\n\n  if (n.signature.type === "Signature") {\n    out += printSignature(n.signature);\n  } else {\n    var index = n.signature;\n    out += space;\n    out += "(";\n    out += "type";\n    out += space;\n    out += printIndex(index);\n    out += ")";\n  }\n\n  if (n.body.length > 0) {\n    // func is empty since we ignore the default end instruction\n    if (n.body.length === 1 && n.body[0].id === "end") {\n      out += ")";\n      return out;\n    }\n\n    if (compact === false) {\n      out += "\\n";\n    }\n\n    n.body.forEach(function (i) {\n      if (i.id !== "end") {\n        out += indent(depth);\n        out += printInstruction(i, depth);\n\n        if (compact === false) {\n          out += "\\n";\n        }\n      }\n    });\n    out += indent(depth - 1) + ")";\n  } else {\n    out += ")";\n  }\n\n  return out;\n}\n\nfunction printInstruction(n, depth) {\n  switch (n.type) {\n    case "Instr":\n      // $FlowIgnore\n      return printGenericInstruction(n, depth + 1);\n\n    case "BlockInstruction":\n      // $FlowIgnore\n      return printBlockInstruction(n, depth + 1);\n\n    case "IfInstruction":\n      // $FlowIgnore\n      return printIfInstruction(n, depth + 1);\n\n    case "CallInstruction":\n      // $FlowIgnore\n      return printCallInstruction(n, depth + 1);\n\n    case "CallIndirectInstruction":\n      // $FlowIgnore\n      return printCallIndirectIntruction(n, depth + 1);\n\n    case "LoopInstruction":\n      // $FlowIgnore\n      return printLoopInstruction(n, depth + 1);\n\n    default:\n      throw new Error("Unsupported instruction: " + JSON.stringify(n.type));\n  }\n}\n\nfunction printCallIndirectIntruction(n, depth) {\n  var out = "";\n  out += "(";\n  out += "call_indirect";\n\n  if (n.signature.type === "Signature") {\n    out += printSignature(n.signature);\n  } else if (n.signature.type === "Identifier") {\n    out += space;\n    out += "(";\n    out += "type";\n    out += space;\n    out += printIdentifier(n.signature);\n    out += ")";\n  } else {\n    throw new Error("CallIndirectInstruction: unsupported signature " + JSON.stringify(n.signature.type));\n  }\n\n  out += space;\n\n  if (n.intrs != null) {\n    // $FlowIgnore\n    n.intrs.forEach(function (i, index) {\n      // $FlowIgnore\n      out += printInstruction(i, depth + 1); // $FlowIgnore\n\n      if (index !== n.intrs.length - 1) {\n        out += space;\n      }\n    });\n  }\n\n  out += ")";\n  return out;\n}\n\nfunction printLoopInstruction(n, depth) {\n  var out = "";\n  out += "(";\n  out += "loop";\n\n  if (n.label != null && isAnonymous(n.label) === false) {\n    out += space;\n    out += printIdentifier(n.label);\n  }\n\n  if (typeof n.resulttype === "string") {\n    out += space;\n    out += "(";\n    out += "result";\n    out += space;\n    out += n.resulttype;\n    out += ")";\n  }\n\n  if (n.instr.length > 0) {\n    n.instr.forEach(function (e) {\n      if (compact === false) {\n        out += "\\n";\n      }\n\n      out += indent(depth);\n      out += printInstruction(e, depth + 1);\n    });\n\n    if (compact === false) {\n      out += "\\n";\n      out += indent(depth - 1);\n    }\n  }\n\n  out += ")";\n  return out;\n}\n\nfunction printCallInstruction(n, depth) {\n  var out = "";\n  out += "(";\n  out += "call";\n  out += space;\n  out += printIndex(n.index);\n\n  if (esm_typeof(n.instrArgs) === "object") {\n    // $FlowIgnore\n    n.instrArgs.forEach(function (arg) {\n      out += space;\n      out += printFuncInstructionArg(arg, depth + 1);\n    });\n  }\n\n  out += ")";\n  return out;\n}\n\nfunction printIfInstruction(n, depth) {\n  var out = "";\n  out += "(";\n  out += "if";\n\n  if (n.testLabel != null && isAnonymous(n.testLabel) === false) {\n    out += space;\n    out += printIdentifier(n.testLabel);\n  }\n\n  if (typeof n.result === "string") {\n    out += space;\n    out += "(";\n    out += "result";\n    out += space;\n    out += n.result;\n    out += ")";\n  }\n\n  if (n.test.length > 0) {\n    out += space;\n    n.test.forEach(function (i) {\n      out += printInstruction(i, depth + 1);\n    });\n  }\n\n  if (n.consequent.length > 0) {\n    if (compact === false) {\n      out += "\\n";\n    }\n\n    out += indent(depth);\n    out += "(";\n    out += "then";\n    depth++;\n    n.consequent.forEach(function (i) {\n      if (compact === false) {\n        out += "\\n";\n      }\n\n      out += indent(depth);\n      out += printInstruction(i, depth + 1);\n    });\n    depth--;\n\n    if (compact === false) {\n      out += "\\n";\n      out += indent(depth);\n    }\n\n    out += ")";\n  } else {\n    if (compact === false) {\n      out += "\\n";\n      out += indent(depth);\n    }\n\n    out += "(";\n    out += "then";\n    out += ")";\n  }\n\n  if (n.alternate.length > 0) {\n    if (compact === false) {\n      out += "\\n";\n    }\n\n    out += indent(depth);\n    out += "(";\n    out += "else";\n    depth++;\n    n.alternate.forEach(function (i) {\n      if (compact === false) {\n        out += "\\n";\n      }\n\n      out += indent(depth);\n      out += printInstruction(i, depth + 1);\n    });\n    depth--;\n\n    if (compact === false) {\n      out += "\\n";\n      out += indent(depth);\n    }\n\n    out += ")";\n  } else {\n    if (compact === false) {\n      out += "\\n";\n      out += indent(depth);\n    }\n\n    out += "(";\n    out += "else";\n    out += ")";\n  }\n\n  if (compact === false) {\n    out += "\\n";\n    out += indent(depth - 1);\n  }\n\n  out += ")";\n  return out;\n}\n\nfunction printBlockInstruction(n, depth) {\n  var out = "";\n  out += "(";\n  out += "block";\n\n  if (n.label != null && isAnonymous(n.label) === false) {\n    out += space;\n    out += printIdentifier(n.label);\n  }\n\n  if (typeof n.result === "string") {\n    out += space;\n    out += "(";\n    out += "result";\n    out += space;\n    out += n.result;\n    out += ")";\n  }\n\n  if (n.instr.length > 0) {\n    n.instr.forEach(function (i) {\n      if (compact === false) {\n        out += "\\n";\n      }\n\n      out += indent(depth);\n      out += printInstruction(i, depth + 1);\n    });\n\n    if (compact === false) {\n      out += "\\n";\n    }\n\n    out += indent(depth - 1);\n    out += ")";\n  } else {\n    out += ")";\n  }\n\n  return out;\n}\n\nfunction printGenericInstruction(n, depth) {\n  var out = "";\n  out += "(";\n\n  if (typeof n.object === "string") {\n    out += n.object;\n    out += ".";\n  }\n\n  out += n.id;\n  n.args.forEach(function (arg) {\n    out += space;\n    out += printFuncInstructionArg(arg, depth + 1);\n  });\n  out += ")";\n  return out;\n}\n\nfunction printLongNumberLiteral(n) {\n  if (typeof n.raw === "string") {\n    return n.raw;\n  }\n\n  var _n$value = n.value,\n      low = _n$value.low,\n      high = _n$value.high;\n  var v = new long_default.a(low, high);\n  return v.toString();\n}\n\nfunction printFloatLiteral(n) {\n  if (typeof n.raw === "string") {\n    return n.raw;\n  }\n\n  return String(n.value);\n}\n\nfunction printFuncInstructionArg(n, depth) {\n  var out = "";\n\n  if (n.type === "NumberLiteral") {\n    out += printNumberLiteral(n);\n  }\n\n  if (n.type === "LongNumberLiteral") {\n    out += printLongNumberLiteral(n);\n  }\n\n  if (n.type === "Identifier" && isAnonymous(n) === false) {\n    out += printIdentifier(n);\n  }\n\n  if (n.type === "ValtypeLiteral") {\n    out += n.name;\n  }\n\n  if (n.type === "FloatLiteral") {\n    out += printFloatLiteral(n);\n  }\n\n  if (isInstruction(n)) {\n    out += printInstruction(n, depth + 1);\n  }\n\n  return out;\n}\n\nfunction printNumberLiteral(n) {\n  if (typeof n.raw === "string") {\n    return n.raw;\n  }\n\n  return String(n.value);\n}\n\nfunction printModuleExport(n) {\n  var out = "";\n  out += "(";\n  out += "export";\n  out += space;\n  out += quote(n.name);\n\n  if (n.descr.exportType === "Func") {\n    out += space;\n    out += "(";\n    out += "func";\n    out += space;\n    out += printIndex(n.descr.id);\n    out += ")";\n  } else if (n.descr.exportType === "Global") {\n    out += space;\n    out += "(";\n    out += "global";\n    out += space;\n    out += printIndex(n.descr.id);\n    out += ")";\n  } else if (n.descr.exportType === "Memory" || n.descr.exportType === "Mem") {\n    out += space;\n    out += "(";\n    out += "memory";\n    out += space;\n    out += printIndex(n.descr.id);\n    out += ")";\n  } else if (n.descr.exportType === "Table") {\n    out += space;\n    out += "(";\n    out += "table";\n    out += space;\n    out += printIndex(n.descr.id);\n    out += ")";\n  } else {\n    throw new Error("printModuleExport: unknown type: " + n.descr.exportType);\n  }\n\n  out += ")";\n  return out;\n}\n\nfunction printIdentifier(n) {\n  return "$" + n.value;\n}\n\nfunction printIndex(n) {\n  if (n.type === "Identifier") {\n    return printIdentifier(n);\n  } else if (n.type === "NumberLiteral") {\n    return printNumberLiteral(n);\n  } else {\n    throw new Error("Unsupported index: " + n.type);\n  }\n}\n\nfunction printMemory(n) {\n  var out = "";\n  out += "(";\n  out += "memory";\n\n  if (n.id != null) {\n    out += space;\n    out += printIndex(n.id);\n    out += space;\n  }\n\n  out += printLimit(n.limits);\n  out += ")";\n  return out;\n}\n\nfunction printLimit(n) {\n  var out = "";\n  out += n.min + "";\n\n  if (n.max != null) {\n    out += space;\n    out += String(n.max);\n  }\n\n  return out;\n}\n// CONCATENATED MODULE: ./node_modules/@webassemblyjs/helper-code-frame/esm/index.js\nfunction helper_code_frame_esm_typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { helper_code_frame_esm_typeof = function _typeof(obj) { return typeof obj; }; } else { helper_code_frame_esm_typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return helper_code_frame_esm_typeof(obj); }\n\n\nvar SHOW_LINES_AROUND_POINTER = 5;\n\nfunction repeat(char, nb) {\n  return Array(nb).fill(char).join("");\n} // TODO(sven): allow arbitrary ast nodes\n\n\nfunction codeFrameFromAst(ast, loc) {\n  return codeFrameFromSource(print(ast), loc);\n}\nfunction codeFrameFromSource(source, loc) {\n  var start = loc.start,\n      end = loc.end;\n  var length = 1;\n\n  if (helper_code_frame_esm_typeof(end) === "object") {\n    length = end.column - start.column + 1;\n  }\n\n  return source.split("\\n").reduce(function (acc, line, lineNbr) {\n    if (Math.abs(start.line - lineNbr) < SHOW_LINES_AROUND_POINTER) {\n      acc += line + "\\n";\n    } // Add a new line with the pointer padded left\n\n\n    if (lineNbr === start.line - 1) {\n      acc += repeat(" ", start.column - 1);\n      acc += repeat("^", length);\n      acc += "\\n";\n    }\n\n    return acc;\n  }, "");\n}\n// CONCATENATED MODULE: ./node_modules/@webassemblyjs/floating-point-hex-parser/esm/index.js\nfunction parse(input) {\n  input = input.toUpperCase();\n  var splitIndex = input.indexOf("P");\n  var mantissa, exponent;\n\n  if (splitIndex !== -1) {\n    mantissa = input.substring(0, splitIndex);\n    exponent = parseInt(input.substring(splitIndex + 1));\n  } else {\n    mantissa = input;\n    exponent = 0;\n  }\n\n  var dotIndex = mantissa.indexOf(".");\n\n  if (dotIndex !== -1) {\n    var integerPart = parseInt(mantissa.substring(0, dotIndex), 16);\n    var sign = Math.sign(integerPart);\n    integerPart = sign * integerPart;\n    var fractionLength = mantissa.length - dotIndex - 1;\n    var fractionalPart = parseInt(mantissa.substring(dotIndex + 1), 16);\n    var fraction = fractionLength > 0 ? fractionalPart / Math.pow(16, fractionLength) : 0;\n\n    if (sign === 0) {\n      if (fraction === 0) {\n        mantissa = sign;\n      } else {\n        if (Object.is(sign, -0)) {\n          mantissa = -fraction;\n        } else {\n          mantissa = fraction;\n        }\n      }\n    } else {\n      mantissa = sign * (integerPart + fraction);\n    }\n  } else {\n    mantissa = parseInt(mantissa, 16);\n  }\n\n  return mantissa * (splitIndex !== -1 ? Math.pow(2, exponent) : 1);\n}\n// CONCATENATED MODULE: ./node_modules/@webassemblyjs/helper-api-error/esm/index.js\nfunction helper_api_error_esm_typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { helper_api_error_esm_typeof = function _typeof(obj) { return typeof obj; }; } else { helper_api_error_esm_typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return helper_api_error_esm_typeof(obj); }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (helper_api_error_esm_typeof(call) === "object" || typeof call === "function")) { return call; } if (!self) { throw new ReferenceError("this hasn\'t been initialised - super() hasn\'t been called"); } return self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\nvar RuntimeError =\n/*#__PURE__*/\nfunction (_Error) {\n  _inherits(RuntimeError, _Error);\n\n  function RuntimeError() {\n    _classCallCheck(this, RuntimeError);\n\n    return _possibleConstructorReturn(this, (RuntimeError.__proto__ || Object.getPrototypeOf(RuntimeError)).apply(this, arguments));\n  }\n\n  return RuntimeError;\n}(Error);\nvar CompileError =\n/*#__PURE__*/\nfunction (_Error2) {\n  _inherits(CompileError, _Error2);\n\n  function CompileError() {\n    _classCallCheck(this, CompileError);\n\n    return _possibleConstructorReturn(this, (CompileError.__proto__ || Object.getPrototypeOf(CompileError)).apply(this, arguments));\n  }\n\n  return CompileError;\n}(Error);\nvar LinkError =\n/*#__PURE__*/\nfunction (_Error3) {\n  _inherits(LinkError, _Error3);\n\n  function LinkError() {\n    _classCallCheck(this, LinkError);\n\n    return _possibleConstructorReturn(this, (LinkError.__proto__ || Object.getPrototypeOf(LinkError)).apply(this, arguments));\n  }\n\n  return LinkError;\n}(Error);\n// CONCATENATED MODULE: ./node_modules/@webassemblyjs/wast-parser/esm/number-literals.js\n\n\n\nfunction parse32F(sourceString) {\n  if (isHexLiteral(sourceString)) {\n    return parse(sourceString);\n  }\n\n  if (isInfLiteral(sourceString)) {\n    return sourceString[0] === "-" ? -1 : 1;\n  }\n\n  if (isNanLiteral(sourceString)) {\n    return (sourceString[0] === "-" ? -1 : 1) * (sourceString.includes(":") ? parseInt(sourceString.substring(sourceString.indexOf(":") + 1), 16) : 0x400000);\n  }\n\n  return parseFloat(sourceString);\n}\nfunction parse64F(sourceString) {\n  if (isHexLiteral(sourceString)) {\n    return parse(sourceString);\n  }\n\n  if (isInfLiteral(sourceString)) {\n    return sourceString[0] === "-" ? -1 : 1;\n  }\n\n  if (isNanLiteral(sourceString)) {\n    return (sourceString[0] === "-" ? -1 : 1) * (sourceString.includes(":") ? parseInt(sourceString.substring(sourceString.indexOf(":") + 1), 16) : 0x8000000000000);\n  }\n\n  if (isHexLiteral(sourceString)) {\n    return parse(sourceString);\n  }\n\n  return parseFloat(sourceString);\n}\nfunction parse32I(sourceString) {\n  var value = 0;\n\n  if (isHexLiteral(sourceString)) {\n    value = ~~parseInt(sourceString, 16);\n  } else if (isDecimalExponentLiteral(sourceString)) {\n    throw new Error("This number literal format is yet to be implemented.");\n  } else {\n    value = parseInt(sourceString, 10);\n  }\n\n  return value;\n}\nfunction parseU32(sourceString) {\n  var value = parse32I(sourceString);\n\n  if (value < 0) {\n    throw new CompileError("Illegal value for u32: " + sourceString);\n  }\n\n  return value;\n}\nfunction parse64I(sourceString) {\n  var long;\n\n  if (isHexLiteral(sourceString)) {\n    long = long_default.a.fromString(sourceString, false, 16);\n  } else if (isDecimalExponentLiteral(sourceString)) {\n    throw new Error("This number literal format is yet to be implemented.");\n  } else {\n    long = long_default.a.fromString(sourceString);\n  }\n\n  return {\n    high: long.high,\n    low: long.low\n  };\n}\nvar NAN_WORD = /^\\+?-?nan/;\nvar INF_WORD = /^\\+?-?inf/;\nfunction isInfLiteral(sourceString) {\n  return INF_WORD.test(sourceString.toLowerCase());\n}\nfunction isNanLiteral(sourceString) {\n  return NAN_WORD.test(sourceString.toLowerCase());\n}\n\nfunction isDecimalExponentLiteral(sourceString) {\n  return !isHexLiteral(sourceString) && sourceString.toUpperCase().includes("E");\n}\n\nfunction isHexLiteral(sourceString) {\n  return sourceString.substring(0, 2).toUpperCase() === "0X" || sourceString.substring(0, 3).toUpperCase() === "-0X";\n}\n// CONCATENATED MODULE: ./node_modules/@webassemblyjs/wast-parser/esm/string-literals.js\n// string literal characters cannot contain control codes\nvar CONTROL_CODES = [0, // null\n7, // bell\n8, // backspace\n9, // horizontal\n10, // line feed\n11, // vertical tab\n12, // form feed\n13, // carriage return\n26, // Control-Z\n27, // escape\n127 // delete\n]; // escaped sequences can either be a two character hex value, or one of the\n// following single character codes\n\nfunction decodeControlCharacter(char) {\n  switch (char) {\n    case "t":\n      return 0x09;\n\n    case "n":\n      return 0x0a;\n\n    case "r":\n      return 0x0d;\n\n    case \'"\':\n      return 0x22;\n\n    case "":\n      return 0x27;\n\n    case "\\\\":\n      return 0x5c;\n  }\n\n  return -1;\n}\n\nvar ESCAPE_CHAR = 92; // backslash\n\nvar QUOTE_CHAR = 34; // backslash\n// parse string as per the spec:\n// https://webassembly.github.io/spec/core/multipage/text/values.html#text-string\n\nfunction parseString(value) {\n  var byteArray = [];\n  var index = 0;\n\n  while (index < value.length) {\n    var charCode = value.charCodeAt(index);\n\n    if (CONTROL_CODES.indexOf(charCode) !== -1) {\n      throw new Error("ASCII control characters are not permitted within string literals");\n    }\n\n    if (charCode === QUOTE_CHAR) {\n      throw new Error("quotes are not permitted within string literals");\n    }\n\n    if (charCode === ESCAPE_CHAR) {\n      var firstChar = value.substr(index + 1, 1);\n      var decodedControlChar = decodeControlCharacter(firstChar);\n\n      if (decodedControlChar !== -1) {\n        // single character escaped values, e.g. \\r\n        byteArray.push(decodedControlChar);\n        index += 2;\n      } else {\n        // hex escaped values, e.g. \\2a\n        var hexValue = value.substr(index + 1, 2);\n\n        if (!/^[0-9A-F]{2}$/i.test(hexValue)) {\n          throw new Error("invalid character encoding");\n        }\n\n        byteArray.push(parseInt(hexValue, 16));\n        index += 3;\n      }\n    } else {\n      // ASCII encoded values\n      byteArray.push(charCode);\n      index++;\n    }\n  }\n\n  return byteArray;\n}\n// CONCATENATED MODULE: ./node_modules/@webassemblyjs/helper-fsm/esm/index.js\nfunction helper_fsm_esm_sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }\n\nfunction helper_fsm_esm_slicedToArray(arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return helper_fsm_esm_sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }\n\nfunction esm_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nvar STOP = Symbol("STOP");\n\nfunction makeTransition(regex, nextState) {\n  var _ref = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {},\n      _ref$n = _ref.n,\n      n = _ref$n === void 0 ? 1 : _ref$n,\n      allowedSeparator = _ref.allowedSeparator;\n\n  return function (instance) {\n    if (allowedSeparator) {\n      if (instance.input[instance.ptr] === allowedSeparator) {\n        if (regex.test(instance.input.substring(instance.ptr - 1, instance.ptr))) {\n          // Consume the separator and stay in current state\n          return [instance.currentState, 1];\n        } else {\n          return [instance.terminatingState, 0];\n        }\n      }\n    }\n\n    if (regex.test(instance.input.substring(instance.ptr, instance.ptr + n))) {\n      return [nextState, n];\n    }\n\n    return false;\n  };\n}\n\nfunction combineTransitions(transitions) {\n  return function () {\n    var match = false;\n    var currentTransitions = transitions[this.currentState] || [];\n\n    for (var i = 0; i < currentTransitions.length; ++i) {\n      match = currentTransitions[i](this);\n\n      if (match !== false) {\n        break;\n      }\n    }\n\n    return match || [this.terminatingState, 0];\n  };\n}\n\nvar FSM =\n/*#__PURE__*/\nfunction () {\n  function FSM(transitions, initialState) {\n    var terminatingState = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : STOP;\n\n    esm_classCallCheck(this, FSM);\n\n    this.initialState = initialState;\n    this.terminatingState = terminatingState;\n\n    if (terminatingState === STOP || !transitions[terminatingState]) {\n      transitions[terminatingState] = [];\n    }\n\n    this.transitionFunction = combineTransitions.call(this, transitions);\n  }\n\n  _createClass(FSM, [{\n    key: "run",\n    value: function run(input) {\n      this.input = input;\n      this.ptr = 0;\n      this.currentState = this.initialState;\n      var value = "";\n      var eatLength, nextState;\n\n      while (this.currentState !== this.terminatingState && this.ptr < this.input.length) {\n        var _transitionFunction = this.transitionFunction();\n\n        var _transitionFunction2 = helper_fsm_esm_slicedToArray(_transitionFunction, 2);\n\n        nextState = _transitionFunction2[0];\n        eatLength = _transitionFunction2[1];\n        value += this.input.substring(this.ptr, this.ptr += eatLength);\n        this.currentState = nextState;\n      }\n\n      return value;\n    }\n  }]);\n\n  return FSM;\n}();\n\n\n// CONCATENATED MODULE: ./node_modules/@webassemblyjs/wast-parser/esm/tokenizer.js\n\n\n\n// eslint-disable-next-line\nfunction getCodeFrame(source, line, column) {\n  var loc = {\n    start: {\n      line: line,\n      column: column\n    }\n  };\n  return "\\n" + codeFrameFromSource(source, loc) + "\\n";\n}\n\nvar WHITESPACE = /\\s/;\nvar PARENS = /\\(|\\)/;\nvar LETTERS = /[a-z0-9_/]/i;\nvar idchar = /[a-z0-9!#$%&*+./:<=>?@\\\\[\\]^_`|~-]/i;\nvar tokenizer_valtypes = ["i32", "i64", "f32", "f64"];\nvar NUMBERS = /[0-9|.|_]/;\nvar NUMBER_KEYWORDS = /nan|inf/;\n\nfunction isNewLine(char) {\n  return char.charCodeAt(0) === 10 || char.charCodeAt(0) === 13;\n}\n\nfunction Token(type, value, start, end) {\n  var opts = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : {};\n  var token = {\n    type: type,\n    value: value,\n    loc: {\n      start: start,\n      end: end\n    }\n  };\n\n  if (Object.keys(opts).length > 0) {\n    // $FlowIgnore\n    token["opts"] = opts;\n  }\n\n  return token;\n}\n\nvar tokenTypes = {\n  openParen: "openParen",\n  closeParen: "closeParen",\n  number: "number",\n  string: "string",\n  name: "name",\n  identifier: "identifier",\n  valtype: "valtype",\n  dot: "dot",\n  comment: "comment",\n  equal: "equal",\n  keyword: "keyword"\n};\nvar keywords = {\n  module: "module",\n  func: "func",\n  param: "param",\n  result: "result",\n  export: "export",\n  loop: "loop",\n  block: "block",\n  if: "if",\n  then: "then",\n  else: "else",\n  call: "call",\n  call_indirect: "call_indirect",\n  import: "import",\n  memory: "memory",\n  table: "table",\n  global: "global",\n  anyfunc: "anyfunc",\n  mut: "mut",\n  data: "data",\n  type: "type",\n  elem: "elem",\n  start: "start",\n  offset: "offset"\n};\nvar NUMERIC_SEPARATOR = "_";\n/**\n * Build the FSM for number literals\n */\n\nvar numberLiteralFSM = new FSM({\n  START: [makeTransition(/-|\\+/, "AFTER_SIGN"), makeTransition(/nan:0x/, "NAN_HEX", {\n    n: 6\n  }), makeTransition(/nan|inf/, "STOP", {\n    n: 3\n  }), makeTransition(/0x/, "HEX", {\n    n: 2\n  }), makeTransition(/[0-9]/, "DEC"), makeTransition(/\\./, "DEC_FRAC")],\n  AFTER_SIGN: [makeTransition(/nan:0x/, "NAN_HEX", {\n    n: 6\n  }), makeTransition(/nan|inf/, "STOP", {\n    n: 3\n  }), makeTransition(/0x/, "HEX", {\n    n: 2\n  }), makeTransition(/[0-9]/, "DEC"), makeTransition(/\\./, "DEC_FRAC")],\n  DEC_FRAC: [makeTransition(/[0-9]/, "DEC_FRAC", {\n    allowedSeparator: NUMERIC_SEPARATOR\n  }), makeTransition(/e|E/, "DEC_SIGNED_EXP")],\n  DEC: [makeTransition(/[0-9]/, "DEC", {\n    allowedSeparator: NUMERIC_SEPARATOR\n  }), makeTransition(/\\./, "DEC_FRAC"), makeTransition(/e|E/, "DEC_SIGNED_EXP")],\n  DEC_SIGNED_EXP: [makeTransition(/\\+|-/, "DEC_EXP"), makeTransition(/[0-9]/, "DEC_EXP")],\n  DEC_EXP: [makeTransition(/[0-9]/, "DEC_EXP", {\n    allowedSeparator: NUMERIC_SEPARATOR\n  })],\n  HEX: [makeTransition(/[0-9|A-F|a-f]/, "HEX", {\n    allowedSeparator: NUMERIC_SEPARATOR\n  }), makeTransition(/\\./, "HEX_FRAC"), makeTransition(/p|P/, "HEX_SIGNED_EXP")],\n  HEX_FRAC: [makeTransition(/[0-9|A-F|a-f]/, "HEX_FRAC", {\n    allowedSeparator: NUMERIC_SEPARATOR\n  }), makeTransition(/p|P|/, "HEX_SIGNED_EXP")],\n  HEX_SIGNED_EXP: [makeTransition(/[0-9|+|-]/, "HEX_EXP")],\n  HEX_EXP: [makeTransition(/[0-9]/, "HEX_EXP", {\n    allowedSeparator: NUMERIC_SEPARATOR\n  })],\n  NAN_HEX: [makeTransition(/[0-9|A-F|a-f]/, "NAN_HEX", {\n    allowedSeparator: NUMERIC_SEPARATOR\n  })],\n  STOP: []\n}, "START", "STOP");\nfunction tokenize(input) {\n  var current = 0;\n  var char = input[current]; // Used by SourceLocation\n\n  var column = 1;\n  var line = 1;\n  var tokens = [];\n  /**\n   * Creates a pushToken function for a given type\n   */\n\n  function pushToken(type) {\n    return function (v) {\n      var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      var startColumn = opts.startColumn || column - String(v).length;\n      delete opts.startColumn;\n      var endColumn = opts.endColumn || startColumn + String(v).length - 1;\n      delete opts.endColumn;\n      var start = {\n        line: line,\n        column: startColumn\n      };\n      var end = {\n        line: line,\n        column: endColumn\n      };\n      tokens.push(Token(type, v, start, end, opts));\n    };\n  }\n  /**\n   * Functions to save newly encountered tokens\n   */\n\n\n  var pushCloseParenToken = pushToken(tokenTypes.closeParen);\n  var pushOpenParenToken = pushToken(tokenTypes.openParen);\n  var pushNumberToken = pushToken(tokenTypes.number);\n  var pushValtypeToken = pushToken(tokenTypes.valtype);\n  var pushNameToken = pushToken(tokenTypes.name);\n  var pushIdentifierToken = pushToken(tokenTypes.identifier);\n  var pushKeywordToken = pushToken(tokenTypes.keyword);\n  var pushDotToken = pushToken(tokenTypes.dot);\n  var pushStringToken = pushToken(tokenTypes.string);\n  var pushCommentToken = pushToken(tokenTypes.comment);\n  var pushEqualToken = pushToken(tokenTypes.equal);\n  /**\n   * Can be used to look at the next character(s).\n   *\n   * The default behavior `lookahead()` simply returns the next character without consuming it.\n   * Letters are always returned in lowercase.\n   *\n   * @param {number} length How many characters to query. Default = 1\n   * @param {number} offset How many characters to skip forward from current one. Default = 1\n   *\n   */\n\n  function lookahead() {\n    var length = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;\n    var offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;\n    return input.substring(current + offset, current + offset + length).toLowerCase();\n  }\n  /**\n   * Advances the cursor in the input by a certain amount\n   *\n   * @param {number} amount How many characters to consume. Default = 1\n   */\n\n\n  function eatCharacter() {\n    var amount = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;\n    column += amount;\n    current += amount;\n    char = input[current];\n  }\n\n  while (current < input.length) {\n    // ;;\n    if (char === ";" && lookahead() === ";") {\n      var startColumn = column;\n      eatCharacter(2);\n      var text = "";\n\n      while (!isNewLine(char)) {\n        text += char;\n        eatCharacter();\n\n        if (char === undefined) {\n          break;\n        }\n      }\n\n      var endColumn = column;\n      pushCommentToken(text, {\n        type: "leading",\n        startColumn: startColumn,\n        endColumn: endColumn\n      });\n      continue;\n    } // (;\n\n\n    if (char === "(" && lookahead() === ";") {\n      var _startColumn = column;\n      eatCharacter(2);\n      var _text = ""; // ;)\n\n      while (true) {\n        char = input[current];\n\n        if (char === ";" && lookahead() === ")") {\n          eatCharacter(2);\n          break;\n        }\n\n        _text += char;\n        eatCharacter();\n\n        if (isNewLine(char)) {\n          line++;\n          column = 0;\n        }\n      }\n\n      var _endColumn = column;\n      pushCommentToken(_text, {\n        type: "block",\n        startColumn: _startColumn,\n        endColumn: _endColumn\n      });\n      continue;\n    }\n\n    if (char === "(") {\n      pushOpenParenToken(char);\n      eatCharacter();\n      continue;\n    }\n\n    if (char === "=") {\n      pushEqualToken(char);\n      eatCharacter();\n      continue;\n    }\n\n    if (char === ")") {\n      pushCloseParenToken(char);\n      eatCharacter();\n      continue;\n    }\n\n    if (isNewLine(char)) {\n      line++;\n      eatCharacter();\n      column = 0;\n      continue;\n    }\n\n    if (WHITESPACE.test(char)) {\n      eatCharacter();\n      continue;\n    }\n\n    if (char === "$") {\n      var _startColumn2 = column;\n      eatCharacter();\n      var value = "";\n\n      while (idchar.test(char)) {\n        value += char;\n        eatCharacter();\n      }\n\n      var _endColumn2 = column;\n      pushIdentifierToken(value, {\n        startColumn: _startColumn2,\n        endColumn: _endColumn2\n      });\n      continue;\n    }\n\n    if (NUMBERS.test(char) || NUMBER_KEYWORDS.test(lookahead(3, 0)) || char === "-" || char === "+") {\n      var _startColumn3 = column;\n\n      var _value = numberLiteralFSM.run(input.slice(current));\n\n      if (_value === "") {\n        throw new Error(getCodeFrame(input, line, column) + "Unexpected character " + JSON.stringify(char));\n      }\n\n      pushNumberToken(_value, {\n        startColumn: _startColumn3\n      });\n      eatCharacter(_value.length);\n\n      if (char && !PARENS.test(char) && !WHITESPACE.test(char)) {\n        throw new Error(getCodeFrame(input, line, column) + "Unexpected character " + JSON.stringify(char));\n      }\n\n      continue;\n    }\n\n    if (char === \'"\') {\n      var _startColumn4 = column;\n      var _value2 = "";\n      eatCharacter(); // "\n\n      while (char !== \'"\') {\n        if (isNewLine(char)) {\n          throw new Error(getCodeFrame(input, line, column) + "Unexpected character " + JSON.stringify(char));\n        }\n\n        _value2 += char;\n        eatCharacter(); // char\n      }\n\n      eatCharacter(); // "\n\n      var _endColumn3 = column;\n      pushStringToken(_value2, {\n        startColumn: _startColumn4,\n        endColumn: _endColumn3\n      });\n      continue;\n    }\n\n    if (LETTERS.test(char)) {\n      var _value3 = "";\n      var _startColumn5 = column;\n\n      while (char && LETTERS.test(char)) {\n        _value3 += char;\n        eatCharacter();\n      }\n      /*\n       * Handle MemberAccess\n       */\n\n\n      if (char === ".") {\n        var dotStartColumn = column;\n\n        if (tokenizer_valtypes.indexOf(_value3) !== -1) {\n          pushValtypeToken(_value3, {\n            startColumn: _startColumn5\n          });\n        } else {\n          pushNameToken(_value3);\n        }\n\n        eatCharacter();\n        _value3 = "";\n        var nameStartColumn = column;\n\n        while (LETTERS.test(char)) {\n          _value3 += char;\n          eatCharacter();\n        }\n\n        pushDotToken(".", {\n          startColumn: dotStartColumn\n        });\n        pushNameToken(_value3, {\n          startColumn: nameStartColumn\n        });\n        continue;\n      }\n      /*\n       * Handle keywords\n       */\n      // $FlowIgnore\n\n\n      if (typeof keywords[_value3] === "string") {\n        pushKeywordToken(_value3, {\n          startColumn: _startColumn5\n        });\n        continue;\n      }\n      /*\n       * Handle types\n       */\n\n\n      if (tokenizer_valtypes.indexOf(_value3) !== -1) {\n        pushValtypeToken(_value3, {\n          startColumn: _startColumn5\n        });\n        continue;\n      }\n      /*\n       * Handle literals\n       */\n\n\n      pushNameToken(_value3, {\n        startColumn: _startColumn5\n      });\n      continue;\n    }\n\n    throw new Error(getCodeFrame(input, line, column) + "Unexpected character " + JSON.stringify(char));\n  }\n\n  return tokens;\n}\nvar tokenizer_tokens = tokenTypes;\n// CONCATENATED MODULE: ./node_modules/@webassemblyjs/wast-parser/esm/grammar.js\nfunction grammar_typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { grammar_typeof = function _typeof(obj) { return typeof obj; }; } else { grammar_typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return grammar_typeof(obj); }\n\nfunction _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }\n\n\n\n\n\n\n\nfunction hasPlugin(name) {\n  if (name !== "wast") throw new Error("unknow plugin");\n  return true;\n}\n\nfunction isKeyword(token, id) {\n  return token.type === tokenizer_tokens.keyword && token.value === id;\n}\n\nfunction tokenToString(token) {\n  if (token.type === "keyword") {\n    return "keyword (".concat(token.value, ")");\n  }\n\n  return token.type;\n}\n\nfunction identifierFromToken(token) {\n  var _token$loc = token.loc,\n      end = _token$loc.end,\n      start = _token$loc.start;\n  return withLoc(identifier(token.value), end, start);\n}\n\nfunction grammar_parse(tokensList, source) {\n  var current = 0;\n  var getUniqueName = getUniqueNameGenerator();\n  var state = {\n    registredExportedElements: []\n  }; // But this time we\'re going to use recursion instead of a `while` loop. So we\n  // define a `walk` function.\n\n  function walk() {\n    var token = tokensList[current];\n\n    function eatToken() {\n      token = tokensList[++current];\n    }\n\n    function getEndLoc() {\n      var currentToken = token;\n\n      if (typeof currentToken === "undefined") {\n        var lastToken = tokensList[tokensList.length - 1];\n        currentToken = lastToken;\n      }\n\n      return currentToken.loc.end;\n    }\n\n    function getStartLoc() {\n      return token.loc.start;\n    }\n\n    function eatTokenOfType(type) {\n      if (token.type !== type) {\n        throw new Error("\\n" + codeFrameFromSource(source, token.loc) + "Assertion error: expected token of type " + type + ", given " + tokenToString(token));\n      }\n\n      eatToken();\n    }\n\n    function parseExportIndex(token) {\n      if (token.type === tokenizer_tokens.identifier) {\n        var index = identifierFromToken(token);\n        eatToken();\n        return index;\n      } else if (token.type === tokenizer_tokens.number) {\n        var _index = numberLiteralFromRaw(token.value);\n\n        eatToken();\n        return _index;\n      } else {\n        throw function () {\n          return new Error("\\n" + codeFrameFromSource(source, token.loc) + "\\n" + "unknown export index" + ", given " + tokenToString(token));\n        }();\n      }\n    }\n\n    function lookaheadAndCheck() {\n      var len = arguments.length;\n\n      for (var i = 0; i < len; i++) {\n        var tokenAhead = tokensList[current + i];\n        var expectedToken = i < 0 || arguments.length <= i ? undefined : arguments[i];\n\n        if (tokenAhead.type === "keyword") {\n          if (isKeyword(tokenAhead, expectedToken) === false) {\n            return false;\n          }\n        } else if (expectedToken !== tokenAhead.type) {\n          return false;\n        }\n      }\n\n      return true;\n    } // TODO(sven): there is probably a better way to do this\n    // can refactor it if it get out of hands\n\n\n    function maybeIgnoreComment() {\n      if (typeof token === "undefined") {\n        // Ignore\n        return;\n      }\n\n      while (token.type === tokenizer_tokens.comment) {\n        eatToken();\n\n        if (typeof token === "undefined") {\n          // Hit the end\n          break;\n        }\n      }\n    }\n    /**\n     * Parses a memory instruction\n     *\n     * WAST:\n     *\n     * memory:  ( memory <name>? <memory_sig> )\n     *          ( memory <name>? ( export <string> ) <...> )\n     *          ( memory <name>? ( import <string> <string> ) <memory_sig> )\n     *          ( memory <name>? ( export <string> )* ( data <string>* )\n     * memory_sig: <nat> <nat>?\n     *\n     */\n\n\n    function parseMemory() {\n      var id = identifier(getUniqueName("memory"));\n      var limits = nodes_limit(0);\n\n      if (token.type === tokenizer_tokens.string || token.type === tokenizer_tokens.identifier) {\n        id = identifier(token.value);\n        eatToken();\n      } else {\n        id = withRaw(id, ""); // preserve anonymous\n      }\n      /**\n       * Maybe data\n       */\n\n\n      if (lookaheadAndCheck(tokenizer_tokens.openParen, keywords.data)) {\n        eatToken(); // (\n\n        eatToken(); // data\n        // TODO(sven): do something with the data collected here\n\n        var stringInitializer = token.value;\n        eatTokenOfType(tokenizer_tokens.string); // Update limits accordingly\n\n        limits = nodes_limit(stringInitializer.length);\n        eatTokenOfType(tokenizer_tokens.closeParen);\n      }\n      /**\n       * Maybe export\n       */\n\n\n      if (lookaheadAndCheck(tokenizer_tokens.openParen, keywords.export)) {\n        eatToken(); // (\n\n        eatToken(); // export\n\n        if (token.type !== tokenizer_tokens.string) {\n          throw function () {\n            return new Error("\\n" + codeFrameFromSource(source, token.loc) + "\\n" + "Expected string in export" + ", given " + tokenToString(token));\n          }();\n        }\n\n        var _name = token.value;\n        eatToken();\n        state.registredExportedElements.push({\n          exportType: "Memory",\n          name: _name,\n          id: id\n        });\n        eatTokenOfType(tokenizer_tokens.closeParen);\n      }\n      /**\n       * Memory signature\n       */\n\n\n      if (token.type === tokenizer_tokens.number) {\n        limits = nodes_limit(parse32I(token.value));\n        eatToken();\n\n        if (token.type === tokenizer_tokens.number) {\n          limits.max = parse32I(token.value);\n          eatToken();\n        }\n      }\n\n      return memory(limits, id);\n    }\n    /**\n     * Parses a data section\n     * https://webassembly.github.io/spec/core/text/modules.html#data-segments\n     *\n     * WAST:\n     *\n     * data:  ( data <index>? <offset> <string> )\n     */\n\n\n    function parseData() {\n      // optional memory index\n      var memidx = 0;\n\n      if (token.type === tokenizer_tokens.number) {\n        memidx = token.value;\n        eatTokenOfType(tokenizer_tokens.number); // .\n      }\n\n      eatTokenOfType(tokenizer_tokens.openParen);\n      var offset;\n\n      if (token.type === tokenizer_tokens.valtype) {\n        eatTokenOfType(tokenizer_tokens.valtype); // i32\n\n        eatTokenOfType(tokenizer_tokens.dot); // .\n\n        if (token.value !== "const") {\n          throw new Error("constant expression required");\n        }\n\n        eatTokenOfType(tokenizer_tokens.name); // const\n\n        var numberLiteral = numberLiteralFromRaw(token.value, "i32");\n        offset = objectInstruction("const", "i32", [numberLiteral]);\n        eatToken();\n        eatTokenOfType(tokenizer_tokens.closeParen);\n      } else {\n        eatTokenOfType(tokenizer_tokens.name); // get_global\n\n        var _numberLiteral = numberLiteralFromRaw(token.value, "i32");\n\n        offset = node_helpers_instruction("get_global", [_numberLiteral]);\n        eatToken();\n        eatTokenOfType(tokenizer_tokens.closeParen);\n      }\n\n      var byteArray = parseString(token.value);\n      eatToken(); // "string"\n\n      return data(memIndexLiteral(memidx), offset, nodes_byteArray(byteArray));\n    }\n    /**\n     * Parses a table instruction\n     *\n     * WAST:\n     *\n     * table:   ( table <name>? <table_type> )\n     *          ( table <name>? ( export <string> ) <...> )\n     *          ( table <name>? ( import <string> <string> ) <table_type> )\n     *          ( table <name>? ( export <string> )* <elem_type> ( elem <var>* ) )\n     *\n     * table_type:  <nat> <nat>? <elem_type>\n     * elem_type: anyfunc\n     *\n     * elem:    ( elem <var>? (offset <instr>* ) <var>* )\n     *          ( elem <var>? <expr> <var>* )\n     */\n\n\n    function parseTable() {\n      var name = identifier(getUniqueName("table"));\n      var limit = nodes_limit(0);\n      var elemIndices = [];\n      var elemType = "anyfunc";\n\n      if (token.type === tokenizer_tokens.string || token.type === tokenizer_tokens.identifier) {\n        name = identifierFromToken(token);\n        eatToken();\n      } else {\n        name = withRaw(name, ""); // preserve anonymous\n      }\n\n      while (token.type !== tokenizer_tokens.closeParen) {\n        /**\n         * Maybe export\n         */\n        if (lookaheadAndCheck(tokenizer_tokens.openParen, keywords.elem)) {\n          eatToken(); // (\n\n          eatToken(); // elem\n\n          while (token.type === tokenizer_tokens.identifier) {\n            elemIndices.push(identifier(token.value));\n            eatToken();\n          }\n\n          eatTokenOfType(tokenizer_tokens.closeParen);\n        } else if (lookaheadAndCheck(tokenizer_tokens.openParen, keywords.export)) {\n          eatToken(); // (\n\n          eatToken(); // export\n\n          if (token.type !== tokenizer_tokens.string) {\n            throw function () {\n              return new Error("\\n" + codeFrameFromSource(source, token.loc) + "\\n" + "Expected string in export" + ", given " + tokenToString(token));\n            }();\n          }\n\n          var exportName = token.value;\n          eatToken();\n          state.registredExportedElements.push({\n            exportType: "Table",\n            name: exportName,\n            id: name\n          });\n          eatTokenOfType(tokenizer_tokens.closeParen);\n        } else if (isKeyword(token, keywords.anyfunc)) {\n          // It\'s the default value, we can ignore it\n          eatToken(); // anyfunc\n        } else if (token.type === tokenizer_tokens.number) {\n          /**\n           * Table type\n           */\n          var min = parseInt(token.value);\n          eatToken();\n\n          if (token.type === tokenizer_tokens.number) {\n            var max = parseInt(token.value);\n            eatToken();\n            limit = nodes_limit(min, max);\n          } else {\n            limit = nodes_limit(min);\n          }\n\n          eatToken();\n        } else {\n          throw function () {\n            return new Error("\\n" + codeFrameFromSource(source, token.loc) + "\\n" + "Unexpected token" + ", given " + tokenToString(token));\n          }();\n        }\n      }\n\n      if (elemIndices.length > 0) {\n        return table(elemType, limit, name, elemIndices);\n      } else {\n        return table(elemType, limit, name);\n      }\n    }\n    /**\n     * Parses an import statement\n     *\n     * WAST:\n     *\n     * import:  ( import <string> <string> <imkind> )\n     * imkind:  ( func <name>? <func_sig> )\n     *          ( global <name>? <global_sig> )\n     *          ( table <name>? <table_sig> )\n     *          ( memory <name>? <memory_sig> )\n     *\n     * global_sig: <type> | ( mut <type> )\n     */\n\n\n    function parseImport() {\n      if (token.type !== tokenizer_tokens.string) {\n        throw new Error("Expected a string, " + token.type + " given.");\n      }\n\n      var moduleName = token.value;\n      eatToken();\n\n      if (token.type !== tokenizer_tokens.string) {\n        throw new Error("Expected a string, " + token.type + " given.");\n      }\n\n      var name = token.value;\n      eatToken();\n      eatTokenOfType(tokenizer_tokens.openParen);\n      var descr;\n\n      if (isKeyword(token, keywords.func)) {\n        eatToken(); // keyword\n\n        var fnParams = [];\n        var fnResult = [];\n        var typeRef;\n        var fnName = identifier(getUniqueName("func"));\n\n        if (token.type === tokenizer_tokens.identifier) {\n          fnName = identifierFromToken(token);\n          eatToken();\n        }\n\n        while (token.type === tokenizer_tokens.openParen) {\n          eatToken();\n\n          if (lookaheadAndCheck(keywords.type) === true) {\n            eatToken();\n            typeRef = parseTypeReference();\n          } else if (lookaheadAndCheck(keywords.param) === true) {\n            eatToken();\n            fnParams.push.apply(fnParams, _toConsumableArray(parseFuncParam()));\n          } else if (lookaheadAndCheck(keywords.result) === true) {\n            eatToken();\n            fnResult.push.apply(fnResult, _toConsumableArray(parseFuncResult()));\n          } else {\n            throw function () {\n              return new Error("\\n" + codeFrameFromSource(source, token.loc) + "\\n" + "Unexpected token in import of type" + ", given " + tokenToString(token));\n            }();\n          }\n\n          eatTokenOfType(tokenizer_tokens.closeParen);\n        }\n\n        if (typeof fnName === "undefined") {\n          throw new Error("Imported function must have a name");\n        }\n\n        descr = funcImportDescr(fnName, typeRef !== undefined ? typeRef : nodes_signature(fnParams, fnResult));\n      } else if (isKeyword(token, keywords.global)) {\n        eatToken(); // keyword\n\n        if (token.type === tokenizer_tokens.openParen) {\n          eatToken(); // (\n\n          eatTokenOfType(tokenizer_tokens.keyword); // mut keyword\n\n          var valtype = token.value;\n          eatToken();\n          descr = globalType(valtype, "var");\n          eatTokenOfType(tokenizer_tokens.closeParen);\n        } else {\n          var _valtype = token.value;\n          eatTokenOfType(tokenizer_tokens.valtype);\n          descr = globalType(_valtype, "const");\n        }\n      } else if (isKeyword(token, keywords.memory) === true) {\n        eatToken(); // Keyword\n\n        descr = parseMemory();\n      } else if (isKeyword(token, keywords.table) === true) {\n        eatToken(); // Keyword\n\n        descr = parseTable();\n      } else {\n        throw new Error("Unsupported import type: " + tokenToString(token));\n      }\n\n      eatTokenOfType(tokenizer_tokens.closeParen);\n      return moduleImport(moduleName, name, descr);\n    }\n    /**\n     * Parses a block instruction\n     *\n     * WAST:\n     *\n     * expr: ( block <name>? <block_sig> <instr>* )\n     * instr: block <name>? <block_sig> <instr>* end <name>?\n     * block_sig : ( result <type>* )*\n     *\n     */\n\n\n    function parseBlock() {\n      var label = identifier(getUniqueName("block"));\n      var blockResult = null;\n      var instr = [];\n\n      if (token.type === tokenizer_tokens.identifier) {\n        label = identifierFromToken(token);\n        eatToken();\n      } else {\n        label = withRaw(label, ""); // preserve anonymous\n      }\n\n      while (token.type === tokenizer_tokens.openParen) {\n        eatToken();\n\n        if (lookaheadAndCheck(keywords.result) === true) {\n          eatToken();\n          blockResult = token.value;\n          eatToken();\n        } else if (lookaheadAndCheck(tokenizer_tokens.name) === true || lookaheadAndCheck(tokenizer_tokens.valtype) === true || token.type === "keyword" // is any keyword\n        ) {\n            // Instruction\n            instr.push(parseFuncInstr());\n          } else {\n          throw function () {\n            return new Error("\\n" + codeFrameFromSource(source, token.loc) + "\\n" + "Unexpected token in block body of type" + ", given " + tokenToString(token));\n          }();\n        }\n\n        maybeIgnoreComment();\n        eatTokenOfType(tokenizer_tokens.closeParen);\n      }\n\n      return blockInstruction(label, instr, blockResult);\n    }\n    /**\n     * Parses a if instruction\n     *\n     * WAST:\n     *\n     * expr:\n     * ( if <name>? <block_sig> ( then <instr>* ) ( else <instr>* )? )\n     * ( if <name>? <block_sig> <expr>+ ( then <instr>* ) ( else <instr>* )? )\n     *\n     * instr:\n     * if <name>? <block_sig> <instr>* end <name>?\n     * if <name>? <block_sig> <instr>* else <name>? <instr>* end <name>?\n     *\n     * block_sig : ( result <type>* )*\n     *\n     */\n\n\n    function parseIf() {\n      var blockResult = null;\n      var label = identifier(getUniqueName("if"));\n      var testInstrs = [];\n      var consequent = [];\n      var alternate = [];\n\n      if (token.type === tokenizer_tokens.identifier) {\n        label = identifierFromToken(token);\n        eatToken();\n      } else {\n        label = withRaw(label, ""); // preserve anonymous\n      }\n\n      while (token.type === tokenizer_tokens.openParen) {\n        eatToken(); // (\n\n        /**\n         * Block signature\n         */\n\n        if (isKeyword(token, keywords.result) === true) {\n          eatToken();\n          blockResult = token.value;\n          eatTokenOfType(tokenizer_tokens.valtype);\n          eatTokenOfType(tokenizer_tokens.closeParen);\n          continue;\n        }\n        /**\n         * Then\n         */\n\n\n        if (isKeyword(token, keywords.then) === true) {\n          eatToken(); // then\n\n          while (token.type === tokenizer_tokens.openParen) {\n            eatToken(); // Instruction\n\n            if (lookaheadAndCheck(tokenizer_tokens.name) === true || lookaheadAndCheck(tokenizer_tokens.valtype) === true || token.type === "keyword" // is any keyword\n            ) {\n                consequent.push(parseFuncInstr());\n              } else {\n              throw function () {\n                return new Error("\\n" + codeFrameFromSource(source, token.loc) + "\\n" + "Unexpected token in consequent body of type" + ", given " + tokenToString(token));\n              }();\n            }\n\n            eatTokenOfType(tokenizer_tokens.closeParen);\n          }\n\n          eatTokenOfType(tokenizer_tokens.closeParen);\n          continue;\n        }\n        /**\n         * Alternate\n         */\n\n\n        if (isKeyword(token, keywords.else)) {\n          eatToken(); // else\n\n          while (token.type === tokenizer_tokens.openParen) {\n            eatToken(); // Instruction\n\n            if (lookaheadAndCheck(tokenizer_tokens.name) === true || lookaheadAndCheck(tokenizer_tokens.valtype) === true || token.type === "keyword" // is any keyword\n            ) {\n                alternate.push(parseFuncInstr());\n              } else {\n              throw function () {\n                return new Error("\\n" + codeFrameFromSource(source, token.loc) + "\\n" + "Unexpected token in alternate body of type" + ", given " + tokenToString(token));\n              }();\n            }\n\n            eatTokenOfType(tokenizer_tokens.closeParen);\n          }\n\n          eatTokenOfType(tokenizer_tokens.closeParen);\n          continue;\n        }\n        /**\n         * Test instruction\n         */\n\n\n        if (lookaheadAndCheck(tokenizer_tokens.name) === true || lookaheadAndCheck(tokenizer_tokens.valtype) === true || token.type === "keyword" // is any keyword\n        ) {\n            testInstrs.push(parseFuncInstr());\n            eatTokenOfType(tokenizer_tokens.closeParen);\n            continue;\n          }\n\n        throw function () {\n          return new Error("\\n" + codeFrameFromSource(source, token.loc) + "\\n" + "Unexpected token in if body" + ", given " + tokenToString(token));\n        }();\n      }\n\n      return ifInstruction(label, testInstrs, blockResult, consequent, alternate);\n    }\n    /**\n     * Parses a loop instruction\n     *\n     * WAT:\n     *\n     * blockinstr :: \'loop\' I:label rt:resulttype (in:instr*) \'end\' id?\n     *\n     * WAST:\n     *\n     * instr     :: loop <name>? <block_sig> <instr>* end <name>?\n     * expr      :: ( loop <name>? <block_sig> <instr>* )\n     * block_sig :: ( result <type>* )*\n     *\n     */\n\n\n    function parseLoop() {\n      var label = identifier(getUniqueName("loop"));\n      var blockResult;\n      var instr = [];\n\n      if (token.type === tokenizer_tokens.identifier) {\n        label = identifierFromToken(token);\n        eatToken();\n      } else {\n        label = withRaw(label, ""); // preserve anonymous\n      }\n\n      while (token.type === tokenizer_tokens.openParen) {\n        eatToken();\n\n        if (lookaheadAndCheck(keywords.result) === true) {\n          eatToken();\n          blockResult = token.value;\n          eatToken();\n        } else if (lookaheadAndCheck(tokenizer_tokens.name) === true || lookaheadAndCheck(tokenizer_tokens.valtype) === true || token.type === "keyword" // is any keyword\n        ) {\n            // Instruction\n            instr.push(parseFuncInstr());\n          } else {\n          throw function () {\n            return new Error("\\n" + codeFrameFromSource(source, token.loc) + "\\n" + "Unexpected token in loop body" + ", given " + tokenToString(token));\n          }();\n        }\n\n        eatTokenOfType(tokenizer_tokens.closeParen);\n      }\n\n      return loopInstruction(label, blockResult, instr);\n    }\n\n    function parseCallIndirect() {\n      var typeRef;\n      var params = [];\n      var results = [];\n      var instrs = [];\n\n      while (token.type !== tokenizer_tokens.closeParen) {\n        if (lookaheadAndCheck(tokenizer_tokens.openParen, keywords.type)) {\n          eatToken(); // (\n\n          eatToken(); // type\n\n          typeRef = parseTypeReference();\n        } else if (lookaheadAndCheck(tokenizer_tokens.openParen, keywords.param)) {\n          eatToken(); // (\n\n          eatToken(); // param\n\n          /**\n           * Params can be empty:\n           * (params)`\n           */\n\n          if (token.type !== tokenizer_tokens.closeParen) {\n            params.push.apply(params, _toConsumableArray(parseFuncParam()));\n          }\n        } else if (lookaheadAndCheck(tokenizer_tokens.openParen, keywords.result)) {\n          eatToken(); // (\n\n          eatToken(); // result\n\n          /**\n           * Results can be empty:\n           * (result)`\n           */\n\n          if (token.type !== tokenizer_tokens.closeParen) {\n            results.push.apply(results, _toConsumableArray(parseFuncResult()));\n          }\n        } else {\n          eatTokenOfType(tokenizer_tokens.openParen);\n          instrs.push(parseFuncInstr());\n        }\n\n        eatTokenOfType(tokenizer_tokens.closeParen);\n      }\n\n      return callIndirectInstruction(typeRef !== undefined ? typeRef : nodes_signature(params, results), instrs);\n    }\n    /**\n     * Parses an export instruction\n     *\n     * WAT:\n     *\n     * export:  ( export <string> <exkind> )\n     * exkind:  ( func <var> )\n     *          ( global <var> )\n     *          ( table <var> )\n     *          ( memory <var> )\n     * var:    <nat> | <name>\n     *\n     */\n\n\n    function parseExport() {\n      if (token.type !== tokenizer_tokens.string) {\n        throw new Error("Expected string after export, got: " + token.type);\n      }\n\n      var name = token.value;\n      eatToken();\n      var moduleExportDescr = parseModuleExportDescr();\n      return moduleExport(name, moduleExportDescr);\n    }\n\n    function parseModuleExportDescr() {\n      var startLoc = getStartLoc();\n      var type = "";\n      var index;\n      eatTokenOfType(tokenizer_tokens.openParen);\n\n      while (token.type !== tokenizer_tokens.closeParen) {\n        if (isKeyword(token, keywords.func)) {\n          type = "Func";\n          eatToken();\n          index = parseExportIndex(token);\n        } else if (isKeyword(token, keywords.table)) {\n          type = "Table";\n          eatToken();\n          index = parseExportIndex(token);\n        } else if (isKeyword(token, keywords.global)) {\n          type = "Global";\n          eatToken();\n          index = parseExportIndex(token);\n        } else if (isKeyword(token, keywords.memory)) {\n          type = "Memory";\n          eatToken();\n          index = parseExportIndex(token);\n        }\n\n        eatToken();\n      }\n\n      if (type === "") {\n        throw new Error("Unknown export type");\n      }\n\n      if (index === undefined) {\n        throw new Error("Exported function must have a name");\n      }\n\n      var node = nodes_moduleExportDescr(type, index);\n      var endLoc = getEndLoc();\n      eatTokenOfType(tokenizer_tokens.closeParen);\n      return withLoc(node, endLoc, startLoc);\n    }\n\n    function parseModule() {\n      var name = null;\n      var isBinary = false;\n      var isQuote = false;\n      var moduleFields = [];\n\n      if (token.type === tokenizer_tokens.identifier) {\n        name = token.value;\n        eatToken();\n      }\n\n      if (hasPlugin("wast") && token.type === tokenizer_tokens.name && token.value === "binary") {\n        eatToken();\n        isBinary = true;\n      }\n\n      if (hasPlugin("wast") && token.type === tokenizer_tokens.name && token.value === "quote") {\n        eatToken();\n        isQuote = true;\n      }\n\n      if (isBinary === true) {\n        var blob = [];\n\n        while (token.type === tokenizer_tokens.string) {\n          blob.push(token.value);\n          eatToken();\n          maybeIgnoreComment();\n        }\n\n        eatTokenOfType(tokenizer_tokens.closeParen);\n        return binaryModule(name, blob);\n      }\n\n      if (isQuote === true) {\n        var string = [];\n\n        while (token.type === tokenizer_tokens.string) {\n          string.push(token.value);\n          eatToken();\n        }\n\n        eatTokenOfType(tokenizer_tokens.closeParen);\n        return quoteModule(name, string);\n      }\n\n      while (token.type !== tokenizer_tokens.closeParen) {\n        moduleFields.push(walk());\n\n        if (state.registredExportedElements.length > 0) {\n          state.registredExportedElements.forEach(function (decl) {\n            moduleFields.push(moduleExport(decl.name, nodes_moduleExportDescr(decl.exportType, decl.id)));\n          });\n          state.registredExportedElements = [];\n        }\n\n        token = tokensList[current];\n      }\n\n      eatTokenOfType(tokenizer_tokens.closeParen);\n      return nodes_module(name, moduleFields);\n    }\n    /**\n     * Parses the arguments of an instruction\n     */\n\n\n    function parseFuncInstrArguments(signature) {\n      var args = [];\n      var namedArgs = {};\n      var signaturePtr = 0;\n\n      while (token.type === tokenizer_tokens.name || isKeyword(token, keywords.offset)) {\n        var key = token.value;\n        eatToken();\n        eatTokenOfType(tokenizer_tokens.equal);\n        var value = void 0;\n\n        if (token.type === tokenizer_tokens.number) {\n          value = numberLiteralFromRaw(token.value);\n        } else {\n          throw new Error("Unexpected type for argument: " + token.type);\n        }\n\n        namedArgs[key] = value;\n        eatToken();\n      } // $FlowIgnore\n\n\n      var signatureLength = signature.vector ? Infinity : signature.length;\n\n      while (token.type !== tokenizer_tokens.closeParen && ( // $FlowIgnore\n      token.type === tokenizer_tokens.openParen || signaturePtr < signatureLength)) {\n        if (token.type === tokenizer_tokens.identifier) {\n          args.push(identifier(token.value));\n          eatToken();\n        } else if (token.type === tokenizer_tokens.valtype) {\n          // Handle locals\n          args.push(valtypeLiteral(token.value));\n          eatToken();\n        } else if (token.type === tokenizer_tokens.string) {\n          args.push(stringLiteral(token.value));\n          eatToken();\n        } else if (token.type === tokenizer_tokens.number) {\n          args.push( // TODO(sven): refactor the type signature handling\n          // https://github.com/xtuc/webassemblyjs/pull/129 is a good start\n          numberLiteralFromRaw(token.value, // $FlowIgnore\n          signature[signaturePtr] || "f64")); // $FlowIgnore\n\n          if (!signature.vector) {\n            ++signaturePtr;\n          }\n\n          eatToken();\n        } else if (token.type === tokenizer_tokens.openParen) {\n          /**\n           * Maybe some nested instructions\n           */\n          eatToken(); // Instruction\n\n          if (lookaheadAndCheck(tokenizer_tokens.name) === true || lookaheadAndCheck(tokenizer_tokens.valtype) === true || token.type === "keyword" // is any keyword\n          ) {\n              // $FlowIgnore\n              args.push(parseFuncInstr());\n            } else {\n            throw function () {\n              return new Error("\\n" + codeFrameFromSource(source, token.loc) + "\\n" + "Unexpected token in nested instruction" + ", given " + tokenToString(token));\n            }();\n          }\n\n          if (token.type === tokenizer_tokens.closeParen) {\n            eatToken();\n          }\n        } else {\n          throw function () {\n            return new Error("\\n" + codeFrameFromSource(source, token.loc) + "\\n" + "Unexpected token in instruction argument" + ", given " + tokenToString(token));\n          }();\n        }\n      }\n\n      return {\n        args: args,\n        namedArgs: namedArgs\n      };\n    }\n    /**\n     * Parses an instruction\n     *\n     * WAT:\n     *\n     * instr      :: plaininst\n     *               blockinstr\n     *\n     * blockinstr :: \'block\' I:label rt:resulttype (in:instr*) \'end\' id?\n     *               \'loop\' I:label rt:resulttype (in:instr*) \'end\' id?\n     *               \'if\' I:label rt:resulttype (in:instr*) \'else\' id? (in2:intr*) \'end\' id?\n     *\n     * plaininst  :: \'unreachable\'\n     *               \'nop\'\n     *               \'br\' l:labelidx\n     *               \'br_if\' l:labelidx\n     *               \'br_table\' l*:vec(labelidx) ln:labelidx\n     *               \'return\'\n     *               \'call\' x:funcidx\n     *               \'call_indirect\' x, I:typeuse\n     *\n     * WAST:\n     *\n     * instr:\n     *   <expr>\n     *   <op>\n     *   block <name>? <block_sig> <instr>* end <name>?\n     *   loop <name>? <block_sig> <instr>* end <name>?\n     *   if <name>? <block_sig> <instr>* end <name>?\n     *   if <name>? <block_sig> <instr>* else <name>? <instr>* end <name>?\n     *\n     * expr:\n     *   ( <op> )\n     *   ( <op> <expr>+ )\n     *   ( block <name>? <block_sig> <instr>* )\n     *   ( loop <name>? <block_sig> <instr>* )\n     *   ( if <name>? <block_sig> ( then <instr>* ) ( else <instr>* )? )\n     *   ( if <name>? <block_sig> <expr>+ ( then <instr>* ) ( else <instr>* )? )\n     *\n     * op:\n     *   unreachable\n     *   nop\n     *   br <var>\n     *   br_if <var>\n     *   br_table <var>+\n     *   return\n     *   call <var>\n     *   call_indirect <func_sig>\n     *   drop\n     *   select\n     *   get_local <var>\n     *   set_local <var>\n     *   tee_local <var>\n     *   get_global <var>\n     *   set_global <var>\n     *   <type>.load((8|16|32)_<sign>)? <offset>? <align>?\n     *   <type>.store(8|16|32)? <offset>? <align>?\n     *   current_memory\n     *   grow_memory\n     *   <type>.const <value>\n     *   <type>.<unop>\n     *   <type>.<binop>\n     *   <type>.<testop>\n     *   <type>.<relop>\n     *   <type>.<cvtop>/<type>\n     *\n     * func_type:   ( type <var> )? <param>* <result>*\n     */\n\n\n    function parseFuncInstr() {\n      var startLoc = getStartLoc();\n      maybeIgnoreComment();\n      /**\n       * A simple instruction\n       */\n\n      if (token.type === tokenizer_tokens.name || token.type === tokenizer_tokens.valtype) {\n        var _name2 = token.value;\n        var object;\n        eatToken();\n\n        if (token.type === tokenizer_tokens.dot) {\n          object = _name2;\n          eatToken();\n\n          if (token.type !== tokenizer_tokens.name) {\n            throw new TypeError("Unknown token: " + token.type + ", name expected");\n          }\n\n          _name2 = token.value;\n          eatToken();\n        }\n\n        if (token.type === tokenizer_tokens.closeParen) {\n          var _endLoc = token.loc.end;\n\n          if (typeof object === "undefined") {\n            return withLoc(node_helpers_instruction(_name2), _endLoc, startLoc);\n          } else {\n            return withLoc(objectInstruction(_name2, object, []), _endLoc, startLoc);\n          }\n        }\n\n        var signature = signatureForOpcode(object || "", _name2);\n\n        var _parseFuncInstrArgume = parseFuncInstrArguments(signature),\n            _args = _parseFuncInstrArgume.args,\n            _namedArgs = _parseFuncInstrArgume.namedArgs;\n\n        var endLoc = token.loc.end;\n\n        if (typeof object === "undefined") {\n          return withLoc(node_helpers_instruction(_name2, _args, _namedArgs), endLoc, startLoc);\n        } else {\n          return withLoc(objectInstruction(_name2, object, _args, _namedArgs), endLoc, startLoc);\n        }\n      } else if (isKeyword(token, keywords.loop)) {\n        /**\n         * Else a instruction with a keyword (loop or block)\n         */\n        eatToken(); // keyword\n\n        return parseLoop();\n      } else if (isKeyword(token, keywords.block)) {\n        eatToken(); // keyword\n\n        return parseBlock();\n      } else if (isKeyword(token, keywords.call_indirect)) {\n        eatToken(); // keyword\n\n        return parseCallIndirect();\n      } else if (isKeyword(token, keywords.call)) {\n        eatToken(); // keyword\n\n        var index;\n\n        if (token.type === tokenizer_tokens.identifier) {\n          index = identifierFromToken(token);\n          eatToken();\n        } else if (token.type === tokenizer_tokens.number) {\n          index = indexLiteral(token.value);\n          eatToken();\n        }\n\n        var instrArgs = []; // Nested instruction\n\n        while (token.type === tokenizer_tokens.openParen) {\n          eatToken();\n          instrArgs.push(parseFuncInstr());\n          eatTokenOfType(tokenizer_tokens.closeParen);\n        }\n\n        if (typeof index === "undefined") {\n          throw new Error("Missing argument in call instruciton");\n        }\n\n        if (instrArgs.length > 0) {\n          return callInstruction(index, instrArgs);\n        } else {\n          return callInstruction(index);\n        }\n      } else if (isKeyword(token, keywords.if)) {\n        eatToken(); // Keyword\n\n        return parseIf();\n      } else if (isKeyword(token, keywords.module) && hasPlugin("wast")) {\n        eatToken(); // In WAST you can have a module as an instruction\'s argument\n        // we will cast it into a instruction to not break the flow\n        // $FlowIgnore\n\n        var module = parseModule();\n        return module;\n      } else {\n        throw function () {\n          return new Error("\\n" + codeFrameFromSource(source, token.loc) + "\\n" + "Unexpected instruction in function body" + ", given " + tokenToString(token));\n        }();\n      }\n    }\n    /*\n     * Parses a function\n     *\n     * WAT:\n     *\n     * functype :: ( \'func\' t1:vec(param) t2:vec(result) )\n     * param    :: ( \'param\' id? t:valtype )\n     * result   :: ( \'result\' t:valtype )\n     *\n     * WAST:\n     *\n     * func     :: ( func <name>? <func_sig> <local>* <instr>* )\n     *             ( func <name>? ( export <string> ) <...> )\n     *             ( func <name>? ( import <string> <string> ) <func_sig> )\n     * func_sig :: ( type <var> )? <param>* <result>*\n     * param    :: ( param <type>* ) | ( param <name> <type> )\n     * result   :: ( result <type>* )\n     * local    :: ( local <type>* ) | ( local <name> <type> )\n     *\n     */\n\n\n    function parseFunc() {\n      var fnName = identifier(getUniqueName("func"));\n      var typeRef;\n      var fnBody = [];\n      var fnParams = [];\n      var fnResult = []; // name\n\n      if (token.type === tokenizer_tokens.identifier) {\n        fnName = identifierFromToken(token);\n        eatToken();\n      } else {\n        fnName = withRaw(fnName, ""); // preserve anonymous\n      }\n\n      maybeIgnoreComment();\n\n      while (token.type === tokenizer_tokens.openParen || token.type === tokenizer_tokens.name || token.type === tokenizer_tokens.valtype) {\n        // Instructions without parens\n        if (token.type === tokenizer_tokens.name || token.type === tokenizer_tokens.valtype) {\n          fnBody.push(parseFuncInstr());\n          continue;\n        }\n\n        eatToken();\n\n        if (lookaheadAndCheck(keywords.param) === true) {\n          eatToken();\n          fnParams.push.apply(fnParams, _toConsumableArray(parseFuncParam()));\n        } else if (lookaheadAndCheck(keywords.result) === true) {\n          eatToken();\n          fnResult.push.apply(fnResult, _toConsumableArray(parseFuncResult()));\n        } else if (lookaheadAndCheck(keywords.export) === true) {\n          eatToken();\n          parseFuncExport(fnName);\n        } else if (lookaheadAndCheck(keywords.type) === true) {\n          eatToken();\n          typeRef = parseTypeReference();\n        } else if (lookaheadAndCheck(tokenizer_tokens.name) === true || lookaheadAndCheck(tokenizer_tokens.valtype) === true || token.type === "keyword" // is any keyword\n        ) {\n            // Instruction\n            fnBody.push(parseFuncInstr());\n          } else {\n          throw function () {\n            return new Error("\\n" + codeFrameFromSource(source, token.loc) + "\\n" + "Unexpected token in func body" + ", given " + tokenToString(token));\n          }();\n        }\n\n        eatTokenOfType(tokenizer_tokens.closeParen);\n      }\n\n      return func(fnName, typeRef !== undefined ? typeRef : nodes_signature(fnParams, fnResult), fnBody);\n    }\n    /**\n     * Parses shorthand export in func\n     *\n     * export :: ( export <string> )\n     */\n\n\n    function parseFuncExport(funcId) {\n      if (token.type !== tokenizer_tokens.string) {\n        throw function () {\n          return new Error("\\n" + codeFrameFromSource(source, token.loc) + "\\n" + "Function export expected a string" + ", given " + tokenToString(token));\n        }();\n      }\n\n      var name = token.value;\n      eatToken();\n      /**\n       * Func export shorthand, we trait it as a syntaxic sugar.\n       * A export ModuleField will be added later.\n       *\n       * We give the anonymous function a generated name and export it.\n       */\n\n      var id = identifier(funcId.value);\n      state.registredExportedElements.push({\n        exportType: "Func",\n        name: name,\n        id: id\n      });\n    }\n    /**\n     * Parses a type instruction\n     *\n     * WAST:\n     *\n     * typedef: ( type <name>? ( func <param>* <result>* ) )\n     */\n\n\n    function parseType() {\n      var id;\n      var params = [];\n      var result = [];\n\n      if (token.type === tokenizer_tokens.identifier) {\n        id = identifierFromToken(token);\n        eatToken();\n      }\n\n      if (lookaheadAndCheck(tokenizer_tokens.openParen, keywords.func)) {\n        eatToken(); // (\n\n        eatToken(); // func\n\n        if (token.type === tokenizer_tokens.closeParen) {\n          eatToken(); // function with an empty signature, we can abort here\n\n          return typeInstruction(id, nodes_signature([], []));\n        }\n\n        if (lookaheadAndCheck(tokenizer_tokens.openParen, keywords.param)) {\n          eatToken(); // (\n\n          eatToken(); // param\n\n          params = parseFuncParam();\n          eatTokenOfType(tokenizer_tokens.closeParen);\n        }\n\n        if (lookaheadAndCheck(tokenizer_tokens.openParen, keywords.result)) {\n          eatToken(); // (\n\n          eatToken(); // result\n\n          result = parseFuncResult();\n          eatTokenOfType(tokenizer_tokens.closeParen);\n        }\n\n        eatTokenOfType(tokenizer_tokens.closeParen);\n      }\n\n      return typeInstruction(id, nodes_signature(params, result));\n    }\n    /**\n     * Parses a function result\n     *\n     * WAST:\n     *\n     * result :: ( result <type>* )\n     */\n\n\n    function parseFuncResult() {\n      var results = [];\n\n      while (token.type !== tokenizer_tokens.closeParen) {\n        if (token.type !== tokenizer_tokens.valtype) {\n          throw function () {\n            return new Error("\\n" + codeFrameFromSource(source, token.loc) + "\\n" + "Unexpected token in func result" + ", given " + tokenToString(token));\n          }();\n        }\n\n        var valtype = token.value;\n        eatToken();\n        results.push(valtype);\n      }\n\n      return results;\n    }\n    /**\n     * Parses a type reference\n     *\n     */\n\n\n    function parseTypeReference() {\n      var ref;\n\n      if (token.type === tokenizer_tokens.identifier) {\n        ref = identifierFromToken(token);\n        eatToken();\n      } else if (token.type === tokenizer_tokens.number) {\n        ref = numberLiteralFromRaw(token.value);\n        eatToken();\n      }\n\n      return ref;\n    }\n    /**\n     * Parses a global instruction\n     *\n     * WAST:\n     *\n     * global:  ( global <name>? <global_sig> <instr>* )\n     *          ( global <name>? ( export <string> ) <...> )\n     *          ( global <name>? ( import <string> <string> ) <global_sig> )\n     *\n     * global_sig: <type> | ( mut <type> )\n     *\n     */\n\n\n    function parseGlobal() {\n      var name = identifier(getUniqueName("global"));\n      var type; // Keep informations in case of a shorthand import\n\n      var importing = null;\n      maybeIgnoreComment();\n\n      if (token.type === tokenizer_tokens.identifier) {\n        name = identifierFromToken(token);\n        eatToken();\n      } else {\n        name = withRaw(name, ""); // preserve anonymous\n      }\n      /**\n       * maybe export\n       */\n\n\n      if (lookaheadAndCheck(tokenizer_tokens.openParen, keywords.export)) {\n        eatToken(); // (\n\n        eatToken(); // export\n\n        var exportName = token.value;\n        eatTokenOfType(tokenizer_tokens.string);\n        state.registredExportedElements.push({\n          exportType: "Global",\n          name: exportName,\n          id: name\n        });\n        eatTokenOfType(tokenizer_tokens.closeParen);\n      }\n      /**\n       * maybe import\n       */\n\n\n      if (lookaheadAndCheck(tokenizer_tokens.openParen, keywords.import)) {\n        eatToken(); // (\n\n        eatToken(); // import\n\n        var moduleName = token.value;\n        eatTokenOfType(tokenizer_tokens.string);\n        var _name3 = token.value;\n        eatTokenOfType(tokenizer_tokens.string);\n        importing = {\n          module: moduleName,\n          name: _name3,\n          descr: undefined\n        };\n        eatTokenOfType(tokenizer_tokens.closeParen);\n      }\n      /**\n       * global_sig\n       */\n\n\n      if (token.type === tokenizer_tokens.valtype) {\n        type = globalType(token.value, "const");\n        eatToken();\n      } else if (token.type === tokenizer_tokens.openParen) {\n        eatToken(); // (\n\n        if (isKeyword(token, keywords.mut) === false) {\n          throw function () {\n            return new Error("\\n" + codeFrameFromSource(source, token.loc) + "\\n" + "Unsupported global type, expected mut" + ", given " + tokenToString(token));\n          }();\n        }\n\n        eatToken(); // mut\n\n        type = globalType(token.value, "var");\n        eatToken();\n        eatTokenOfType(tokenizer_tokens.closeParen);\n      }\n\n      if (type === undefined) {\n        throw function () {\n          return new Error("\\n" + codeFrameFromSource(source, token.loc) + "\\n" + "Could not determine global type" + ", given " + tokenToString(token));\n        }();\n      }\n\n      maybeIgnoreComment();\n      var init = [];\n\n      if (importing != null) {\n        importing.descr = type;\n        init.push(moduleImport(importing.module, importing.name, importing.descr));\n      }\n      /**\n       * instr*\n       */\n\n\n      while (token.type === tokenizer_tokens.openParen) {\n        eatToken();\n        init.push(parseFuncInstr());\n        eatTokenOfType(tokenizer_tokens.closeParen);\n      }\n\n      return global(type, init, name);\n    }\n    /**\n     * Parses a function param\n     *\n     * WAST:\n     *\n     * param    :: ( param <type>* ) | ( param <name> <type> )\n     */\n\n\n    function parseFuncParam() {\n      var params = [];\n      var id;\n      var valtype;\n\n      if (token.type === tokenizer_tokens.identifier) {\n        id = token.value;\n        eatToken();\n      }\n\n      if (token.type === tokenizer_tokens.valtype) {\n        valtype = token.value;\n        eatToken();\n        params.push({\n          id: id,\n          valtype: valtype\n        });\n        /**\n         * Shorthand notation for multiple anonymous parameters\n         * @see https://webassembly.github.io/spec/core/text/types.html#function-types\n         * @see https://github.com/xtuc/webassemblyjs/issues/6\n         */\n\n        if (id === undefined) {\n          while (token.type === tokenizer_tokens.valtype) {\n            valtype = token.value;\n            eatToken();\n            params.push({\n              id: undefined,\n              valtype: valtype\n            });\n          }\n        }\n      } else {// ignore\n      }\n\n      return params;\n    }\n    /**\n     * Parses an element segments instruction\n     *\n     * WAST:\n     *\n     * elem:    ( elem <var>? (offset <instr>* ) <var>* )\n     *          ( elem <var>? <expr> <var>* )\n     *\n     * var:    <nat> | <name>\n     */\n\n\n    function parseElem() {\n      var tableIndex = indexLiteral(0);\n      var offset = [];\n      var funcs = [];\n\n      if (token.type === tokenizer_tokens.identifier) {\n        tableIndex = identifierFromToken(token);\n        eatToken();\n      }\n\n      if (token.type === tokenizer_tokens.number) {\n        tableIndex = indexLiteral(token.value);\n        eatToken();\n      }\n\n      while (token.type !== tokenizer_tokens.closeParen) {\n        if (lookaheadAndCheck(tokenizer_tokens.openParen, keywords.offset)) {\n          eatToken(); // (\n\n          eatToken(); // offset\n\n          while (token.type !== tokenizer_tokens.closeParen) {\n            eatTokenOfType(tokenizer_tokens.openParen);\n            offset.push(parseFuncInstr());\n            eatTokenOfType(tokenizer_tokens.closeParen);\n          }\n\n          eatTokenOfType(tokenizer_tokens.closeParen);\n        } else if (token.type === tokenizer_tokens.identifier) {\n          funcs.push(identifier(token.value));\n          eatToken();\n        } else if (token.type === tokenizer_tokens.number) {\n          funcs.push(indexLiteral(token.value));\n          eatToken();\n        } else if (token.type === tokenizer_tokens.openParen) {\n          eatToken(); // (\n\n          offset.push(parseFuncInstr());\n          eatTokenOfType(tokenizer_tokens.closeParen);\n        } else {\n          throw function () {\n            return new Error("\\n" + codeFrameFromSource(source, token.loc) + "\\n" + "Unsupported token in elem" + ", given " + tokenToString(token));\n          }();\n        }\n      }\n\n      return elem(tableIndex, offset, funcs);\n    }\n    /**\n     * Parses the start instruction in a module\n     *\n     * WAST:\n     *\n     * start:   ( start <var> )\n     * var:    <nat> | <name>\n     *\n     * WAT:\n     * start ::= ( start  x:funcidx )\n     */\n\n\n    function parseStart() {\n      if (token.type === tokenizer_tokens.identifier) {\n        var index = identifierFromToken(token);\n        eatToken();\n        return nodes_start(index);\n      }\n\n      if (token.type === tokenizer_tokens.number) {\n        var _index2 = indexLiteral(token.value);\n\n        eatToken();\n        return nodes_start(_index2);\n      }\n\n      throw new Error("Unknown start, token: " + tokenToString(token));\n    }\n\n    if (token.type === tokenizer_tokens.openParen) {\n      eatToken();\n      var startLoc = getStartLoc();\n\n      if (isKeyword(token, keywords.export)) {\n        eatToken();\n        var node = parseExport();\n\n        var _endLoc2 = getEndLoc();\n\n        return withLoc(node, _endLoc2, startLoc);\n      }\n\n      if (isKeyword(token, keywords.loop)) {\n        eatToken();\n\n        var _node = parseLoop();\n\n        var _endLoc3 = getEndLoc();\n\n        return withLoc(_node, _endLoc3, startLoc);\n      }\n\n      if (isKeyword(token, keywords.func)) {\n        eatToken();\n\n        var _node2 = parseFunc();\n\n        var _endLoc4 = getEndLoc();\n\n        maybeIgnoreComment();\n        eatTokenOfType(tokenizer_tokens.closeParen);\n        return withLoc(_node2, _endLoc4, startLoc);\n      }\n\n      if (isKeyword(token, keywords.module)) {\n        eatToken();\n\n        var _node3 = parseModule();\n\n        var _endLoc5 = getEndLoc();\n\n        return withLoc(_node3, _endLoc5, startLoc);\n      }\n\n      if (isKeyword(token, keywords.import)) {\n        eatToken();\n\n        var _node4 = parseImport();\n\n        var _endLoc6 = getEndLoc();\n\n        eatTokenOfType(tokenizer_tokens.closeParen);\n        return withLoc(_node4, _endLoc6, startLoc);\n      }\n\n      if (isKeyword(token, keywords.block)) {\n        eatToken();\n\n        var _node5 = parseBlock();\n\n        var _endLoc7 = getEndLoc();\n\n        eatTokenOfType(tokenizer_tokens.closeParen);\n        return withLoc(_node5, _endLoc7, startLoc);\n      }\n\n      if (isKeyword(token, keywords.memory)) {\n        eatToken();\n\n        var _node6 = parseMemory();\n\n        var _endLoc8 = getEndLoc();\n\n        eatTokenOfType(tokenizer_tokens.closeParen);\n        return withLoc(_node6, _endLoc8, startLoc);\n      }\n\n      if (isKeyword(token, keywords.data)) {\n        eatToken();\n\n        var _node7 = parseData();\n\n        var _endLoc9 = getEndLoc();\n\n        eatTokenOfType(tokenizer_tokens.closeParen);\n        return withLoc(_node7, _endLoc9, startLoc);\n      }\n\n      if (isKeyword(token, keywords.table)) {\n        eatToken();\n\n        var _node8 = parseTable();\n\n        var _endLoc10 = getEndLoc();\n\n        eatTokenOfType(tokenizer_tokens.closeParen);\n        return withLoc(_node8, _endLoc10, startLoc);\n      }\n\n      if (isKeyword(token, keywords.global)) {\n        eatToken();\n\n        var _node9 = parseGlobal();\n\n        var _endLoc11 = getEndLoc();\n\n        eatTokenOfType(tokenizer_tokens.closeParen);\n        return withLoc(_node9, _endLoc11, startLoc);\n      }\n\n      if (isKeyword(token, keywords.type)) {\n        eatToken();\n\n        var _node10 = parseType();\n\n        var _endLoc12 = getEndLoc();\n\n        eatTokenOfType(tokenizer_tokens.closeParen);\n        return withLoc(_node10, _endLoc12, startLoc);\n      }\n\n      if (isKeyword(token, keywords.start)) {\n        eatToken();\n\n        var _node11 = parseStart();\n\n        var _endLoc13 = getEndLoc();\n\n        eatTokenOfType(tokenizer_tokens.closeParen);\n        return withLoc(_node11, _endLoc13, startLoc);\n      }\n\n      if (isKeyword(token, keywords.elem)) {\n        eatToken();\n\n        var _node12 = parseElem();\n\n        var _endLoc14 = getEndLoc();\n\n        eatTokenOfType(tokenizer_tokens.closeParen);\n        return withLoc(_node12, _endLoc14, startLoc);\n      }\n\n      var instruction = parseFuncInstr();\n      var endLoc = getEndLoc();\n      maybeIgnoreComment();\n\n      if (grammar_typeof(instruction) === "object") {\n        if (typeof token !== "undefined") {\n          eatTokenOfType(tokenizer_tokens.closeParen);\n        }\n\n        return withLoc(instruction, endLoc, startLoc);\n      }\n    }\n\n    if (token.type === tokenizer_tokens.comment) {\n      var _startLoc = getStartLoc();\n\n      var builder = token.opts.type === "leading" ? leadingComment : blockComment;\n\n      var _node13 = builder(token.value);\n\n      eatToken(); // comment\n\n      var _endLoc15 = getEndLoc();\n\n      return withLoc(_node13, _endLoc15, _startLoc);\n    }\n\n    throw function () {\n      return new Error("\\n" + codeFrameFromSource(source, token.loc) + "\\n" + "Unknown token" + ", given " + tokenToString(token));\n    }();\n  }\n\n  var body = [];\n\n  while (current < tokensList.length) {\n    body.push(walk());\n  }\n\n  return program(body);\n}\n// CONCATENATED MODULE: ./node_modules/@webassemblyjs/wast-parser/esm/index.js\n\n\nfunction esm_parse(source) {\n  var tokens = tokenize(source); // We pass the source here to show code frames\n\n  var ast = grammar_parse(tokens, source);\n  return ast;\n}\n\n\n//# sourceURL=webpack:///./node_modules/@webassemblyjs/wast-parser/esm/index.js_+_19_modules?')},"./node_modules/@xtuc/long/src/long.js":function(module,exports){eval("module.exports = Long;\n\n/**\n * wasm optimizations, to do native i64 multiplication and divide\n */\nvar wasm = null;\n\ntry {\n  wasm = new WebAssembly.Instance(new WebAssembly.Module(new Uint8Array([\n    0, 97, 115, 109, 1, 0, 0, 0, 1, 13, 2, 96, 0, 1, 127, 96, 4, 127, 127, 127, 127, 1, 127, 3, 7, 6, 0, 1, 1, 1, 1, 1, 6, 6, 1, 127, 1, 65, 0, 11, 7, 50, 6, 3, 109, 117, 108, 0, 1, 5, 100, 105, 118, 95, 115, 0, 2, 5, 100, 105, 118, 95, 117, 0, 3, 5, 114, 101, 109, 95, 115, 0, 4, 5, 114, 101, 109, 95, 117, 0, 5, 8, 103, 101, 116, 95, 104, 105, 103, 104, 0, 0, 10, 191, 1, 6, 4, 0, 35, 0, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 126, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 127, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 128, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 129, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 130, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11\n  ])), {}).exports;\n} catch (e) {\n  // no wasm support :(\n}\n\n/**\n * Constructs a 64 bit two's-complement integer, given its low and high 32 bit values as *signed* integers.\n *  See the from* functions below for more convenient ways of constructing Longs.\n * @exports Long\n * @class A Long class for representing a 64 bit two's-complement integer value.\n * @param {number} low The low (signed) 32 bits of the long\n * @param {number} high The high (signed) 32 bits of the long\n * @param {boolean=} unsigned Whether unsigned or not, defaults to signed\n * @constructor\n */\nfunction Long(low, high, unsigned) {\n\n    /**\n     * The low 32 bits as a signed value.\n     * @type {number}\n     */\n    this.low = low | 0;\n\n    /**\n     * The high 32 bits as a signed value.\n     * @type {number}\n     */\n    this.high = high | 0;\n\n    /**\n     * Whether unsigned or not.\n     * @type {boolean}\n     */\n    this.unsigned = !!unsigned;\n}\n\n// The internal representation of a long is the two given signed, 32-bit values.\n// We use 32-bit pieces because these are the size of integers on which\n// Javascript performs bit-operations.  For operations like addition and\n// multiplication, we split each number into 16 bit pieces, which can easily be\n// multiplied within Javascript's floating-point representation without overflow\n// or change in sign.\n//\n// In the algorithms below, we frequently reduce the negative case to the\n// positive case by negating the input(s) and then post-processing the result.\n// Note that we must ALWAYS check specially whether those values are MIN_VALUE\n// (-2^63) because -MIN_VALUE == MIN_VALUE (since 2^63 cannot be represented as\n// a positive number, it overflows back into a negative).  Not handling this\n// case would often result in infinite recursion.\n//\n// Common constant values ZERO, ONE, NEG_ONE, etc. are defined below the from*\n// methods on which they depend.\n\n/**\n * An indicator used to reliably determine if an object is a Long or not.\n * @type {boolean}\n * @const\n * @private\n */\nLong.prototype.__isLong__;\n\nObject.defineProperty(Long.prototype, \"__isLong__\", { value: true });\n\n/**\n * @function\n * @param {*} obj Object\n * @returns {boolean}\n * @inner\n */\nfunction isLong(obj) {\n    return (obj && obj[\"__isLong__\"]) === true;\n}\n\n/**\n * Tests if the specified object is a Long.\n * @function\n * @param {*} obj Object\n * @returns {boolean}\n */\nLong.isLong = isLong;\n\n/**\n * A cache of the Long representations of small integer values.\n * @type {!Object}\n * @inner\n */\nvar INT_CACHE = {};\n\n/**\n * A cache of the Long representations of small unsigned integer values.\n * @type {!Object}\n * @inner\n */\nvar UINT_CACHE = {};\n\n/**\n * @param {number} value\n * @param {boolean=} unsigned\n * @returns {!Long}\n * @inner\n */\nfunction fromInt(value, unsigned) {\n    var obj, cachedObj, cache;\n    if (unsigned) {\n        value >>>= 0;\n        if (cache = (0 <= value && value < 256)) {\n            cachedObj = UINT_CACHE[value];\n            if (cachedObj)\n                return cachedObj;\n        }\n        obj = fromBits(value, (value | 0) < 0 ? -1 : 0, true);\n        if (cache)\n            UINT_CACHE[value] = obj;\n        return obj;\n    } else {\n        value |= 0;\n        if (cache = (-128 <= value && value < 128)) {\n            cachedObj = INT_CACHE[value];\n            if (cachedObj)\n                return cachedObj;\n        }\n        obj = fromBits(value, value < 0 ? -1 : 0, false);\n        if (cache)\n            INT_CACHE[value] = obj;\n        return obj;\n    }\n}\n\n/**\n * Returns a Long representing the given 32 bit integer value.\n * @function\n * @param {number} value The 32 bit integer in question\n * @param {boolean=} unsigned Whether unsigned or not, defaults to signed\n * @returns {!Long} The corresponding Long value\n */\nLong.fromInt = fromInt;\n\n/**\n * @param {number} value\n * @param {boolean=} unsigned\n * @returns {!Long}\n * @inner\n */\nfunction fromNumber(value, unsigned) {\n    if (isNaN(value))\n        return unsigned ? UZERO : ZERO;\n    if (unsigned) {\n        if (value < 0)\n            return UZERO;\n        if (value >= TWO_PWR_64_DBL)\n            return MAX_UNSIGNED_VALUE;\n    } else {\n        if (value <= -TWO_PWR_63_DBL)\n            return MIN_VALUE;\n        if (value + 1 >= TWO_PWR_63_DBL)\n            return MAX_VALUE;\n    }\n    if (value < 0)\n        return fromNumber(-value, unsigned).neg();\n    return fromBits((value % TWO_PWR_32_DBL) | 0, (value / TWO_PWR_32_DBL) | 0, unsigned);\n}\n\n/**\n * Returns a Long representing the given value, provided that it is a finite number. Otherwise, zero is returned.\n * @function\n * @param {number} value The number in question\n * @param {boolean=} unsigned Whether unsigned or not, defaults to signed\n * @returns {!Long} The corresponding Long value\n */\nLong.fromNumber = fromNumber;\n\n/**\n * @param {number} lowBits\n * @param {number} highBits\n * @param {boolean=} unsigned\n * @returns {!Long}\n * @inner\n */\nfunction fromBits(lowBits, highBits, unsigned) {\n    return new Long(lowBits, highBits, unsigned);\n}\n\n/**\n * Returns a Long representing the 64 bit integer that comes by concatenating the given low and high bits. Each is\n *  assumed to use 32 bits.\n * @function\n * @param {number} lowBits The low 32 bits\n * @param {number} highBits The high 32 bits\n * @param {boolean=} unsigned Whether unsigned or not, defaults to signed\n * @returns {!Long} The corresponding Long value\n */\nLong.fromBits = fromBits;\n\n/**\n * @function\n * @param {number} base\n * @param {number} exponent\n * @returns {number}\n * @inner\n */\nvar pow_dbl = Math.pow; // Used 4 times (4*8 to 15+4)\n\n/**\n * @param {string} str\n * @param {(boolean|number)=} unsigned\n * @param {number=} radix\n * @returns {!Long}\n * @inner\n */\nfunction fromString(str, unsigned, radix) {\n    if (str.length === 0)\n        throw Error('empty string');\n    if (str === \"NaN\" || str === \"Infinity\" || str === \"+Infinity\" || str === \"-Infinity\")\n        return ZERO;\n    if (typeof unsigned === 'number') {\n        // For goog.math.long compatibility\n        radix = unsigned,\n        unsigned = false;\n    } else {\n        unsigned = !! unsigned;\n    }\n    radix = radix || 10;\n    if (radix < 2 || 36 < radix)\n        throw RangeError('radix');\n\n    var p;\n    if ((p = str.indexOf('-')) > 0)\n        throw Error('interior hyphen');\n    else if (p === 0) {\n        return fromString(str.substring(1), unsigned, radix).neg();\n    }\n\n    // Do several (8) digits each time through the loop, so as to\n    // minimize the calls to the very expensive emulated div.\n    var radixToPower = fromNumber(pow_dbl(radix, 8));\n\n    var result = ZERO;\n    for (var i = 0; i < str.length; i += 8) {\n        var size = Math.min(8, str.length - i),\n            value = parseInt(str.substring(i, i + size), radix);\n        if (size < 8) {\n            var power = fromNumber(pow_dbl(radix, size));\n            result = result.mul(power).add(fromNumber(value));\n        } else {\n            result = result.mul(radixToPower);\n            result = result.add(fromNumber(value));\n        }\n    }\n    result.unsigned = unsigned;\n    return result;\n}\n\n/**\n * Returns a Long representation of the given string, written using the specified radix.\n * @function\n * @param {string} str The textual representation of the Long\n * @param {(boolean|number)=} unsigned Whether unsigned or not, defaults to signed\n * @param {number=} radix The radix in which the text is written (2-36), defaults to 10\n * @returns {!Long} The corresponding Long value\n */\nLong.fromString = fromString;\n\n/**\n * @function\n * @param {!Long|number|string|!{low: number, high: number, unsigned: boolean}} val\n * @param {boolean=} unsigned\n * @returns {!Long}\n * @inner\n */\nfunction fromValue(val, unsigned) {\n    if (typeof val === 'number')\n        return fromNumber(val, unsigned);\n    if (typeof val === 'string')\n        return fromString(val, unsigned);\n    // Throws for non-objects, converts non-instanceof Long:\n    return fromBits(val.low, val.high, typeof unsigned === 'boolean' ? unsigned : val.unsigned);\n}\n\n/**\n * Converts the specified value to a Long using the appropriate from* function for its type.\n * @function\n * @param {!Long|number|string|!{low: number, high: number, unsigned: boolean}} val Value\n * @param {boolean=} unsigned Whether unsigned or not, defaults to signed\n * @returns {!Long}\n */\nLong.fromValue = fromValue;\n\n// NOTE: the compiler should inline these constant values below and then remove these variables, so there should be\n// no runtime penalty for these.\n\n/**\n * @type {number}\n * @const\n * @inner\n */\nvar TWO_PWR_16_DBL = 1 << 16;\n\n/**\n * @type {number}\n * @const\n * @inner\n */\nvar TWO_PWR_24_DBL = 1 << 24;\n\n/**\n * @type {number}\n * @const\n * @inner\n */\nvar TWO_PWR_32_DBL = TWO_PWR_16_DBL * TWO_PWR_16_DBL;\n\n/**\n * @type {number}\n * @const\n * @inner\n */\nvar TWO_PWR_64_DBL = TWO_PWR_32_DBL * TWO_PWR_32_DBL;\n\n/**\n * @type {number}\n * @const\n * @inner\n */\nvar TWO_PWR_63_DBL = TWO_PWR_64_DBL / 2;\n\n/**\n * @type {!Long}\n * @const\n * @inner\n */\nvar TWO_PWR_24 = fromInt(TWO_PWR_24_DBL);\n\n/**\n * @type {!Long}\n * @inner\n */\nvar ZERO = fromInt(0);\n\n/**\n * Signed zero.\n * @type {!Long}\n */\nLong.ZERO = ZERO;\n\n/**\n * @type {!Long}\n * @inner\n */\nvar UZERO = fromInt(0, true);\n\n/**\n * Unsigned zero.\n * @type {!Long}\n */\nLong.UZERO = UZERO;\n\n/**\n * @type {!Long}\n * @inner\n */\nvar ONE = fromInt(1);\n\n/**\n * Signed one.\n * @type {!Long}\n */\nLong.ONE = ONE;\n\n/**\n * @type {!Long}\n * @inner\n */\nvar UONE = fromInt(1, true);\n\n/**\n * Unsigned one.\n * @type {!Long}\n */\nLong.UONE = UONE;\n\n/**\n * @type {!Long}\n * @inner\n */\nvar NEG_ONE = fromInt(-1);\n\n/**\n * Signed negative one.\n * @type {!Long}\n */\nLong.NEG_ONE = NEG_ONE;\n\n/**\n * @type {!Long}\n * @inner\n */\nvar MAX_VALUE = fromBits(0xFFFFFFFF|0, 0x7FFFFFFF|0, false);\n\n/**\n * Maximum signed value.\n * @type {!Long}\n */\nLong.MAX_VALUE = MAX_VALUE;\n\n/**\n * @type {!Long}\n * @inner\n */\nvar MAX_UNSIGNED_VALUE = fromBits(0xFFFFFFFF|0, 0xFFFFFFFF|0, true);\n\n/**\n * Maximum unsigned value.\n * @type {!Long}\n */\nLong.MAX_UNSIGNED_VALUE = MAX_UNSIGNED_VALUE;\n\n/**\n * @type {!Long}\n * @inner\n */\nvar MIN_VALUE = fromBits(0, 0x80000000|0, false);\n\n/**\n * Minimum signed value.\n * @type {!Long}\n */\nLong.MIN_VALUE = MIN_VALUE;\n\n/**\n * @alias Long.prototype\n * @inner\n */\nvar LongPrototype = Long.prototype;\n\n/**\n * Converts the Long to a 32 bit integer, assuming it is a 32 bit integer.\n * @this {!Long}\n * @returns {number}\n */\nLongPrototype.toInt = function toInt() {\n    return this.unsigned ? this.low >>> 0 : this.low;\n};\n\n/**\n * Converts the Long to a the nearest floating-point representation of this value (double, 53 bit mantissa).\n * @this {!Long}\n * @returns {number}\n */\nLongPrototype.toNumber = function toNumber() {\n    if (this.unsigned)\n        return ((this.high >>> 0) * TWO_PWR_32_DBL) + (this.low >>> 0);\n    return this.high * TWO_PWR_32_DBL + (this.low >>> 0);\n};\n\n/**\n * Converts the Long to a string written in the specified radix.\n * @this {!Long}\n * @param {number=} radix Radix (2-36), defaults to 10\n * @returns {string}\n * @override\n * @throws {RangeError} If `radix` is out of range\n */\nLongPrototype.toString = function toString(radix) {\n    radix = radix || 10;\n    if (radix < 2 || 36 < radix)\n        throw RangeError('radix');\n    if (this.isZero())\n        return '0';\n    if (this.isNegative()) { // Unsigned Longs are never negative\n        if (this.eq(MIN_VALUE)) {\n            // We need to change the Long value before it can be negated, so we remove\n            // the bottom-most digit in this base and then recurse to do the rest.\n            var radixLong = fromNumber(radix),\n                div = this.div(radixLong),\n                rem1 = div.mul(radixLong).sub(this);\n            return div.toString(radix) + rem1.toInt().toString(radix);\n        } else\n            return '-' + this.neg().toString(radix);\n    }\n\n    // Do several (6) digits each time through the loop, so as to\n    // minimize the calls to the very expensive emulated div.\n    var radixToPower = fromNumber(pow_dbl(radix, 6), this.unsigned),\n        rem = this;\n    var result = '';\n    while (true) {\n        var remDiv = rem.div(radixToPower),\n            intval = rem.sub(remDiv.mul(radixToPower)).toInt() >>> 0,\n            digits = intval.toString(radix);\n        rem = remDiv;\n        if (rem.isZero())\n            return digits + result;\n        else {\n            while (digits.length < 6)\n                digits = '0' + digits;\n            result = '' + digits + result;\n        }\n    }\n};\n\n/**\n * Gets the high 32 bits as a signed integer.\n * @this {!Long}\n * @returns {number} Signed high bits\n */\nLongPrototype.getHighBits = function getHighBits() {\n    return this.high;\n};\n\n/**\n * Gets the high 32 bits as an unsigned integer.\n * @this {!Long}\n * @returns {number} Unsigned high bits\n */\nLongPrototype.getHighBitsUnsigned = function getHighBitsUnsigned() {\n    return this.high >>> 0;\n};\n\n/**\n * Gets the low 32 bits as a signed integer.\n * @this {!Long}\n * @returns {number} Signed low bits\n */\nLongPrototype.getLowBits = function getLowBits() {\n    return this.low;\n};\n\n/**\n * Gets the low 32 bits as an unsigned integer.\n * @this {!Long}\n * @returns {number} Unsigned low bits\n */\nLongPrototype.getLowBitsUnsigned = function getLowBitsUnsigned() {\n    return this.low >>> 0;\n};\n\n/**\n * Gets the number of bits needed to represent the absolute value of this Long.\n * @this {!Long}\n * @returns {number}\n */\nLongPrototype.getNumBitsAbs = function getNumBitsAbs() {\n    if (this.isNegative()) // Unsigned Longs are never negative\n        return this.eq(MIN_VALUE) ? 64 : this.neg().getNumBitsAbs();\n    var val = this.high != 0 ? this.high : this.low;\n    for (var bit = 31; bit > 0; bit--)\n        if ((val & (1 << bit)) != 0)\n            break;\n    return this.high != 0 ? bit + 33 : bit + 1;\n};\n\n/**\n * Tests if this Long's value equals zero.\n * @this {!Long}\n * @returns {boolean}\n */\nLongPrototype.isZero = function isZero() {\n    return this.high === 0 && this.low === 0;\n};\n\n/**\n * Tests if this Long's value equals zero. This is an alias of {@link Long#isZero}.\n * @returns {boolean}\n */\nLongPrototype.eqz = LongPrototype.isZero;\n\n/**\n * Tests if this Long's value is negative.\n * @this {!Long}\n * @returns {boolean}\n */\nLongPrototype.isNegative = function isNegative() {\n    return !this.unsigned && this.high < 0;\n};\n\n/**\n * Tests if this Long's value is positive.\n * @this {!Long}\n * @returns {boolean}\n */\nLongPrototype.isPositive = function isPositive() {\n    return this.unsigned || this.high >= 0;\n};\n\n/**\n * Tests if this Long's value is odd.\n * @this {!Long}\n * @returns {boolean}\n */\nLongPrototype.isOdd = function isOdd() {\n    return (this.low & 1) === 1;\n};\n\n/**\n * Tests if this Long's value is even.\n * @this {!Long}\n * @returns {boolean}\n */\nLongPrototype.isEven = function isEven() {\n    return (this.low & 1) === 0;\n};\n\n/**\n * Tests if this Long's value equals the specified's.\n * @this {!Long}\n * @param {!Long|number|string} other Other value\n * @returns {boolean}\n */\nLongPrototype.equals = function equals(other) {\n    if (!isLong(other))\n        other = fromValue(other);\n    if (this.unsigned !== other.unsigned && (this.high >>> 31) === 1 && (other.high >>> 31) === 1)\n        return false;\n    return this.high === other.high && this.low === other.low;\n};\n\n/**\n * Tests if this Long's value equals the specified's. This is an alias of {@link Long#equals}.\n * @function\n * @param {!Long|number|string} other Other value\n * @returns {boolean}\n */\nLongPrototype.eq = LongPrototype.equals;\n\n/**\n * Tests if this Long's value differs from the specified's.\n * @this {!Long}\n * @param {!Long|number|string} other Other value\n * @returns {boolean}\n */\nLongPrototype.notEquals = function notEquals(other) {\n    return !this.eq(/* validates */ other);\n};\n\n/**\n * Tests if this Long's value differs from the specified's. This is an alias of {@link Long#notEquals}.\n * @function\n * @param {!Long|number|string} other Other value\n * @returns {boolean}\n */\nLongPrototype.neq = LongPrototype.notEquals;\n\n/**\n * Tests if this Long's value differs from the specified's. This is an alias of {@link Long#notEquals}.\n * @function\n * @param {!Long|number|string} other Other value\n * @returns {boolean}\n */\nLongPrototype.ne = LongPrototype.notEquals;\n\n/**\n * Tests if this Long's value is less than the specified's.\n * @this {!Long}\n * @param {!Long|number|string} other Other value\n * @returns {boolean}\n */\nLongPrototype.lessThan = function lessThan(other) {\n    return this.comp(/* validates */ other) < 0;\n};\n\n/**\n * Tests if this Long's value is less than the specified's. This is an alias of {@link Long#lessThan}.\n * @function\n * @param {!Long|number|string} other Other value\n * @returns {boolean}\n */\nLongPrototype.lt = LongPrototype.lessThan;\n\n/**\n * Tests if this Long's value is less than or equal the specified's.\n * @this {!Long}\n * @param {!Long|number|string} other Other value\n * @returns {boolean}\n */\nLongPrototype.lessThanOrEqual = function lessThanOrEqual(other) {\n    return this.comp(/* validates */ other) <= 0;\n};\n\n/**\n * Tests if this Long's value is less than or equal the specified's. This is an alias of {@link Long#lessThanOrEqual}.\n * @function\n * @param {!Long|number|string} other Other value\n * @returns {boolean}\n */\nLongPrototype.lte = LongPrototype.lessThanOrEqual;\n\n/**\n * Tests if this Long's value is less than or equal the specified's. This is an alias of {@link Long#lessThanOrEqual}.\n * @function\n * @param {!Long|number|string} other Other value\n * @returns {boolean}\n */\nLongPrototype.le = LongPrototype.lessThanOrEqual;\n\n/**\n * Tests if this Long's value is greater than the specified's.\n * @this {!Long}\n * @param {!Long|number|string} other Other value\n * @returns {boolean}\n */\nLongPrototype.greaterThan = function greaterThan(other) {\n    return this.comp(/* validates */ other) > 0;\n};\n\n/**\n * Tests if this Long's value is greater than the specified's. This is an alias of {@link Long#greaterThan}.\n * @function\n * @param {!Long|number|string} other Other value\n * @returns {boolean}\n */\nLongPrototype.gt = LongPrototype.greaterThan;\n\n/**\n * Tests if this Long's value is greater than or equal the specified's.\n * @this {!Long}\n * @param {!Long|number|string} other Other value\n * @returns {boolean}\n */\nLongPrototype.greaterThanOrEqual = function greaterThanOrEqual(other) {\n    return this.comp(/* validates */ other) >= 0;\n};\n\n/**\n * Tests if this Long's value is greater than or equal the specified's. This is an alias of {@link Long#greaterThanOrEqual}.\n * @function\n * @param {!Long|number|string} other Other value\n * @returns {boolean}\n */\nLongPrototype.gte = LongPrototype.greaterThanOrEqual;\n\n/**\n * Tests if this Long's value is greater than or equal the specified's. This is an alias of {@link Long#greaterThanOrEqual}.\n * @function\n * @param {!Long|number|string} other Other value\n * @returns {boolean}\n */\nLongPrototype.ge = LongPrototype.greaterThanOrEqual;\n\n/**\n * Compares this Long's value with the specified's.\n * @this {!Long}\n * @param {!Long|number|string} other Other value\n * @returns {number} 0 if they are the same, 1 if the this is greater and -1\n *  if the given one is greater\n */\nLongPrototype.compare = function compare(other) {\n    if (!isLong(other))\n        other = fromValue(other);\n    if (this.eq(other))\n        return 0;\n    var thisNeg = this.isNegative(),\n        otherNeg = other.isNegative();\n    if (thisNeg && !otherNeg)\n        return -1;\n    if (!thisNeg && otherNeg)\n        return 1;\n    // At this point the sign bits are the same\n    if (!this.unsigned)\n        return this.sub(other).isNegative() ? -1 : 1;\n    // Both are positive if at least one is unsigned\n    return (other.high >>> 0) > (this.high >>> 0) || (other.high === this.high && (other.low >>> 0) > (this.low >>> 0)) ? -1 : 1;\n};\n\n/**\n * Compares this Long's value with the specified's. This is an alias of {@link Long#compare}.\n * @function\n * @param {!Long|number|string} other Other value\n * @returns {number} 0 if they are the same, 1 if the this is greater and -1\n *  if the given one is greater\n */\nLongPrototype.comp = LongPrototype.compare;\n\n/**\n * Negates this Long's value.\n * @this {!Long}\n * @returns {!Long} Negated Long\n */\nLongPrototype.negate = function negate() {\n    if (!this.unsigned && this.eq(MIN_VALUE))\n        return MIN_VALUE;\n    return this.not().add(ONE);\n};\n\n/**\n * Negates this Long's value. This is an alias of {@link Long#negate}.\n * @function\n * @returns {!Long} Negated Long\n */\nLongPrototype.neg = LongPrototype.negate;\n\n/**\n * Returns the sum of this and the specified Long.\n * @this {!Long}\n * @param {!Long|number|string} addend Addend\n * @returns {!Long} Sum\n */\nLongPrototype.add = function add(addend) {\n    if (!isLong(addend))\n        addend = fromValue(addend);\n\n    // Divide each number into 4 chunks of 16 bits, and then sum the chunks.\n\n    var a48 = this.high >>> 16;\n    var a32 = this.high & 0xFFFF;\n    var a16 = this.low >>> 16;\n    var a00 = this.low & 0xFFFF;\n\n    var b48 = addend.high >>> 16;\n    var b32 = addend.high & 0xFFFF;\n    var b16 = addend.low >>> 16;\n    var b00 = addend.low & 0xFFFF;\n\n    var c48 = 0, c32 = 0, c16 = 0, c00 = 0;\n    c00 += a00 + b00;\n    c16 += c00 >>> 16;\n    c00 &= 0xFFFF;\n    c16 += a16 + b16;\n    c32 += c16 >>> 16;\n    c16 &= 0xFFFF;\n    c32 += a32 + b32;\n    c48 += c32 >>> 16;\n    c32 &= 0xFFFF;\n    c48 += a48 + b48;\n    c48 &= 0xFFFF;\n    return fromBits((c16 << 16) | c00, (c48 << 16) | c32, this.unsigned);\n};\n\n/**\n * Returns the difference of this and the specified Long.\n * @this {!Long}\n * @param {!Long|number|string} subtrahend Subtrahend\n * @returns {!Long} Difference\n */\nLongPrototype.subtract = function subtract(subtrahend) {\n    if (!isLong(subtrahend))\n        subtrahend = fromValue(subtrahend);\n    return this.add(subtrahend.neg());\n};\n\n/**\n * Returns the difference of this and the specified Long. This is an alias of {@link Long#subtract}.\n * @function\n * @param {!Long|number|string} subtrahend Subtrahend\n * @returns {!Long} Difference\n */\nLongPrototype.sub = LongPrototype.subtract;\n\n/**\n * Returns the product of this and the specified Long.\n * @this {!Long}\n * @param {!Long|number|string} multiplier Multiplier\n * @returns {!Long} Product\n */\nLongPrototype.multiply = function multiply(multiplier) {\n    if (this.isZero())\n        return ZERO;\n    if (!isLong(multiplier))\n        multiplier = fromValue(multiplier);\n\n    // use wasm support if present\n    if (wasm) {\n        var low = wasm[\"mul\"](this.low,\n                              this.high,\n                              multiplier.low,\n                              multiplier.high);\n        return fromBits(low, wasm[\"get_high\"](), this.unsigned);\n    }\n\n    if (multiplier.isZero())\n        return ZERO;\n    if (this.eq(MIN_VALUE))\n        return multiplier.isOdd() ? MIN_VALUE : ZERO;\n    if (multiplier.eq(MIN_VALUE))\n        return this.isOdd() ? MIN_VALUE : ZERO;\n\n    if (this.isNegative()) {\n        if (multiplier.isNegative())\n            return this.neg().mul(multiplier.neg());\n        else\n            return this.neg().mul(multiplier).neg();\n    } else if (multiplier.isNegative())\n        return this.mul(multiplier.neg()).neg();\n\n    // If both longs are small, use float multiplication\n    if (this.lt(TWO_PWR_24) && multiplier.lt(TWO_PWR_24))\n        return fromNumber(this.toNumber() * multiplier.toNumber(), this.unsigned);\n\n    // Divide each long into 4 chunks of 16 bits, and then add up 4x4 products.\n    // We can skip products that would overflow.\n\n    var a48 = this.high >>> 16;\n    var a32 = this.high & 0xFFFF;\n    var a16 = this.low >>> 16;\n    var a00 = this.low & 0xFFFF;\n\n    var b48 = multiplier.high >>> 16;\n    var b32 = multiplier.high & 0xFFFF;\n    var b16 = multiplier.low >>> 16;\n    var b00 = multiplier.low & 0xFFFF;\n\n    var c48 = 0, c32 = 0, c16 = 0, c00 = 0;\n    c00 += a00 * b00;\n    c16 += c00 >>> 16;\n    c00 &= 0xFFFF;\n    c16 += a16 * b00;\n    c32 += c16 >>> 16;\n    c16 &= 0xFFFF;\n    c16 += a00 * b16;\n    c32 += c16 >>> 16;\n    c16 &= 0xFFFF;\n    c32 += a32 * b00;\n    c48 += c32 >>> 16;\n    c32 &= 0xFFFF;\n    c32 += a16 * b16;\n    c48 += c32 >>> 16;\n    c32 &= 0xFFFF;\n    c32 += a00 * b32;\n    c48 += c32 >>> 16;\n    c32 &= 0xFFFF;\n    c48 += a48 * b00 + a32 * b16 + a16 * b32 + a00 * b48;\n    c48 &= 0xFFFF;\n    return fromBits((c16 << 16) | c00, (c48 << 16) | c32, this.unsigned);\n};\n\n/**\n * Returns the product of this and the specified Long. This is an alias of {@link Long#multiply}.\n * @function\n * @param {!Long|number|string} multiplier Multiplier\n * @returns {!Long} Product\n */\nLongPrototype.mul = LongPrototype.multiply;\n\n/**\n * Returns this Long divided by the specified. The result is signed if this Long is signed or\n *  unsigned if this Long is unsigned.\n * @this {!Long}\n * @param {!Long|number|string} divisor Divisor\n * @returns {!Long} Quotient\n */\nLongPrototype.divide = function divide(divisor) {\n    if (!isLong(divisor))\n        divisor = fromValue(divisor);\n    if (divisor.isZero())\n        throw Error('division by zero');\n\n    // use wasm support if present\n    if (wasm) {\n        // guard against signed division overflow: the largest\n        // negative number / -1 would be 1 larger than the largest\n        // positive number, due to two's complement.\n        if (!this.unsigned &&\n            this.high === -0x80000000 &&\n            divisor.low === -1 && divisor.high === -1) {\n            // be consistent with non-wasm code path\n            return this;\n        }\n        var low = (this.unsigned ? wasm[\"div_u\"] : wasm[\"div_s\"])(\n            this.low,\n            this.high,\n            divisor.low,\n            divisor.high\n        );\n        return fromBits(low, wasm[\"get_high\"](), this.unsigned);\n    }\n\n    if (this.isZero())\n        return this.unsigned ? UZERO : ZERO;\n    var approx, rem, res;\n    if (!this.unsigned) {\n        // This section is only relevant for signed longs and is derived from the\n        // closure library as a whole.\n        if (this.eq(MIN_VALUE)) {\n            if (divisor.eq(ONE) || divisor.eq(NEG_ONE))\n                return MIN_VALUE;  // recall that -MIN_VALUE == MIN_VALUE\n            else if (divisor.eq(MIN_VALUE))\n                return ONE;\n            else {\n                // At this point, we have |other| >= 2, so |this/other| < |MIN_VALUE|.\n                var halfThis = this.shr(1);\n                approx = halfThis.div(divisor).shl(1);\n                if (approx.eq(ZERO)) {\n                    return divisor.isNegative() ? ONE : NEG_ONE;\n                } else {\n                    rem = this.sub(divisor.mul(approx));\n                    res = approx.add(rem.div(divisor));\n                    return res;\n                }\n            }\n        } else if (divisor.eq(MIN_VALUE))\n            return this.unsigned ? UZERO : ZERO;\n        if (this.isNegative()) {\n            if (divisor.isNegative())\n                return this.neg().div(divisor.neg());\n            return this.neg().div(divisor).neg();\n        } else if (divisor.isNegative())\n            return this.div(divisor.neg()).neg();\n        res = ZERO;\n    } else {\n        // The algorithm below has not been made for unsigned longs. It's therefore\n        // required to take special care of the MSB prior to running it.\n        if (!divisor.unsigned)\n            divisor = divisor.toUnsigned();\n        if (divisor.gt(this))\n            return UZERO;\n        if (divisor.gt(this.shru(1))) // 15 >>> 1 = 7 ; with divisor = 8 ; true\n            return UONE;\n        res = UZERO;\n    }\n\n    // Repeat the following until the remainder is less than other:  find a\n    // floating-point that approximates remainder / other *from below*, add this\n    // into the result, and subtract it from the remainder.  It is critical that\n    // the approximate value is less than or equal to the real value so that the\n    // remainder never becomes negative.\n    rem = this;\n    while (rem.gte(divisor)) {\n        // Approximate the result of division. This may be a little greater or\n        // smaller than the actual value.\n        approx = Math.max(1, Math.floor(rem.toNumber() / divisor.toNumber()));\n\n        // We will tweak the approximate result by changing it in the 48-th digit or\n        // the smallest non-fractional digit, whichever is larger.\n        var log2 = Math.ceil(Math.log(approx) / Math.LN2),\n            delta = (log2 <= 48) ? 1 : pow_dbl(2, log2 - 48),\n\n        // Decrease the approximation until it is smaller than the remainder.  Note\n        // that if it is too large, the product overflows and is negative.\n            approxRes = fromNumber(approx),\n            approxRem = approxRes.mul(divisor);\n        while (approxRem.isNegative() || approxRem.gt(rem)) {\n            approx -= delta;\n            approxRes = fromNumber(approx, this.unsigned);\n            approxRem = approxRes.mul(divisor);\n        }\n\n        // We know the answer can't be zero... and actually, zero would cause\n        // infinite recursion since we would make no progress.\n        if (approxRes.isZero())\n            approxRes = ONE;\n\n        res = res.add(approxRes);\n        rem = rem.sub(approxRem);\n    }\n    return res;\n};\n\n/**\n * Returns this Long divided by the specified. This is an alias of {@link Long#divide}.\n * @function\n * @param {!Long|number|string} divisor Divisor\n * @returns {!Long} Quotient\n */\nLongPrototype.div = LongPrototype.divide;\n\n/**\n * Returns this Long modulo the specified.\n * @this {!Long}\n * @param {!Long|number|string} divisor Divisor\n * @returns {!Long} Remainder\n */\nLongPrototype.modulo = function modulo(divisor) {\n    if (!isLong(divisor))\n        divisor = fromValue(divisor);\n\n    // use wasm support if present\n    if (wasm) {\n        var low = (this.unsigned ? wasm[\"rem_u\"] : wasm[\"rem_s\"])(\n            this.low,\n            this.high,\n            divisor.low,\n            divisor.high\n        );\n        return fromBits(low, wasm[\"get_high\"](), this.unsigned);\n    }\n\n    return this.sub(this.div(divisor).mul(divisor));\n};\n\n/**\n * Returns this Long modulo the specified. This is an alias of {@link Long#modulo}.\n * @function\n * @param {!Long|number|string} divisor Divisor\n * @returns {!Long} Remainder\n */\nLongPrototype.mod = LongPrototype.modulo;\n\n/**\n * Returns this Long modulo the specified. This is an alias of {@link Long#modulo}.\n * @function\n * @param {!Long|number|string} divisor Divisor\n * @returns {!Long} Remainder\n */\nLongPrototype.rem = LongPrototype.modulo;\n\n/**\n * Returns the bitwise NOT of this Long.\n * @this {!Long}\n * @returns {!Long}\n */\nLongPrototype.not = function not() {\n    return fromBits(~this.low, ~this.high, this.unsigned);\n};\n\n/**\n * Returns the bitwise AND of this Long and the specified.\n * @this {!Long}\n * @param {!Long|number|string} other Other Long\n * @returns {!Long}\n */\nLongPrototype.and = function and(other) {\n    if (!isLong(other))\n        other = fromValue(other);\n    return fromBits(this.low & other.low, this.high & other.high, this.unsigned);\n};\n\n/**\n * Returns the bitwise OR of this Long and the specified.\n * @this {!Long}\n * @param {!Long|number|string} other Other Long\n * @returns {!Long}\n */\nLongPrototype.or = function or(other) {\n    if (!isLong(other))\n        other = fromValue(other);\n    return fromBits(this.low | other.low, this.high | other.high, this.unsigned);\n};\n\n/**\n * Returns the bitwise XOR of this Long and the given one.\n * @this {!Long}\n * @param {!Long|number|string} other Other Long\n * @returns {!Long}\n */\nLongPrototype.xor = function xor(other) {\n    if (!isLong(other))\n        other = fromValue(other);\n    return fromBits(this.low ^ other.low, this.high ^ other.high, this.unsigned);\n};\n\n/**\n * Returns this Long with bits shifted to the left by the given amount.\n * @this {!Long}\n * @param {number|!Long} numBits Number of bits\n * @returns {!Long} Shifted Long\n */\nLongPrototype.shiftLeft = function shiftLeft(numBits) {\n    if (isLong(numBits))\n        numBits = numBits.toInt();\n    if ((numBits &= 63) === 0)\n        return this;\n    else if (numBits < 32)\n        return fromBits(this.low << numBits, (this.high << numBits) | (this.low >>> (32 - numBits)), this.unsigned);\n    else\n        return fromBits(0, this.low << (numBits - 32), this.unsigned);\n};\n\n/**\n * Returns this Long with bits shifted to the left by the given amount. This is an alias of {@link Long#shiftLeft}.\n * @function\n * @param {number|!Long} numBits Number of bits\n * @returns {!Long} Shifted Long\n */\nLongPrototype.shl = LongPrototype.shiftLeft;\n\n/**\n * Returns this Long with bits arithmetically shifted to the right by the given amount.\n * @this {!Long}\n * @param {number|!Long} numBits Number of bits\n * @returns {!Long} Shifted Long\n */\nLongPrototype.shiftRight = function shiftRight(numBits) {\n    if (isLong(numBits))\n        numBits = numBits.toInt();\n    if ((numBits &= 63) === 0)\n        return this;\n    else if (numBits < 32)\n        return fromBits((this.low >>> numBits) | (this.high << (32 - numBits)), this.high >> numBits, this.unsigned);\n    else\n        return fromBits(this.high >> (numBits - 32), this.high >= 0 ? 0 : -1, this.unsigned);\n};\n\n/**\n * Returns this Long with bits arithmetically shifted to the right by the given amount. This is an alias of {@link Long#shiftRight}.\n * @function\n * @param {number|!Long} numBits Number of bits\n * @returns {!Long} Shifted Long\n */\nLongPrototype.shr = LongPrototype.shiftRight;\n\n/**\n * Returns this Long with bits logically shifted to the right by the given amount.\n * @this {!Long}\n * @param {number|!Long} numBits Number of bits\n * @returns {!Long} Shifted Long\n */\nLongPrototype.shiftRightUnsigned = function shiftRightUnsigned(numBits) {\n    if (isLong(numBits)) numBits = numBits.toInt();\n    if ((numBits &= 63) === 0) return this;\n    if (numBits < 32) return fromBits((this.low >>> numBits) | (this.high << (32 - numBits)), this.high >>> numBits, this.unsigned);\n    if (numBits === 32) return fromBits(this.high, 0, this.unsigned);\n    return fromBits(this.high >>> (numBits - 32), 0, this.unsigned);\n};\n\n/**\n * Returns this Long with bits logically shifted to the right by the given amount. This is an alias of {@link Long#shiftRightUnsigned}.\n * @function\n * @param {number|!Long} numBits Number of bits\n * @returns {!Long} Shifted Long\n */\nLongPrototype.shru = LongPrototype.shiftRightUnsigned;\n\n/**\n * Returns this Long with bits logically shifted to the right by the given amount. This is an alias of {@link Long#shiftRightUnsigned}.\n * @function\n * @param {number|!Long} numBits Number of bits\n * @returns {!Long} Shifted Long\n */\nLongPrototype.shr_u = LongPrototype.shiftRightUnsigned;\n\n/**\n * Returns this Long with bits rotated to the left by the given amount.\n * @this {!Long}\n * @param {number|!Long} numBits Number of bits\n * @returns {!Long} Rotated Long\n */\nLongPrototype.rotateLeft = function rotateLeft(numBits) {\n    var b;\n    if (isLong(numBits)) numBits = numBits.toInt();\n    if ((numBits &= 63) === 0) return this;\n    if (numBits === 32) return fromBits(this.high, this.low, this.unsigned);\n    if (numBits < 32) {\n        b = (32 - numBits);\n        return fromBits(((this.low << numBits) | (this.high >>> b)), ((this.high << numBits) | (this.low >>> b)), this.unsigned);\n    }\n    numBits -= 32;\n    b = (32 - numBits);\n    return fromBits(((this.high << numBits) | (this.low >>> b)), ((this.low << numBits) | (this.high >>> b)), this.unsigned);\n}\n/**\n * Returns this Long with bits rotated to the left by the given amount. This is an alias of {@link Long#rotateLeft}.\n * @function\n * @param {number|!Long} numBits Number of bits\n * @returns {!Long} Rotated Long\n */\nLongPrototype.rotl = LongPrototype.rotateLeft;\n\n/**\n * Returns this Long with bits rotated to the right by the given amount.\n * @this {!Long}\n * @param {number|!Long} numBits Number of bits\n * @returns {!Long} Rotated Long\n */\nLongPrototype.rotateRight = function rotateRight(numBits) {\n    var b;\n    if (isLong(numBits)) numBits = numBits.toInt();\n    if ((numBits &= 63) === 0) return this;\n    if (numBits === 32) return fromBits(this.high, this.low, this.unsigned);\n    if (numBits < 32) {\n        b = (32 - numBits);\n        return fromBits(((this.high << b) | (this.low >>> numBits)), ((this.low << b) | (this.high >>> numBits)), this.unsigned);\n    }\n    numBits -= 32;\n    b = (32 - numBits);\n    return fromBits(((this.low << b) | (this.high >>> numBits)), ((this.high << b) | (this.low >>> numBits)), this.unsigned);\n}\n/**\n * Returns this Long with bits rotated to the right by the given amount. This is an alias of {@link Long#rotateRight}.\n * @function\n * @param {number|!Long} numBits Number of bits\n * @returns {!Long} Rotated Long\n */\nLongPrototype.rotr = LongPrototype.rotateRight;\n\n/**\n * Converts this Long to signed.\n * @this {!Long}\n * @returns {!Long} Signed long\n */\nLongPrototype.toSigned = function toSigned() {\n    if (!this.unsigned)\n        return this;\n    return fromBits(this.low, this.high, false);\n};\n\n/**\n * Converts this Long to unsigned.\n * @this {!Long}\n * @returns {!Long} Unsigned long\n */\nLongPrototype.toUnsigned = function toUnsigned() {\n    if (this.unsigned)\n        return this;\n    return fromBits(this.low, this.high, true);\n};\n\n/**\n * Converts this Long to its byte representation.\n * @param {boolean=} le Whether little or big endian, defaults to big endian\n * @this {!Long}\n * @returns {!Array.<number>} Byte representation\n */\nLongPrototype.toBytes = function toBytes(le) {\n    return le ? this.toBytesLE() : this.toBytesBE();\n};\n\n/**\n * Converts this Long to its little endian byte representation.\n * @this {!Long}\n * @returns {!Array.<number>} Little endian byte representation\n */\nLongPrototype.toBytesLE = function toBytesLE() {\n    var hi = this.high,\n        lo = this.low;\n    return [\n        lo        & 0xff,\n        lo >>>  8 & 0xff,\n        lo >>> 16 & 0xff,\n        lo >>> 24       ,\n        hi        & 0xff,\n        hi >>>  8 & 0xff,\n        hi >>> 16 & 0xff,\n        hi >>> 24\n    ];\n};\n\n/**\n * Converts this Long to its big endian byte representation.\n * @this {!Long}\n * @returns {!Array.<number>} Big endian byte representation\n */\nLongPrototype.toBytesBE = function toBytesBE() {\n    var hi = this.high,\n        lo = this.low;\n    return [\n        hi >>> 24       ,\n        hi >>> 16 & 0xff,\n        hi >>>  8 & 0xff,\n        hi        & 0xff,\n        lo >>> 24       ,\n        lo >>> 16 & 0xff,\n        lo >>>  8 & 0xff,\n        lo        & 0xff\n    ];\n};\n\n/**\n * Creates a Long from its byte representation.\n * @param {!Array.<number>} bytes Byte representation\n * @param {boolean=} unsigned Whether unsigned or not, defaults to signed\n * @param {boolean=} le Whether little or big endian, defaults to big endian\n * @returns {Long} The corresponding Long value\n */\nLong.fromBytes = function fromBytes(bytes, unsigned, le) {\n    return le ? Long.fromBytesLE(bytes, unsigned) : Long.fromBytesBE(bytes, unsigned);\n};\n\n/**\n * Creates a Long from its little endian byte representation.\n * @param {!Array.<number>} bytes Little endian byte representation\n * @param {boolean=} unsigned Whether unsigned or not, defaults to signed\n * @returns {Long} The corresponding Long value\n */\nLong.fromBytesLE = function fromBytesLE(bytes, unsigned) {\n    return new Long(\n        bytes[0]       |\n        bytes[1] <<  8 |\n        bytes[2] << 16 |\n        bytes[3] << 24,\n        bytes[4]       |\n        bytes[5] <<  8 |\n        bytes[6] << 16 |\n        bytes[7] << 24,\n        unsigned\n    );\n};\n\n/**\n * Creates a Long from its big endian byte representation.\n * @param {!Array.<number>} bytes Big endian byte representation\n * @param {boolean=} unsigned Whether unsigned or not, defaults to signed\n * @returns {Long} The corresponding Long value\n */\nLong.fromBytesBE = function fromBytesBE(bytes, unsigned) {\n    return new Long(\n        bytes[4] << 24 |\n        bytes[5] << 16 |\n        bytes[6] <<  8 |\n        bytes[7],\n        bytes[0] << 24 |\n        bytes[1] << 16 |\n        bytes[2] <<  8 |\n        bytes[3],\n        unsigned\n    );\n};\n\n\n//# sourceURL=webpack:///./node_modules/@xtuc/long/src/long.js?")}}]);