(window.webpackJsonp=window.webpackJsonp||[]).push([[84],{"./node_modules/tenko/build/tenko.prod.mjs":function(__webpack_module__,__webpack_exports__,__webpack_require__){"use strict";eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Tenko\", function() { return Tenko; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Lexer\", function() { return Lexer; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"COLLECT_TOKENS_NONE\", function() { return COLLECT_TOKENS_NONE; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"COLLECT_TOKENS_SOLID\", function() { return COLLECT_TOKENS_SOLID; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"COLLECT_TOKENS_ALL\", function() { return COLLECT_TOKENS_ALL; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"COLLECT_TOKENS_TYPES\", function() { return COLLECT_TOKENS_TYPES; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"GOAL_MODULE\", function() { return GOAL_MODULE; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"GOAL_SCRIPT\", function() { return GOAL_SCRIPT; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"WEB_COMPAT_OFF\", function() { return WEB_COMPAT_OFF; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"WEB_COMPAT_ON\", function() { return WEB_COMPAT_ON; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"VERSION_EXPONENTIATION\", function() { return VERSION_EXPONENTIATION; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"VERSION_WHATEVER\", function() { return VERSION_WHATEVER; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"isWhiteToken\", function() { return isWhiteToken; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"isNewlineToken\", function() { return isNewlineToken; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"isCommentToken\", function() { return isCommentToken; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"isIdentToken\", function() { return isIdentToken; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"isNumberToken\", function() { return isNumberToken; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"isBigintToken\", function() { return isBigintToken; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"isStringToken\", function() { return isStringToken; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"isPunctuatorToken\", function() { return isPunctuatorToken; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"isRegexToken\", function() { return isRegexToken; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"isTickToken\", function() { return isTickToken; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"isBadTickToken\", function() { return isBadTickToken; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"isNumberStringToken\", function() { return isNumberStringToken; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"isNumberStringRegex\", function() { return isNumberStringRegex; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"toktypeToString\", function() { return toktypeToString; });\n\n\n\n\n// <perf>\nlet IGNORE = {};\n// </perf>\n\n// <charcodes>\n\n// </charcodes>\n\n// <utils>\nfunction inspect(...args) {\nconsole.dir(((args.length === 1)? args[0] : args), {depth:null});\n}\nfunction THROW(str, ...rest) {\nthrow new Error(`Parser error! ${str} ${(rest.length? rest : '')}`);\n}\n// </utils>\n\n// <tokentype>\nlet __$flag_leaf = 0;\nlet __$flag_group = 7;\nlet ALL_GEES;\nlet KEYWORD_TRIE_OBJLIT = {0:{17:{6:{20:{12:{4:{13:{19:{18:{hit:2072, canon:'arguments'}}}}}}}}, 18:{24:{13:{2:{hit:2074, canon:'async'}}}, hit:2073, canon:'as'}, 22:{0:{8:{19:{hit:2075, canon:'await'}}}}}, 1:{17:{4:{0:{10:{hit:2076, canon:'break'}}}}}, 2:{0:{18:{4:{hit:2077, canon:'case'}}, 19:{2:{7:{hit:2078, canon:'catch'}}}}, 11:{0:{18:{18:{hit:2079, canon:'class'}}}}, 14:{13:{18:{19:{hit:2080, canon:'const'}}, 19:{8:{13:{20:{4:{hit:2081, canon:'continue'}}}}}}}}, 3:{4:{1:{20:{6:{6:{4:{17:{hit:2082, canon:'debugger'}}}}}}, 5:{0:{20:{11:{19:{hit:2083, canon:'default'}}}}}, 11:{4:{19:{4:{hit:2084, canon:'delete'}}}}}, 14:{hit:2085, canon:'do'}}, 4:{11:{18:{4:{hit:2086, canon:'else'}}}, 13:{20:{12:{hit:2087, canon:'enum'}}}, 21:{0:{11:{hit:2088, canon:'eval'}}}, 23:{15:{14:{17:{19:{hit:2089, canon:'export'}}}}, 19:{4:{13:{3:{18:{hit:2090, canon:'extends'}}}}}}}, 5:{0:{11:{18:{4:{hit:2091, canon:'false'}}}}, 8:{13:{0:{11:{11:{24:{hit:2092, canon:'finally'}}}}}}, 14:{17:{hit:2093, canon:'for'}}, 17:{14:{12:{hit:2094, canon:'from'}}}, 20:{13:{2:{19:{8:{14:{13:{hit:2095, canon:'function'}}}}}}}}, 6:{4:{19:{hit:2096, canon:'get'}}}, 8:{5:{hit:2097, canon:'if'}, 12:{15:{11:{4:{12:{4:{13:{19:{18:{hit:2098, canon:'implements'}}}}}}}, 14:{17:{19:{hit:2099, canon:'import'}}}}}, 13:{18:{19:{0:{13:{2:{4:{14:{5:{hit:67637, canon:'instanceof'}}}}}}}}, 19:{4:{17:{5:{0:{2:{4:{hit:2102, canon:'interface'}}}}}}}, hit:67636, canon:'in'}}, 11:{4:{19:{hit:2103, canon:'let'}}}, 13:{4:{22:{hit:2104, canon:'new'}}, 20:{11:{11:{hit:2105, canon:'null'}}}}, 14:{5:{hit:2106, canon:'of'}}, 15:{0:{2:{10:{0:{6:{4:{hit:2107, canon:'package'}}}}}}, 17:{8:{21:{0:{19:{4:{hit:2108, canon:'private'}}}}}, 14:{19:{4:{2:{19:{4:{3:{hit:2109, canon:'protected'}}}}}}}}, 20:{1:{11:{8:{2:{hit:2110, canon:'public'}}}}}}, 17:{4:{19:{20:{17:{13:{hit:2111, canon:'return'}}}}}}, 18:{4:{19:{hit:2112, canon:'set'}}, 19:{0:{19:{8:{2:{hit:2113, canon:'static'}}}}}, 20:{15:{4:{17:{hit:2114, canon:'super'}}}}, 22:{8:{19:{2:{7:{hit:2115, canon:'switch'}}}}}}, 19:{0:{17:{6:{4:{19:{hit:2116, canon:'target'}}}}}, 7:{8:{18:{hit:2117, canon:'this'}}, 17:{14:{22:{hit:2118, canon:'throw'}}}}, 17:{20:{4:{hit:2119, canon:'true'}}, 24:{hit:2120, canon:'try'}}, 24:{15:{4:{14:{5:{hit:2121, canon:'typeof'}}}}}}, 21:{0:{17:{hit:2122, canon:'var'}}, 14:{8:{3:{hit:2123, canon:'void'}}}}, 22:{7:{8:{11:{4:{hit:2124, canon:'while'}}}}, 8:{19:{7:{hit:2125, canon:'with'}}}}, 24:{8:{4:{11:{3:{hit:2126, canon:'yield'}}}}}};\nfunction isWhiteToken(type) {\nreturn (type & 256) === 256;\n}\nfunction isNewlineToken(type) {\nreturn (type & 512) === 512;\n}\nfunction isCommentToken(type) {\nreturn (type & 1024) === 1024;\n}\nfunction isIdentToken(type) {\nreturn (type & 2048) === 2048;\n}\nfunction isNumberToken(type) {\nreturn (type & 4096) === 4096;\n}\nfunction isBigintToken(type) {\nreturn (type & 8192) === 8192;\n}\nfunction isStringToken(type) {\nreturn (type & 131072) === 131072;\n}\nfunction isPunctuatorToken(type) {\nreturn (type & 16384) === 16384;\n}\nfunction isRegexToken(type) {\nreturn (type & 262144) === 262144;\n}\nfunction isTickToken(type) {\nreturn (type & 524288) === 524288;\n}\nfunction isBadTickToken(type) {\nreturn (type & 1048576) === 1048576;\n}\nfunction isNumberStringToken(type) {\nreturn (type & 135168) !== 0;\n}\nfunction isNumberStringRegex(type) {\nreturn (type & 397312) !== 0;\n}\nfunction toktypeToString(type, token, ignoreUnknown) {\nswitch ((((typeof type) === 'object')? type.type : type)) {\ncase 0:\nreturn 'UNTYPED';\ncase 257:\nreturn 'SPACE';\ncase 258:\nreturn 'TAB';\ncase 771:\nreturn 'NL_SOLO';\ncase 772:\nreturn 'NL_CRLF';\ncase 1285:\nreturn 'COMMENT_SINGLE';\ncase 1286:\nreturn 'COMMENT_MULTI';\ncase 1287:\nreturn 'COMMENT_HTML';\ncase 2048:\nreturn 'IDENT';\ncase 2072:\nreturn 'ID_arguments';\ncase 2073:\nreturn 'ID_as';\ncase 2074:\nreturn 'ID_async';\ncase 2075:\nreturn 'ID_await';\ncase 2076:\nreturn 'ID_break';\ncase 2077:\nreturn 'ID_case';\ncase 2078:\nreturn 'ID_catch';\ncase 2079:\nreturn 'ID_class';\ncase 2080:\nreturn 'ID_const';\ncase 2081:\nreturn 'ID_continue';\ncase 2082:\nreturn 'ID_debugger';\ncase 2083:\nreturn 'ID_default';\ncase 2084:\nreturn 'ID_delete';\ncase 2085:\nreturn 'ID_do';\ncase 2086:\nreturn 'ID_else';\ncase 2087:\nreturn 'ID_enum';\ncase 2088:\nreturn 'ID_eval';\ncase 2089:\nreturn 'ID_export';\ncase 2090:\nreturn 'ID_extends';\ncase 2091:\nreturn 'ID_false';\ncase 2092:\nreturn 'ID_finally';\ncase 2093:\nreturn 'ID_for';\ncase 2094:\nreturn 'ID_from';\ncase 2095:\nreturn 'ID_function';\ncase 2096:\nreturn 'ID_get';\ncase 2097:\nreturn 'ID_if';\ncase 2098:\nreturn 'ID_implements';\ncase 2099:\nreturn 'ID_import';\ncase 67636:\nreturn 'ID_in';\ncase 67637:\nreturn 'ID_instanceof';\ncase 2102:\nreturn 'ID_interface';\ncase 2103:\nreturn 'ID_let';\ncase 2104:\nreturn 'ID_new';\ncase 2105:\nreturn 'ID_null';\ncase 2106:\nreturn 'ID_of';\ncase 2107:\nreturn 'ID_package';\ncase 2108:\nreturn 'ID_private';\ncase 2109:\nreturn 'ID_protected';\ncase 2110:\nreturn 'ID_public';\ncase 2111:\nreturn 'ID_return';\ncase 2112:\nreturn 'ID_set';\ncase 2113:\nreturn 'ID_static';\ncase 2114:\nreturn 'ID_super';\ncase 2115:\nreturn 'ID_switch';\ncase 2116:\nreturn 'ID_target';\ncase 2117:\nreturn 'ID_this';\ncase 2118:\nreturn 'ID_throw';\ncase 2119:\nreturn 'ID_true';\ncase 2120:\nreturn 'ID_try';\ncase 2121:\nreturn 'ID_typeof';\ncase 2122:\nreturn 'ID_var';\ncase 2123:\nreturn 'ID_void';\ncase 2124:\nreturn 'ID_while';\ncase 2125:\nreturn 'ID_with';\ncase 2126:\nreturn 'ID_yield';\ncase 4104:\nreturn 'NUMBER_HEX';\ncase 4105:\nreturn 'NUMBER_DEC';\ncase 4106:\nreturn 'NUMBER_BIN';\ncase 4107:\nreturn 'NUMBER_OCT';\ncase 4108:\nreturn 'NUMBER_OLD';\ncase 12296:\nreturn 'NUMBER_BIG_HEX';\ncase 12297:\nreturn 'NUMBER_BIG_DEC';\ncase 12298:\nreturn 'NUMBER_BIG_BIN';\ncase 12299:\nreturn 'NUMBER_BIG_OCT';\ncase 16463:\nreturn 'PUNC_EXCL';\ncase 82000:\nreturn 'PUNC_EXCL_EQ';\ncase 82001:\nreturn 'PUNC_EXCL_EQ_EQ';\ncase 82002:\nreturn 'PUNC_PERCENT';\ncase 49235:\nreturn 'PUNC_PERCENT_EQ';\ncase 82004:\nreturn 'PUNC_AND';\ncase 82005:\nreturn 'PUNC_AND_AND';\ncase 49238:\nreturn 'PUNC_AND_EQ';\ncase 16471:\nreturn 'PUNC_PAREN_OPEN';\ncase 16472:\nreturn 'PUNC_PAREN_CLOSE';\ncase 82009:\nreturn 'PUNC_STAR';\ncase 82010:\nreturn 'PUNC_STAR_STAR';\ncase 49243:\nreturn 'PUNC_STAR_EQ';\ncase 49244:\nreturn 'PUNC_STAR_STAR_EQ';\ncase 82013:\nreturn 'PUNC_PLUS';\ncase 16478:\nreturn 'PUNC_PLUS_PLUS';\ncase 49247:\nreturn 'PUNC_PLUS_EQ';\ncase 16480:\nreturn 'PUNC_COMMA';\ncase 82017:\nreturn 'PUNC_MIN';\ncase 16482:\nreturn 'PUNC_MIN_MIN';\ncase 49251:\nreturn 'PUNC_MIN_EQ';\ncase 16484:\nreturn 'PUNC_MIN_MIN_GT';\ncase 16485:\nreturn 'PUNC_DOT';\ncase 16486:\nreturn 'PUNC_DOT_DOT_DOT';\ncase 82023:\nreturn 'PUNC_DIV';\ncase 49256:\nreturn 'PUNC_DIV_EQ';\ncase 16489:\nreturn 'PUNC_COLON';\ncase 16490:\nreturn 'PUNC_SEMI';\ncase 82027:\nreturn 'PUNC_LT';\ncase 82028:\nreturn 'PUNC_LT_LT';\ncase 82029:\nreturn 'PUNC_LT_EQ';\ncase 49262:\nreturn 'PUNC_LT_LT_EQ';\ncase 16495:\nreturn 'PUNC_LT_EXCL_MIN_MIN';\ncase 49264:\nreturn 'PUNC_EQ';\ncase 82033:\nreturn 'PUNC_EQ_EQ';\ncase 82034:\nreturn 'PUNC_EQ_EQ_EQ';\ncase 16499:\nreturn 'PUNC_EQ_GT';\ncase 82036:\nreturn 'PUNC_GT';\ncase 82037:\nreturn 'PUNC_GT_GT';\ncase 82038:\nreturn 'PUNC_GT_GT_GT';\ncase 82039:\nreturn 'PUNC_GT_EQ';\ncase 49272:\nreturn 'PUNC_GT_GT_EQ';\ncase 49273:\nreturn 'PUNC_GT_GT_GT_EQ';\ncase 16506:\nreturn 'PUNC_QMARK';\ncase 82043:\nreturn 'QMARK_DOT';\ncase 82044:\nreturn 'QMARK_QMARK';\ncase 16509:\nreturn 'PUNC_BRACKET_OPEN';\ncase 16510:\nreturn 'PUNC_BRACKET_CLOSE';\ncase 82047:\nreturn 'PUNC_CARET';\ncase 49280:\nreturn 'PUNC_CARET_EQ';\ncase 16513:\nreturn 'PUNC_CURLY_OPEN';\ncase 82050:\nreturn 'PUNC_OR';\ncase 82051:\nreturn 'PUNC_OR_OR';\ncase 49284:\nreturn 'PUNC_OR_EQ';\ncase 16517:\nreturn 'PUNC_CURLY_CLOSE';\ncase 16518:\nreturn 'PUNC_TILDE';\ncase 262157:\nreturn 'REGEXN';\ncase 262158:\nreturn 'REGEXU';\ncase 131087:\nreturn 'STRING_SINGLE';\ncase 131088:\nreturn 'STRING_DOUBLE';\ncase 524305:\nreturn 'TICK_HEAD';\ncase 524306:\nreturn 'TICK_BODY';\ncase 524307:\nreturn 'TICK_TAIL';\ncase 524308:\nreturn 'TICK_PURE';\ncase 1572881:\nreturn 'TICK_BAD_HEAD';\ncase 1572882:\nreturn 'TICK_BAD_BODY';\ncase 1572883:\nreturn 'TICK_BAD_TAIL';\ncase 1572884:\nreturn 'TICK_BAD_PURE';\ncase 2097173:\nreturn 'EOF';\ncase 2097174:\nreturn 'ASI';\ncase 2097175:\nreturn 'ERROR';\n}\nif (ignoreUnknown) return ('UNKNOWN[' + ((((typeof type) === 'object')? type.type : type))) + ']';\nthrow new Error(('toktypeToString: UNKNOWN[' + JSON.stringify(type)) + ']');\n}\nlet MAX_START_VALUE = 26;\nlet __$flag_start = 0;\nlet tokenStartJumpTable = [26, 26, 26, 26, 26, 26, 26, 26, 26, 1, 4, 1, 1, 5, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 1, 16, 6, 26, 2, 17, 18, 6, 16471, 16472, 19, 12, 16480, 13, 8, 11, 14, 7, 7, 7, 7, 7, 7, 7, 7, 7, 16489, 16490, 21, 10, 22, 25, 26, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 16509, 24, 16510, 20, 2, 15, 3, 3, 3, 3, 3, 3, 3, 2, 3, 2, 2, 3, 2, 3, 3, 3, 2, 3, 3, 3, 2, 3, 3, 2, 3, 2, 16513, 23, 9, 16518];\nlet stringScanTable = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];\nlet identScanTable = [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 2, 1, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1];\nlet regexAtomEscapeStartJumpTable = [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 10, 1, 1, 10, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 0, 0, 0, 0, 1, 1, 0, 0, 7, 8, 8, 8, 8, 8, 8, 8, 8, 8, 1, 1, 1, 1, 1, 0, 1, 11, 11, 11, 0, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 6, 11, 11, 0, 11, 11, 11, 0, 11, 11, 11, 0, 0, 0, 0, 11, 1, 11, 11, 5, 0, 11, 0, 11, 11, 11, 11, 9, 11, 11, 0, 11, 6, 11, 0, 0, 0, 2, 0, 0, 3, 11, 11, 0, 0, 0, 1];\nlet regexClassEscapeStartJumpTable = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 20, 0, 0, 20, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 18, 0, 0, 0, 18, 18, 18, 18, 0, 19, 18, 18, 15, 16, 16, 16, 16, 16, 16, 16, 17, 17, 0, 0, 0, 0, 0, 18, 0, 0, 7, 0, 13, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 14, 0, 0, 13, 0, 0, 0, 13, 0, 0, 0, 18, 18, 18, 18, 0, 0, 0, 6, 4, 13, 0, 8, 0, 0, 0, 0, 5, 0, 0, 9, 0, 14, 0, 10, 13, 11, 2, 12, 13, 3, 0, 0, 18, 18, 18, 0];\nlet hexValueJumpTable = [16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 16, 16, 16, 16, 16, 16, 16, 10, 11, 12, 13, 14, 15, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 10, 11, 12, 13, 14, 15];\nlet regexAtomJumpTable = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 15, 0, 0, 15, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 10, 0, 0, 0, 3, 4, 2, 2, 0, 0, 1, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 7, 6, 9, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 12, 14, 13, 0];\nlet stringEscapeStartJumpTable = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 10, 0, 0, 9, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 11, 12, 12, 12, 12, 12, 12, 12, 12, 12, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 13, 0, 0, 0, 14, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 8, 0, 7, 4, 15, 0, 5, 0, 0, 0, 0, 0, 0];\nfunction getTokenStart(c) {\nlet s = tokenStartJumpTable[c];\nreturn s;\n}\nfunction getStringPart(c) {\nif (c > 0x7e) return 3;\nlet s = stringScanTable[c];\nreturn s;\n}\nfunction getIdentPart(c) {\nif (c > 0x7e) return 3;\nlet s = identScanTable[c];\nreturn s;\n}\nfunction getHexValue(c) {\nif (c > 0x66) return 16;\nlet v = hexValueJumpTable[c];\nreturn v;\n}\nfunction T(type) {\nreturn ('T<' + toktypeToString(type)) + '>';\n}\n// </tokentype>\n\n// <lexerflags>\nlet __$flag_lf = 0;\nfunction L(flags) {\nlet bak = flags;\nlet s = [];\nif (!flags) {\ns.push('LF_NO_FLAGS');\n}\nif (flags & 8192) {\nflags ^= 8192;\ns.push('LF_STRICT_MODE');\n}\nif (flags & 4) {\nflags ^= 4;\ns.push('LF_FOR_REGEX');\n}\nif (flags & 2048) {\nflags ^= 2048;\ns.push('LF_IN_TEMPLATE');\n}\nif (flags & 8) {\nflags ^= 8;\ns.push('LF_IN_ASYNC');\n}\nif (flags & 128) {\nflags ^= 128;\ns.push('LF_IN_GENERATOR');\n}\nif (flags & 16) {\nflags ^= 16;\ns.push('LF_IN_CONSTRUCTOR');\n}\nif (flags & 64) {\nflags ^= 64;\ns.push('LF_IN_FUNC_ARGS');\n}\nif (flags & 256) {\nflags ^= 256;\ns.push('LF_IN_GLOBAL');\n}\nif (flags & 512) {\nflags ^= 512;\ns.push('LF_IN_ITERATION');\n}\nif (flags & 1024) {\nflags ^= 1024;\ns.push('LF_IN_SWITCH');\n}\nif (flags & 2) {\nflags ^= 2;\ns.push('LF_CAN_NEW_DOT_TARGET');\n}\nif (flags & 32) {\nflags ^= 32;\ns.push('LF_IN_FOR_LHS');\n}\nif (flags & 4096) {\nflags ^= 4096;\ns.push('LF_NO_ASI');\n}\nif (flags & 16384) {\nflags ^= 16384;\ns.push('LF_SUPER_CALL');\n}\nif (flags & 32768) {\nflags ^= 32768;\ns.push('LF_SUPER_PROP');\n}\nif (flags & 65536) {\nflags ^= 65536;\ns.push('LF_NOT_KEYWORD');\n}\nif (flags) {\nthrow new Error(((((('UNKNOWN_FLAGS: ' + flags.toString(2)) + ' (was: ') + bak.toString(2)) + '), so far: [') + s.join('|')) + ']');\n}\nreturn 'L:' + s.join('|');\n}\n// </lexerflags>\n\n// <enum_lexer>\nconst GOAL_MODULE = true;\nconst GOAL_SCRIPT = false;\nconst COLLECT_TOKENS_NONE = 0;\nconst COLLECT_TOKENS_SOLID = 1;\nconst COLLECT_TOKENS_ALL = 2;\nconst COLLECT_TOKENS_TYPES = 3;\nconst WEB_COMPAT_OFF = false;\nconst WEB_COMPAT_ON = true;\n// </enum_lexer>\n\n// <enum_parser>\nconst VERSION_EXPONENTIATION = 7;\nconst VERSION_WHATEVER = Infinity;\nfunction DEVONLY() {\nlet dev = false;\nreturn dev;\n}\nfunction copyPiggies(output, input) {\nreturn output | (input & 1984);\n}\nfunction P(f, arr) {\nif (f & 256) {\narr.push('PIGGY_BACK_WAS_CONSTRUCTOR');\nf ^= 256;\n}\nif (f & 512) {\narr.push('PIGGY_BACK_WAS_PROTO');\nf ^= 512;\n}\nif (f & 64) {\narr.push('PIGGY_BACK_SAW_AWAIT');\nf ^= 64;\n}\nif (f & 128) {\narr.push('PIGGY_BACK_SAW_YIELD');\nf ^= 128;\n}\nif (f & 1024) {\narr.push('PIGGY_BACK_WAS_ARROW');\nf ^= 1024;\n}\nreturn f;\n}\n// </enum_parser>\n\n// <lexer>\nconst TABLE_NONBIN_UNI_PROPS = ',General_Category,gc,Script,sc,Script_Extensions,scx,';\nconst TABLE_BIN_UNI_PROPS = ',ASCII,ASCII_Hex_Digit,AHex,Alphabetic,Alpha,Any,Assigned,Bidi_Control,Bidi_C,Bidi_Mirrored,Bidi_M,Case_Ignorable,CI,Cased,Changes_When_Casefolded,CWCF,Changes_When_Casemapped,CWCM,Changes_When_Lowercased,CWL,Changes_When_NFKC_Casefolded,CWKCF,Changes_When_Titlecased,CWT,Changes_When_Uppercased,CWU,Dash,Default_Ignorable_Code_Point,DI,Deprecated,Dep,Diacritic,Dia,Emoji,Emoji_Component,Emoji_Modifier,Emoji_Modifier_Base,Emoji_Presentation,Extended_Pictographic,Extender,Ext,Grapheme_Base,Gr_Base,Grapheme_Extend,Gr_Ext,Hex_Digit,Hex,IDS_Binary_Operator,IDSB,IDS_Trinary_Operator,IDST,ID_Continue,IDC,ID_Start,IDS,Ideographic,Ideo,Join_Control,Join_C,Logical_Order_Exception,LOE,Lowercase,Lower,Math,Noncharacter_Code_Point,NChar,Pattern_Syntax,Pat_Syn,Pattern_White_Space,Pat_WS,Quotation_Mark,QMark,Radical,Regional_Indicator,RI,Sentence_Terminal,STerm,Soft_Dotted,SD,Terminal_Punctuation,Term,Unified_Ideograph,UIdeo,Uppercase,Upper,Variation_Selector,VS,White_Space,space,XID_Continue,XIDC,XID_Start,XIDS,';\nconst TABLE_GEN_CAT_VALUES = ',Cased_Letter,LC,Close_Punctuation,Pe,Connector_Punctuation,Pc,Control,Cc,cntrl,Currency_Symbol,Sc,Dash_Punctuation,Pd,Decimal_Number,Nd,digit,Enclosing_Mark,Me,Final_Punctuation,Pf,Format,Cf,Initial_Punctuation,Pi,Letter,L,Letter_Number,Nl,Line_Separator,Zl,Lowercase_Letter,Ll,Mark,M,Combining_Mark,Math_Symbol,Sm,Modifier_Letter,Lm,Modifier_Symbol,Sk,Nonspacing_Mark,Mn,Number,N,Open_Punctuation,Ps,Other,C,Other_Letter,Lo,Other_Number,No,Other_Punctuation,Po,Other_Symbol,So,Paragraph_Separator,Zp,Private_Use,Co,Punctuation,P,punct,Separator,Z,Space_Separator,Zs,Spacing_Mark,Mc,Surrogate,Cs,Symbol,S,Titlecase_Letter,Lt,Unassigned,Cn,Uppercase_Letter,Lu,';\nconst TABLE_SCRIPT_VALUES = ',Adlam,Adlm,Ahom,Anatolian_Hieroglyphs,Hluw,Arabic,Arab,Armenian,Armn,Avestan,Avst,Balinese,Bali,Bamum,Bamu,Bassa_Vah,Bass,Batak,Batk,Bengali,Beng,Bhaiksuki,Bhks,Bopomofo,Bopo,Brahmi,Brah,Braille,Brai,Buginese,Bugi,Buhid,Buhd,Canadian_Aboriginal,Cans,Carian,Cari,Caucasian_Albanian,Aghb,Chakma,Cakm,Cham,Cherokee,Cher,Common,Zyyy,Coptic,Copt,Qaac,Cuneiform,Xsux,Cypriot,Cprt,Cyrillic,Cyrl,Deseret,Dsrt,Devanagari,Deva,Dogra,Dogr,Duployan,Dupl,Egyptian_Hieroglyphs,Egyp,Elbasan,Elba,Elymaic,Elym,Ethiopic,Ethi,Georgian,Geor,Glagolitic,Glag,Gothic,Goth,Grantha,Gran,Greek,Grek,Gujarati,Gujr,Gunjala_Gondi,Gong,Gurmukhi,Guru,Han,Hani,Hangul,Hang,Hanifi_Rohingya,Rohg,Hanunoo,Hano,Hatran,Hatr,Hebrew,Hebr,Hiragana,Hira,Imperial_Aramaic,Armi,Inherited,Zinh,Qaai,Inscriptional_Pahlavi,Phli,Inscriptional_Parthian,Prti,Javanese,Java,Kaithi,Kthi,Kannada,Knda,Katakana,Kana,Kayah_Li,Kali,Kharoshthi,Khar,Khmer,Khmr,Khojki,Khoj,Khudawadi,Sind,Lao,Laoo,Latin,Latn,Lepcha,Lepc,Limbu,Limb,Linear_A,Lina,Linear_B,Linb,Lisu,Lycian,Lyci,Lydian,Lydi,Mahajani,Mahj,Makasar,Maka,Malayalam,Mlym,Mandaic,Mand,Manichaean,Mani,Marchen,Marc,Medefaidrin,Medf,Masaram_Gondi,Gonm,Meetei_Mayek,Mtei,Mende_Kikakui,Mend,Meroitic_Cursive,Merc,Meroitic_Hieroglyphs,Mero,Miao,Plrd,Modi,Mongolian,Mong,Mro,Mroo,Multani,Mult,Myanmar,Mymr,Nabataean,Nbat,Nandinagari,Nand,New_Tai_Lue,Talu,Newa,Nko,Nkoo,Nushu,Nshu,Nyiakeng_Puachue_Hmong,Hmnp,Ogham,Ogam,Ol_Chiki,Olck,Old_Hungarian,Hung,Old_Italic,Ital,Old_North_Arabian,Narb,Old_Permic,Perm,Old_Persian,Xpeo,Old_Sogdian,Sogo,Old_South_Arabian,Sarb,Old_Turkic,Orkh,Oriya,Orya,Osage,Osge,Osmanya,Osma,Pahawh_Hmong,Hmng,Palmyrene,Palm,Pau_Cin_Hau,Pauc,Phags_Pa,Phag,Phoenician,Phnx,Psalter_Pahlavi,Phlp,Rejang,Rjng,Runic,Runr,Samaritan,Samr,Saurashtra,Saur,Sharada,Shrd,Shavian,Shaw,Siddham,Sidd,SignWriting,Sgnw,Sinhala,Sinh,Sogdian,Sogd,Sora_Sompeng,Sora,Soyombo,Soyo,Sundanese,Sund,Syloti_Nagri,Sylo,Syriac,Syrc,Tagalog,Tglg,Tagbanwa,Tagb,Tai_Le,Tale,Tai_Tham,Lana,Tai_Viet,Tavt,Takri,Takr,Tamil,Taml,Tangut,Tang,Telugu,Telu,Thaana,Thaa,Thai,Tibetan,Tibt,Tifinagh,Tfng,Tirhuta,Tirh,Ugaritic,Ugar,Vai,Vaii,Wancho,Wcho,Warang_Citi,Wara,Yi,Yiii,Zanabazar_Square,Zanb,';\nlet ID_START_REGEX = undefined;\nfunction getIdStartRegexSuperSlow() {\nif (ID_START_REGEX) return ID_START_REGEX;\nreturn ID_START_REGEX = createUnicodeRegex('^\\\\p{ID_Start}$');\n}\nlet ID_CONTINUE_REGEX = undefined;\nfunction getIdRestRegexSuperSlow() {\nif (ID_CONTINUE_REGEX) return ID_CONTINUE_REGEX;\nreturn ID_CONTINUE_REGEX = createUnicodeRegex('^\\\\p{ID_Continue}$');\n}\nfunction createUnicodeRegex(pattern) {\ntry {\nreturn new RegExp(pattern, 'u');\n} catch (e) {\nconsole.warn(('Tenko: Current nodejs version does not suppport unicode regexes or regex property escapes; Input contains unicode that requires it so Tenko is unable to properly parse input (' + e.message) + ')');\nreturn /|/;\n}\n}\nfunction Lexer(input, options) {\nconst {targetEsVersion = Infinity, parsingGoal = true, collectTokens = 0, returnTokens = 3, webCompat = true, gracefulErrors = false, tokenStorageExternal, babelTokenCompat = false, errorCodeFrame = true, truncCodeFrame = false, $log = console.log, $warn = console.warn, $error = console.error} = options;\nconst tokenStorage = (tokenStorageExternal || (((collectTokens !== 0)? [] : undefined)));\nconst supportRegexPropertyEscapes = ((targetEsVersion >= 9) || (targetEsVersion === Infinity));\nconst supportRegexLookbehinds = ((targetEsVersion >= 9) || (targetEsVersion === Infinity));\nconst supportRegexDotallFlag = ((targetEsVersion >= 9) || (targetEsVersion === Infinity));\nconst supportRegexNamedGroups = ((targetEsVersion >= 9) || (targetEsVersion === Infinity));\nconst supportBigInt = ((targetEsVersion === 11) || (targetEsVersion === Infinity));\nconst supportNullishCoalescing = ((targetEsVersion === 11) || (targetEsVersion === Infinity));\nconst supportOptionalChaining = ((targetEsVersion === 11) || (targetEsVersion === Infinity));\nlet pointer = 0;\nlet len = input.length;\nlet consumedNewlinesBeforeSolid = false;\nlet nlwas = false;\nlet finished = false;\nlet lastOffset = pointer;\nlet startForError = 0;\nlet lastType = 0;\nlet lastStart = 0;\nlet lastStop = 0;\nlet lastLine = 0;\nlet lastColumn = 0;\nlet lastCanonizedInput = '';\nlet lastCanonizedInputLen = 0;\nlet lastPotentialRegexError = '';\nlet lastReportableLexerError = '';\nlet currentLine = 1;\nlet currentColOffset = 0;\nlet prevTokenEndColumn = 0;\nlet prevTokenEndLine = 0;\nlet prevTokenEndPointer = 0;\nlet prevTokenSolid = true;\nlet stale = false;\nlet cache = input.charCodeAt(0);\nlet anyTokenCount = 0;\nlet solidTokenCount = 0;\nfunction peek() {\nreturn cache;\n}\nfunction _readCache() {\nreturn cache;\n}\nfunction peekd(delta) {\nreturn input.charCodeAt(pointer + delta);\n}\nfunction peeky(ord) {\nreturn cache === ord;\n}\nfunction slice(from, to) {\nreturn input.slice(from, to);\n}\nfunction skipPeek() {\nreturn cache = input.charCodeAt(++pointer);\n}\nfunction skip() {\nlet p = ++pointer;\nif (pointer >= len) {\ncache = 0;\nreturn;\n}\ncache = input.charCodeAt(p);\n}\nfunction skipFastWithoutUpdatingCache() {\n++pointer;\n}\nfunction eof() {\nreturn pointer >= len;\n}\nfunction eofd(d) {\nreturn pointer >= (len - d);\n}\nfunction neof() {\nreturn pointer < len;\n}\nfunction neofd(d) {\nreturn pointer <= (len - d);\n}\nfunction nextToken(lexerFlags) {\nif (prevTokenSolid) {\nprevTokenEndColumn = pointer - currentColOffset;\nprevTokenEndLine = currentLine;\nprevTokenEndPointer = pointer;\nprevTokenSolid = false;\n}\nlastPotentialRegexError = '';\nlastReportableLexerError = '';\ndo {\n++anyTokenCount;\nlet startCol = pointer - currentColOffset;\nlet startRow = currentLine;\nlastCanonizedInput = '';\nlastCanonizedInputLen = 0;\nnlwas = consumedNewlinesBeforeSolid;\nif (pointer >= len) {\ncreateToken(2097173, pointer, pointer, startCol, startRow);\nfinished = true;\nreturn returnSolidToken(2097173, pointer, pointer, startCol, startRow);\n}\nlet start = startForError = pointer;\nlet consumedTokenType = jumpTableLexer(lexerFlags);\nif (!isWhiteToken(consumedTokenType)) {\ncreateToken(consumedTokenType, start, pointer, startCol, startRow);\nreturn returnSolidToken(consumedTokenType, start, pointer, startCol, startRow);\n}\nif (isCommentToken(consumedTokenType)) {\nif (returnTokens === 2) {\ncreateToken(consumedTokenType, start, pointer, startCol, startRow);\nreturn returnCommentToken(consumedTokenType, start, pointer, startCol, startRow);\n}\n}\nif (((collectTokens === 2) || (collectTokens === 3))) {\ncreateToken(consumedTokenType, start, pointer, startCol, startRow);\ntokenStorage.push(((collectTokens === 3)? consumedTokenType : createBaseToken(consumedTokenType, start, pointer, startCol, startRow, false)));\n}\nif (returnTokens === 1) {\nreturn createToken(consumedTokenType, start, pointer, startCol, startRow);\n}\nif (consumedTokenType === 1285) {\nif (((collectTokens !== 2) && (collectTokens !== 3))) skipNewlinesWithoutTokens();\n}\nif (nlwas === true) {\nif (((collectTokens !== 2) && (collectTokens !== 3))) skipSpacesWithoutTokens();\n}\n} while (true);\n}\nfunction returnCommentToken(consumedTokenType, start, pointer, startCol, startRow) {\nif (((collectTokens === 2) || (collectTokens === 3))) {\ntokenStorage.push(((collectTokens === 3)? consumedTokenType : createBaseToken(consumedTokenType, start, pointer, startCol, startRow, false)));\n}\n}\nfunction returnSolidToken(consumedTokenType, start, pointer, startCol, startRow) {\n++solidTokenCount;\nif (collectTokens !== 0) {\ntokenStorage.push(((collectTokens === 3)? consumedTokenType : createBaseToken(consumedTokenType, start, pointer, startCol, startRow, consumedNewlinesBeforeSolid)));\n}\nconsumedNewlinesBeforeSolid = false;\nprevTokenSolid = true;\n}\nfunction skipSpacesWithoutTokens() {\nwhile (pointer < len) {\nlet c = cache;\nif (((c !== 0x20) && (c !== 0x09))) return;\nskip();\n}\n}\nfunction skipNewlinesWithoutTokens() {\nwhile (pointer < len) {\nlet c = cache;\nif (c === 0x0A) {\nskip();\nincrementLine();\n} else if (c === 0x0D) {\nskip();\nparseCR();\n} else {\nreturn;\n}\n}\n}\nfunction jumpTableLexer(lexerFlags) {\nlet c = cache;\nskip();\nif (c > 0x7e) {\nreturn parseOtherUnicode(c);\n}\nlet s = getTokenStart(c);\nif (s > MAX_START_VALUE) {\nreturn s;\n}\nswitch (s) {\ncase 1:\nreturn parseSpace();\ncase 2:\nreturn parseIdentifierRest(String.fromCharCode(c), 1);\ncase 3:\nif ((lexerFlags & 65536) === 65536) return parseIdentifierRest(String.fromCharCode(c), 1);\nreturn parsePotentialKeywordTrieMap(c);\ncase 4:\nreturn parseNewlineSolo();\ncase 5:\nreturn parseCR();\ncase 6:\nreturn parseAnyString(c, lexerFlags);\ncase 7:\nreturn parseDecimal();\ncase 8:\nreturn parseLeadingDot();\ncase 9:\nif ((lexerFlags & 2048) === 2048) return parseTemplateString(lexerFlags, false);\nreturn 16517;\ncase 10:\nreturn parseEqual();\ncase 11:\nreturn parseFwdSlash(lexerFlags);\ncase 12:\nreturn parseSameOrCompound(0x2b);\ncase 13:\nreturn parseDash();\ncase 14:\nreturn parseLeadingZero(lexerFlags);\ncase 15:\nreturn parseTemplateString(lexerFlags, true);\ncase 16:\nreturn parseExcl();\ncase 17:\nreturn parseCompoundAssignment(0x25);\ncase 18:\nreturn parseSameOrCompound(0x26);\ncase 19:\nreturn parseStar();\ncase 20:\nreturn parseCompoundAssignment(0x5e);\ncase 21:\nreturn parseLt();\ncase 22:\nreturn parseGtPunctuator();\ncase 23:\nreturn parseSameOrCompound(0x7c);\ncase 24:\nreturn parseBackslash();\ncase 25:\nreturn parseQmark();\n}\nTHROW('Unknown input', pointer - 1, pointer);\n}\nfunction incrementLine() {\nconsumedNewlinesBeforeSolid = true;\n++currentLine;\ncurrentColOffset = pointer;\n}\nfunction addAsi() {\nif (collectTokens !== 0) {\ntokenStorage.push(((collectTokens === 3)? 2097174 : createBaseToken(2097174, pointer, pointer, pointer - currentColOffset, currentLine, false)), tokenStorage.pop());\n}\n++anyTokenCount;\n++solidTokenCount;\nprevTokenSolid = true;\n}\nfunction createToken(type, start, stop, column, line) {\nlastType = type;\nlastStart = start;\nlastStop = stop;\nlastLine = line;\nlastColumn = column;\n}\nfunction createBaseToken(type, start, stop, column, line, nl) {\nif (babelTokenCompat) {\nreturn {type, start, stop, loc:{start:{line:line, column:column}, end:{line:currentLine, column:currentColOffset}}, column, line};\n}\nreturn {type, start, stop, column, line, nl};\n}\nfunction parseLeadingDot() {\nif (pointer >= len) return 16485;\nlet c = cache;\nif (c === 0x2e) {\nreturn parseTripleDot();\n}\nif (isAsciiNumber(c)) {\nreturn parseNumberFromDot(c);\n}\nreturn 16485;\n}\nfunction parseTripleDot() {\nif (peekd(1) === 0x2e) {\nskip();\nskip();\nreturn 16486;\n}\nreturn 16486;\n}\nfunction parseNumberFromDot(c) {\nskip();\nif (pointer < len) {\nlet d = skipDigits();\nparseExponentMaybe(d);\n}\nverifyCharAfterNumber();\nreturn 4105;\n}\nfunction parseSpace() {\nreturn 257;\n}\nfunction parseCR() {\nif ((pointer < len && (cache === 0x0A))) {\nskip();\nincrementLine();\nreturn 772;\n}\nincrementLine();\nreturn 771;\n}\nfunction parseAnyString(marker, lexerFlags) {\nlet pointerOffset = pointer;\nlet badEscape = false;\nlet hadNewline = false;\nwhile (pointer < len) {\nlet c = cache;\nlet s = getStringPart(c);\nif (s <= MAX_START_VALUE) {\nswitch (s) {\ncase 0:\nskip();\nbreak;\ncase 1:\nskip();\nif (c === marker) {\nif (badEscape) {\nif (!lastReportableLexerError) lastReportableLexerError = 'String had an illegal escape';\nreturn 2097175;\n}\nif (hadNewline) {\nif (!lastReportableLexerError) lastReportableLexerError = 'Encountered newline in string which is not allowed';\nreturn 2097175;\n}\nlastCanonizedInput += slice(pointerOffset, pointer - 1);\nlastCanonizedInputLen += (pointer - 1) - pointerOffset;\nreturn ((marker === 0x22)? 131088 : 131087);\n}\nbreak;\ncase 2:\nlastCanonizedInput += slice(pointerOffset, pointer);\nlastCanonizedInputLen += pointer - pointerOffset;\nbadEscape = ((parseStringOrTemplateEscape(lexerFlags, false) === true) || badEscape);\npointerOffset = pointer;\nbreak;\ncase 3:\nskip();\nif (((c <= 0x2029) && (c >= 0x2028))) {\nincrementLine();\n}\nbreak;\ncase 4:\nskip();\nhadNewline = true;\nbreak;\n;\n}\n}\n}\nif (!lastReportableLexerError) lastReportableLexerError = 'Unclosed string at EOF';\nreturn 2097175;\n}\nfunction parseStringOrTemplateEscape(lexerFlags, forTemplate) {\nskip();\nif (pointer >= len) {\nif (!lastReportableLexerError) lastReportableLexerError = 'Backslash at end of input';\nreturn true;\n}\nlet c = cache;\nskip();\nlet s = ((c > 0x7e)? 6 : stringEscapeStartJumpTable[c]);\nswitch (s) {\ncase 0:\nlastCanonizedInput += String.fromCharCode(c);\n++lastCanonizedInputLen;\nreturn false;\ncase 1:\nlastCanonizedInput += '\\n';\n++lastCanonizedInputLen;\nreturn false;\ncase 2:\nlastCanonizedInput += '\\'';\n++lastCanonizedInputLen;\nreturn false;\ncase 3:\nlastCanonizedInput += '\"';\n++lastCanonizedInputLen;\nreturn false;\ncase 4:\n{\nif (pointer >= len) return true;\nlet r = parseUnicodeEscapeForNonRegex();\nif (r === 0x110000) return true;\nlastCanonizedInput += ((r > 0xffff)? String.fromCodePoint(r) : String.fromCharCode(r));\nlastCanonizedInputLen += ((r > 0xffff)? 2 : 1);\nreturn false;\n}\ncase 5:\nreturn parseStringEscapeHex();\ncase 6:\nif (((c === 0x2028) || (c === 0x2029))) {\nincrementLine();\nreturn false;\n}\nlastCanonizedInput += String.fromCharCode(c);\n++lastCanonizedInputLen;\nreturn false;\ncase 7:\nlastCanonizedInput += '\\t';\n++lastCanonizedInputLen;\nreturn false;\ncase 8:\nlastCanonizedInput += '\\r';\n++lastCanonizedInputLen;\nreturn false;\ncase 9:\nif ((pointer < len && (cache === 0x0A))) skip();\nincrementLine();\nreturn false;\ncase 10:\nincrementLine();\nreturn false;\ncase 11:\n\ncase 12:\nreturn parseStringEscapeOctalOrDigit(c, forTemplate, lexerFlags);\ncase 13:\nlastCanonizedInput += '\\b';\n++lastCanonizedInputLen;\nreturn false;\ncase 14:\nlastCanonizedInput += '\\f';\n++lastCanonizedInputLen;\nreturn false;\ncase 15:\nlastCanonizedInput += '\\v';\n++lastCanonizedInputLen;\nreturn false;\n;\n}\n}\nfunction skipZeroes() {\nlet c = cache;\nwhile (c === 0x30) {\nskip();\nif (pointer >= len) return 0;\nc = cache;\n}\nreturn c;\n}\nfunction parseStringEscapeHex() {\nif (eofd(1)) {\nif (pointer >= len) return false;\nif (!lastReportableLexerError) lastReportableLexerError = 'Not enough of input left to create valid hex escape';\nreturn true;\n}\nlet a = cache;\nlet b = peekd(1);\nlet va = getHexValue(a);\nlet vb = getHexValue(b);\nif ((va | vb) >= 16) {\nlastCanonizedInput += 'x';\n++lastCanonizedInputLen;\nif (!lastReportableLexerError) lastReportableLexerError = 'At least one of the two hex characters were not hex character (0-9a-f)';\nreturn true;\n}\nskip();\nskip();\nlastCanonizedInput += String.fromCharCode((va << 4) | vb);\n++lastCanonizedInputLen;\nreturn false;\n}\nfunction parseStringEscapeOctalOrDigit(a, forTemplate, lexerFlags) {\nif (((a === 0x38) || (a === 0x39))) {\nif (!lastReportableLexerError) lastReportableLexerError = 'The grammar does not allow to escape the 8 or the 9 character';\nreturn true;\n}\nif (pointer >= len) return false;\nlet b = cache;\nif (((((webCompat === false) || forTemplate)) || ((lexerFlags & 8192) === 8192))) {\nif (((a === 0x30) && (((b < 0x30) || (b > 0x39))))) {\nlastCanonizedInput += '\\0';\n++lastCanonizedInputLen;\nreturn false;\n}\nif (forTemplate) {\nif (!lastReportableLexerError) lastReportableLexerError = 'Illegal legacy octal escape in template, where octal escapes are never allowed';\n} else if ((lexerFlags & 8192) === 8192) {\nif (!lastReportableLexerError) lastReportableLexerError = 'Illegal legacy octal escape in strict mode';\n} else {\nif (!lastReportableLexerError) lastReportableLexerError = 'Octal escapes are only allowed in sloppy mode with web compat enabled';\n}\nreturn true;\n}\nif (((a === 0x30) && (((b < 0x30) || (b > 0x37))))) {\nlastCanonizedInput += '\\0';\n++lastCanonizedInputLen;\nreturn false;\n}\nif (((b < 0x30) || (b > 0x37))) {\nlastCanonizedInput += String.fromCharCode(parseInt(String.fromCharCode(a), 8));\n++lastCanonizedInputLen;\nreturn false;\n}\nskip();\nif (pointer >= len) return false;\nif (a > 0x33) {\nlastCanonizedInput += String.fromCharCode(parseInt(String.fromCharCode(a, b), 8));\n++lastCanonizedInputLen;\nreturn false;\n}\nlet c = cache;\nif (((c < 0x30) || (c > 0x37))) {\nlastCanonizedInput += String.fromCharCode(parseInt(String.fromCharCode(a, b), 8));\n++lastCanonizedInputLen;\nreturn false;\n}\nskip();\nlastCanonizedInput += String.fromCharCode(parseInt(String.fromCharCode(a, b, c), 8));\n++lastCanonizedInputLen;\nreturn false;\n}\nfunction parseDash() {\nif (((((((((parsingGoal === false) && (webCompat === true))) && (!eofd(1)))) && (cache === 0x2d))) && (peekd(1) === 0x3e))) {\nif (consumedNewlinesBeforeSolid === true) {\nreturn parseCommentHtmlClose();\n} else {\n\n}\n}\nreturn parseSameOrCompound(0x2d);\n}\nfunction parseSameOrCompound(c) {\nif (pointer < len) {\nlet d = cache;\nif (d === c) {\nskip();\nswitch (c) {\ncase 0x2b:\nreturn 16478;\ncase 0x2d:\nreturn 16482;\ncase 0x26:\nreturn 82005;\ncase 0x7c:\nreturn 82051;\n;\n}\n}\nif (d === 0x3d) {\nskip();\nswitch (c) {\ncase 0x2b:\nreturn 49247;\ncase 0x2d:\nreturn 49251;\ncase 0x26:\nreturn 49238;\ncase 0x7c:\nreturn 49284;\n;\n}\n}\n}\nswitch (c) {\ncase 0x2b:\nreturn 82013;\ncase 0x2d:\nreturn 82017;\ncase 0x26:\nreturn 82004;\ncase 0x7c:\nreturn 82050;\n;\n}\n}\nfunction parseTemplateString(lexerFlags, fromTick) {\nlastOffset = pointer;\nlet badEscapes = false;\nwhile (pointer < len) {\nlet c = cache;\nwhile (c === 0x24) {\nskip();\nif (pointer >= len) {\nif (!lastReportableLexerError) lastReportableLexerError = 'Unclosed template string';\nlastCanonizedInput += slice(lastOffset, pointer);\nlastCanonizedInputLen += pointer - lastOffset;\nreturn 2097175;\n}\nc = cache;\nif (c === 0x7b) {\nlastCanonizedInput += slice(lastOffset, pointer - 1);\nlastCanonizedInputLen += (pointer - 1) - lastOffset;\nskip();\nreturn (badEscapes? ((fromTick? 1572881 : 1572882)) : ((fromTick? 524305 : 524306)));\n}\n}\nif (c === 0x60) {\nlastCanonizedInput += slice(lastOffset, pointer);\nlastCanonizedInputLen += pointer - lastOffset;\nskip();\nreturn (badEscapes? ((fromTick? 1572884 : 1572883)) : ((fromTick? 524308 : 524307)));\n}\nif (c === 0x0D) {\nskip();\nif ((pointer < len && (cache === 0x0A))) {\nskip();\n}\nincrementLine();\n} else if (isLfPsLs(c)) {\nskip();\nincrementLine();\n} else if (c === 0x5c) {\nlastCanonizedInput += slice(lastOffset, pointer);\nlastCanonizedInputLen += pointer - lastOffset;\nbadEscapes = ((parseStringOrTemplateEscape(lexerFlags, true) === true) || badEscapes);\nlastOffset = pointer;\n} else {\nskip();\n}\n}\nlastCanonizedInput += slice(lastOffset, pointer);\nlastCanonizedInputLen += pointer - lastOffset;\nif (!lastReportableLexerError) lastReportableLexerError = 'Unclosed template literal';\nreturn 2097175;\n}\nfunction verifyCharAfterNumber() {\nif (pointer >= len) return;\nlet c = cache;\nif (((isIdentStart(c, 0) !== (-1)) || (((c >= 0x30) && (c <= 0x39))))) {\nreturn THROW(('Found `' + String.fromCharCode(c)) + '`. It is not legal for an ident or number token to start after a number token without some form of separation', pointer, pointer);\n}\n}\nfunction parseLeadingZero(lexerFlags) {\nlet r = _parseLeadingZero(lexerFlags);\nif (r !== 2097175) verifyCharAfterNumber();\nreturn r;\n}\nfunction _parseLeadingZero(lexerFlags) {\nif (pointer >= len) return 4105;\nlet c = cache;\nif (isAsciiNumber(c)) {\nskip();\nif (pointer < len) skipDigits();\nif ((lexerFlags & 8192) === 8192) {\nif (!lastReportableLexerError) lastReportableLexerError = '\"Illegal\" octal escape in strict mode';\nreturn 2097175;\n}\nif (pointer < len) {\nlet e = cache;\nif (((e === 0x45) || (e === 0x65))) {\nif (!lastReportableLexerError) lastReportableLexerError = 'An exponent is not allowed after a legacy octal number and an ident after number must be separated by some whitespace so this is an error';\nreturn 2097175;\n}\nif (e === 0x6E) {\nif (!supportBigInt) {\nreturn THROW('BigInt suffix is not supported on legacy octals; use the `0o` prefix notation for that', startForError, pointer + 1);\n}\n}\n}\nreturn 4108;\n}\nif (c === 0x2e) {\nparseFromFractionDot();\nreturn 4105;\n}\nif (((c === 0x78) || (c === 0x58))) {\nskip();\nreturn parseHex();\n}\nif (((c === 0x6F) || (c === 0x4F))) {\nskip();\nreturn parseOctal();\n}\nif (((c === 0x62) || (c === 0x42))) {\nskip();\nreturn parseBinary();\n}\nif (((c === 0x65) || (c === 0x45))) {\nparseExponentMaybe(c);\nreturn 4105;\n}\nif (c === 0x6E) {\nif (!supportBigInt) {\nreturn THROW(('The BigInt syntax is supported in ES11+ / ES2020 (currently parsing ES' + targetEsVersion) + ')', startForError, pointer + 1);\n}\nskip();\nreturn 12297;\n}\nreturn 4105;\n}\nfunction parseDecimal() {\nif (pointer >= len) {\nreturn 4105;\n}\nlet c = skipDigits();\nif (pointer >= len) {\nreturn 4105;\n}\nif (c === 0x2e) {\nparseFromFractionDot();\nverifyCharAfterNumber();\nreturn 4105;\n}\nif (c === 0x6E) {\nif (!supportBigInt) {\nreturn THROW(('The BigInt syntax is supported in ES11+ / ES2020 (currently parsing ES' + targetEsVersion) + ')', startForError, pointer);\n}\nskip();\nverifyCharAfterNumber();\nreturn 12297;\n}\nparseExponentMaybe(c);\nverifyCharAfterNumber();\nreturn 4105;\n}\nfunction skipDigits() {\nlet c = cache;\nwhile (isAsciiNumber(c)) {\nskip();\nif (pointer >= len) return 0;\nc = cache;\n}\nreturn c;\n}\nfunction parseExponentMaybe(c) {\nif (((c !== 0x65) && (c !== 0x45))) return;\nif (eofd(1)) return;\nlet d = peekd(1);\nif (((d === 0x2d) || (d === 0x2b))) {\nif (eofd(2)) return;\nlet e = peekd(2);\nif (!isAsciiNumber(e)) return;\nskipFastWithoutUpdatingCache();\nskipFastWithoutUpdatingCache();\nskip();\nif (pointer >= len) return;\nskipDigits();\nreturn;\n}\nif (!isAsciiNumber(d)) return;\nskipFastWithoutUpdatingCache();\nskip();\nif (pointer >= len) return;\nskipDigits();\n}\nfunction parseFromFractionDot() {\nskip();\nif (pointer >= len) return;\nlet c = skipDigits();\nparseExponentMaybe(c);\n}\nfunction parseHex() {\nif (pointer >= len) {\nif (!lastReportableLexerError) lastReportableLexerError = '`0x` is illegal without a digit';\nreturn 2097175;\n}\nlet c = cache;\nlet cv = getHexValue(c);\nif (cv === 16) {\nif (!lastReportableLexerError) lastReportableLexerError = '`0x` is illegal without a digit';\nreturn 2097175;\n}\nskip();\ndo {\nif (pointer >= len) return 4104;\nc = cache;\ncv = getHexValue(c);\nif (cv === 16) {\nbreak;\n}\nskip();\n} while (true);\nif (c === 0x6E) {\nif (!supportBigInt) {\nreturn THROW(('The BigInt syntax is supported in ES11+ / ES2020 (currently parsing ES' + targetEsVersion) + ')', startForError, pointer + 1);\n}\nskip();\nreturn 12296;\n}\nreturn 4104;\n}\nfunction parseOctal() {\nif (pointer >= len) {\nif (!lastReportableLexerError) lastReportableLexerError = '`0o` is illegal without a digit';\nreturn 2097175;\n}\nlet c = cache;\nif (!isOctal(c)) {\nif (!lastReportableLexerError) lastReportableLexerError = '`0o` is illegal without a digit';\nreturn 2097175;\n}\nskip();\ndo {\nif (pointer >= len) return 4107;\nc = cache;\nif (!isOctal(c)) break;\nskip();\n} while (true);\nif (c === 0x6E) {\nif (!supportBigInt) {\nreturn THROW(('The BigInt syntax is supported in ES11+ / ES2020 (currently parsing ES' + targetEsVersion) + ')', startForError, pointer + 1);\n}\nskip();\nreturn 12299;\n}\nreturn 4107;\n}\nfunction parseBinary() {\nif (pointer >= len) {\nif (!lastReportableLexerError) lastReportableLexerError = '`0b` is illegal without a digit';\nreturn 2097175;\n}\nlet c = cache;\nif (!isBinary(c)) {\nif (!lastReportableLexerError) lastReportableLexerError = '`0b` is illegal without a digit';\nreturn 2097175;\n}\nskip();\ndo {\nif (pointer >= len) return 4106;\nc = cache;\nif (!isBinary(c)) break;\nskip();\n} while (true);\nif (c === 0x6E) {\nif (!supportBigInt) {\nreturn THROW(('The BigInt syntax is supported in ES11+ / ES2020 (currently parsing ES' + targetEsVersion) + ')', startForError, pointer + 1);\n}\nskip();\nreturn 12297;\n}\nreturn 4106;\n}\nfunction isBinary(ord) {\nreturn ((ord === 0x30) || (ord === 0x31));\n}\nfunction parseExcl() {\nif (pointer >= len) return 16463;\nif ((cache === 0x3d)) {\nskip();\nif ((pointer < len && (cache === 0x3d))) {\nskip();\nreturn 82001;\n}\nreturn 82000;\n}\nreturn 16463;\n}\nfunction parseStar() {\nif (pointer < len) {\nlet c = cache;\nif (c === 0x2a) {\nskip();\nif ((pointer < len && (cache === 0x3d))) {\nskip();\nreturn 49244;\n}\nreturn 82010;\n} else if (c === 0x3d) {\nskip();\nreturn 49243;\n}\n}\nreturn 82009;\n}\nfunction parseIdentRestNotKeywordObjTrie(d, n, start) {\npointer = n - 1;\ncache = d;\nreturn parseIdentifierRest(slice(start, n - 1), (n - 1) - start);\n}\nfunction parsePotentialKeywordTrieMap(c) {\nlet trieObjlit = KEYWORD_TRIE_OBJLIT[c - 0x61];\nlet start = pointer - 1;\nlet n = start + 1;\ndo {\nif (n >= len) return eofAfterPotentialKeywordTrieMap(trieObjlit, n, start);\nlet d = input.charCodeAt(n++);\nif (((d < 0x61) || (d > 0x7a))) {\nreturn endOfPotentialKeywordTrieMap(trieObjlit, d, n, start);\n}\ntrieObjlit = trieObjlit[d - 0x61];\nif (trieObjlit === undefined) return parseIdentRestNotKeywordObjTrie(d, n, start);\n} while (true);\n}\nfunction endOfPotentialKeywordTrieMap(trieObjlit, d, n, start) {\nlet hit = trieObjlit.hit;\nif (d > 0x7e) {\npointer = n - 1;\ncache = d;\nlet wide = isIdentRestChr(d, n - 1);\nif (wide === (-1)) {\nlastCanonizedInputLen = (n - 1) - start;\nif (hit === undefined) {\nlastCanonizedInput = slice(start, n - 1);\nreturn 2048;\n}\nlet canon = trieObjlit.canon;\nlastCanonizedInput = canon;\nreturn hit;\n}\nreturn parseIdentifierRest(slice(start, n - 1), (n - 1) - start);\n}\nlet s = getTokenStart(d);\nif (((((s === 2) || (s === 7))) || (s === 14))) {\npointer = n - 1;\ncache = d;\nreturn parseIdentifierRest(slice(start, n - 1), (n - 1) - start);\n}\nif (s === 24) {\npointer = n - 1;\ncache = d;\nreturn parseIdentifierRest(slice(start, n - 1), (n - 1) - start);\n}\nif (hit !== undefined) {\npointer = n - 1;\ncache = d;\nlastCanonizedInputLen = (n - 1) - start;\nlet canon = trieObjlit.canon;\nlastCanonizedInput = canon;\nreturn hit;\n}\nlastCanonizedInput = slice(start, n - 1);\nlastCanonizedInputLen = (n - 1) - start;\npointer = n - 1;\ncache = d;\nreturn 2048;\n}\nfunction eofAfterPotentialKeywordTrieMap(trieObjlit, n, start) {\npointer = n - 1;\nskip();\nlastCanonizedInputLen = n - start;\nlet hit = trieObjlit.hit;\nif (hit !== undefined) {\nlet canon = trieObjlit.canon;\nlastCanonizedInput = canon;\nreturn hit;\n}\nlastCanonizedInput = slice(start, n);\nreturn 2048;\n}\nfunction parseIdentifierRest(prevStr, prevLen) {\nlet start = pointer;\nwhile (pointer < len) {\nlet c = cache;\nlet s = getIdentPart(c);\nswitch (s) {\ncase 0:\nskip();\nbreak;\ncase 1:\nlastCanonizedInput = prevStr + slice(start, pointer);\nlastCanonizedInputLen = prevLen + (pointer - start);\nreturn 2048;\ncase 2:\nlet x = prevStr + slice(start, pointer);\nlet xlen = prevLen + (pointer - start);\nskip();\nreturn parseIdentFromUnicodeEscape(false, x, xlen);\ncase 3:\nlet wide = isIdentRestChrUnicode(c, pointer);\nif (wide === (-1)) {\nlastCanonizedInput = prevStr + slice(start, pointer);\nlastCanonizedInputLen = prevLen + (pointer - start);\nreturn 2048;\n}\nif (wide === (-3)) {\nskipFastWithoutUpdatingCache();\n}\nskip();\nbreak;\n;\n}\n}\nlastCanonizedInput = prevStr + slice(start, pointer);\nlastCanonizedInputLen = prevLen + (pointer - start);\nreturn 2048;\n}\nfunction parseIdentFromUnicodeEscape(fromStart, prevStr, prevLen) {\nif (pointer >= len) {\nlastCanonizedInput = prevStr;\nlastCanonizedInputLen = prevLen;\nif (!lastReportableLexerError) lastReportableLexerError = 'Encountered a backslash at end of input';\nreturn 2097175;\n}\nif (!(cache === 0x75)) {\nreturn THROW('Only unicode escapes are supported in identifier escapes', startForError, pointer + 1);\n}\nskip();\nif (pointer >= len) {\nif (!lastReportableLexerError) lastReportableLexerError = 'Reached end of input before closing the current ident escape';\nreturn 2097175;\n}\nlet r = parseUnicodeEscapeForNonRegex();\nif (r === 0x110000) {\nparseIdentifierRest(prevStr, prevLen);\nlastCanonizedInput = prevStr;\nlastCanonizedInputLen = prevLen;\nif (!lastReportableLexerError) lastReportableLexerError = 'Only _unicode_ escapes are supported in identifiers';\nreturn 2097175;\n}\nif (r > 0xffff) {\nprevStr += String.fromCodePoint(r);\nprevLen += 2;\n} else {\nprevStr += String.fromCharCode(r);\n++prevLen;\n}\nif (((fromStart === true) && (isIdentStart(r, -1) !== (-1)))) {\nreturn parseIdentifierRest(prevStr, prevLen);\n}\nif (((fromStart === false) && (isIdentRestChr(r, -1) !== (-1)))) {\nreturn parseIdentifierRest(prevStr, prevLen);\n}\nlastCanonizedInput = prevStr;\nlastCanonizedInputLen = prevLen;\nif (!lastReportableLexerError) lastReportableLexerError = 'Identifier escape did not yield a valid identifier character';\nreturn 2097175;\n}\nfunction toStringExpensive(c) {\nreturn String.fromCodePoint(c);\n}\nfunction isIdentStart(c, offsetOfC) {\nif (c > 0x7e) {\nreturn veryExpensiveUnicodeCheck(c, offsetOfC, getIdStartRegexSuperSlow());\n}\nlet s = getTokenStart(c);\nif (((s === 2) || (s === 3))) return -2;\nreturn -1;\n}\nfunction isIdentRestChr(c, offsetOfC) {\nif (c > 0x7e) {\nreturn isIdentRestChrUnicode(c, offsetOfC);\n}\nlet s = getTokenStart(c);\nif (((s === 2) || (s === 3))) return -2;\nif (s === 7) return -2;\nif (s === 14) return -2;\nreturn -1;\n}\nfunction isIdentRestChrUnicode(c, offsetOfC) {\nif (((c === 0x200C) || (c === 0x200D))) return -2;\nreturn veryExpensiveUnicodeCheck(c, offsetOfC, getIdRestRegexSuperSlow());\n}\nfunction veryExpensiveUnicodeCheck(c, offset, regexScanner) {\nif (offset !== (-1)) {\nc = input.codePointAt(offset);\n}\nlet s = String.fromCodePoint(c);\nif (regexScanner.test(s)) {\nreturn ((s.length === 1)? (-2) : (-3));\n}\nreturn -1;\n}\nfunction isAsciiLetter(c) {\nlet d = c | 32;\nreturn ((d >= 0x61) && (d <= 0x7a));\n}\nfunction isAsciiNumber(c) {\nreturn ((c >= 0x30) && (c <= 0x39));\n}\nfunction parseCompoundAssignment(c) {\nif ((pointer < len && (cache === 0x3d))) {\nskip();\nif (c === 0x5e) return 49280;\nreturn 49235;\n}\nif (c === 0x5e) return 82047;\nreturn 82002;\n}\nfunction parseFwdSlash(lexerFlags) {\nif (pointer >= len) return 82023;\nlet c = cache;\nif (c === 0x2f) {\nskip();\nreturn parseCommentSingle();\n}\nif (c === 0x2a) {\nreturn parseCommentMulti();\n}\nif ((lexerFlags & 4) === 4) {\nreturn parseRegex(c);\n}\nif (c === 0x3d) {\nskip();\nreturn 49256;\n}\nreturn 82023;\n}\nfunction parseCommentSingle() {\nwhile (pointer < len) {\nlet c = cache;\nif (((c === 0x0D) || isLfPsLs(c))) {\nreturn 1285;\n}\nskip();\n}\nreturn 1285;\n}\nfunction parseCommentMulti() {\nskip();\nlet c = 0;\nwhile (pointer < len) {\nc = cache;\nskip();\nwhile (c === 0x2a) {\nif (pointer >= len) break;\nc = cache;\nskip();\nif (c === 0x2f) {\nreturn 1286;\n}\n}\nif (c === 0x0D) {\nif ((pointer < len && (cache === 0x0A))) skip();\nincrementLine();\n} else if (isLfPsLs(c)) {\nincrementLine();\n}\n}\nif (!lastReportableLexerError) lastReportableLexerError = 'Unclosed multi line comment, early eof';\nreturn 2097175;\n}\nfunction parseCommentHtmlOpen() {\nparseCommentSingle();\nreturn 1287;\n}\nfunction parseCommentHtmlClose() {\nparseCommentSingle();\nreturn 1287;\n}\nfunction parseEqual() {\nif (pointer < len) {\nlet c = cache;\nif (c === 0x3d) {\nskip();\nif ((pointer < len && (cache === 0x3d))) {\nskip();\nreturn 82034;\n}\nreturn 82033;\n} else if (c === 0x3e) {\nskip();\nreturn 16499;\n}\n}\nreturn 49264;\n}\nfunction parseLt() {\nif (((((((((((parsingGoal === false) && (webCompat === true))) && (!eofd(3)))) && (cache === 0x21))) && (peekd(1) === 0x2d))) && (peekd(2) === 0x2d))) {\nreturn parseCommentHtmlOpen();\n}\nreturn parseLtPunctuator();\n}\nfunction parseLtPunctuator() {\nif (pointer < len) {\nlet c = cache;\nif (c === 0x3d) {\nskip();\nreturn 82029;\n}\nif (c === 0x3c) {\nskip();\nif ((pointer < len && (cache === 0x3d))) {\nskip();\nreturn 49262;\n}\nreturn 82028;\n}\n}\nreturn 82027;\n}\nfunction parseGtPunctuator() {\nif (pointer < len) {\nlet c = cache;\nif (c === 0x3d) {\nskip();\nreturn 82039;\n}\nif (c === 0x3e) {\nskip();\nif (pointer < len) {\nc = cache;\nif (c === 0x3d) {\nskip();\nreturn 49272;\n}\nif (c === 0x3e) {\nskip();\nif ((pointer < len && (cache === 0x3d))) {\nskip();\nreturn 49273;\n}\nreturn 82038;\n}\n}\nreturn 82037;\n}\n}\nreturn 82036;\n}\nfunction parseNewlineSolo() {\nincrementLine();\nreturn 771;\n}\nfunction parseBackslash() {\nreturn parseIdentFromUnicodeEscape(true, '', 0);\n}\nfunction parseQmark() {\nif (pointer >= len) return 16506;\nif ((cache === 0x3f)) {\nskip();\nif (supportNullishCoalescing) {\nreturn 82044;\n}\nreturn THROW('The nullish coalescing operator (`??`) is only supported since ES2020, currently targeting a lower version', pointer - 2, pointer);\n}\nif ((cache === 0x2e)) {\nif (neofd(1)) {\nlet c = peekd(1);\nif (((c >= 0x30) && (c <= 0x39))) {\nreturn 16506;\n}\n}\nskip();\nif (supportOptionalChaining) {\nreturn 82043;\n}\nreturn THROW('The optional chaining operator (`?.`) is only supported since ES2020, currently targeting a lower version', pointer, pointer + 2);\n}\nreturn 16506;\n}\nfunction regexSyntaxError(desc, ...rest) {\nif (lastReportableLexerError) {\nreturn 4;\n}\nupdateRegexPotentialError(desc + ((rest.length? (': [' + rest.join(', ')) + ']' : '')));\nlastReportableLexerError = 'Regex: ' + lastPotentialRegexError;\nreturn 4;\n}\nfunction updateRegexPotentialError(msg) {\nif (!lastPotentialRegexError.includes(msg)) {\nif (lastPotentialRegexError) lastPotentialRegexError += '; ';\nlastPotentialRegexError += msg;\n}\n}\nfunction updateRegexUflagIsIllegal(state, reason) {\nreturn updateRegexUflagState(state, 2, reason);\n}\nfunction updateRegexUflagIsMandatory(state, reason) {\nreturn updateRegexUflagState(state, 1, reason);\n}\nfunction updateRegexUflagState(currentState, newState, error) {\nif (lastReportableLexerError) return 4;\nif (currentState === (((newState === 1)? 2 : 1))) {\nreturn regexSyntaxError(error);\n}\nif (currentState === 0) {\nupdateRegexPotentialError(error);\ncurrentState = newState;\n} else {\n\n}\nreturn currentState;\n}\nlet nCapturingParens = 0;\nlet largestBackReference = 0;\nlet declaredGroupNames = ',';\nlet reffedGroupNames = ',';\nlet kCharClassEscaped = false;\nlet foundInvalidGroupName = false;\nfunction parseRegex(c) {\nnCapturingParens = 0;\nlargestBackReference = 0;\nlastPotentialRegexError = '';\ndeclaredGroupNames = ',';\nreffedGroupNames = ',';\nkCharClassEscaped = false;\nfoundInvalidGroupName = false;\nlet ustatusBody = parseRegexBody(c);\nif (ustatusBody === 4) {\nreturn 2097175;\n}\nlet ustatusFlags = parseRegexFlags();\nif (nCapturingParens < largestBackReference) {\nlet errmsg = 'Largest back reference index exceeded the number of capturing groups (only valid without u-flag in webcompat mode)';\nif (webCompat === false) {\nregexSyntaxError(errmsg);\nreturn 2097175;\n}\nustatusBody = updateRegexUflagIsIllegal(ustatusBody, errmsg);\n}\nif (ustatusFlags === 4) {\nreturn 2097175;\n}\nif (kCharClassEscaped) {\nif (declaredGroupNames !== ',') {\nregexSyntaxError('Found `\\\\k` in a char class but the regex also had a group name so this is illegal');\nreturn 2097175;\n}\nif (((webCompat === false) || (ustatusFlags === 1))) {\nregexSyntaxError('Found `\\\\k` in a char class but this is only allowed in webcompat mode and without u-flag');\nreturn 2097175;\n}\n}\nif (((reffedGroupNames !== ',') && (((webCompat === false) || (declaredGroupNames !== ','))))) {\nlet bad = false;\nreffedGroupNames.split(',').filter(Boolean).forEach(name => {\nif (!declaredGroupNames.includes((',' + name) + ',')) {\nregexSyntaxError(('Found a `\\\\k` that referenced `' + name) + '` but no capturing group had this name');\nbad = true;\n}\n});\nif (bad) {\nreturn 2097175;\n}\n}\nif (ustatusBody === 1) {\nif (ustatusFlags === 1) return 262158;\nregexSyntaxError('Regex contained syntax that is only valid with the u-flag but the u-flag was not present');\nreturn 2097175;\n}\nif (ustatusBody === 2) {\nif (ustatusFlags !== 1) return 262157;\nregexSyntaxError('Regex contained syntax that is invalid with the u-flag but the u-flag was present');\nreturn 2097175;\n}\nif (ustatusFlags === 1) return 262158;\nreturn 262157;\n}\nfunction parseRegexBody(c) {\nreturn _parseRegexBody(c, 0, 0);\n}\nfunction cannotBeQuantifier(c, uflagStatus, webcompatException, msg) {\nlet badStart = ((((((c === 0x2a) || (c === 0x2b))) || (c === 0x3f))) || (c === 0x7b));\nif (badStart) {\nmsg += (' (by a `' + String.fromCharCode(c)) + '`)';\nif ((webcompatException && (webCompat === true))) {\nuflagStatus = updateRegexUflagIsIllegal(uflagStatus, msg);\n} else {\nuflagStatus = regexSyntaxError(msg);\n}\n}\nreturn uflagStatus;\n}\nfunction _parseRegexBody(c, groupLevel, uflagStatus) {\nlet afterAtom = false;\nuflagStatus = cannotBeQuantifier(c, uflagStatus, c === 0x7b, 'Started with a quantifier but that is not allowed');\nlet groupNames = {};\ndo {\nlet s = ((c > 0x7e)? 11 : regexAtomJumpTable[c]);\nswitch (s) {\ncase 0:\nskip();\nafterAtom = true;\nbreak;\ncase 1:\nskip();\nafterAtom = true;\nbreak;\ncase 2:\nskip();\nif (afterAtom) {\nafterAtom = false;\nif (pointer < len) {\nif ((cache === 0x3f)) {\nskip();\n}\n}\n} else {\nuflagStatus = regexSyntaxError(('Encountered unescaped quantifier (ord=' + c) + ') without a value to quantify');\n}\nbreak;\ncase 3:\nlet wasFixableAssertion = false;\nlet wasUnfixableAssertion = false;\nskip();\nafterAtom = false;\nif (pointer >= len) {\nreturn regexSyntaxError('Encountered early EOF');\n}\nc = cache;\nif (c === 0x3f) {\nskip();\nif (pointer >= len) {\nreturn regexSyntaxError('Encountered early EOF');\n}\nc = cache;\nif (((((((c === 0x3a) || (c === 0x3d))) || (c === 0x21))) || (c === 0x3c))) {\nif (c === 0x3c) {\nskip();\nif (pointer >= len) {\nreturn regexSyntaxError('Encountered early EOF');\n}\nc = cache;\nif (((c === 0x3d) || (c === 0x21))) {\nif (!supportRegexLookbehinds) {\nreturn THROW('Lookbehinds in regular expressions are not supported in the currently targeted language version', startForError, pointer + 1);\n}\nskip();\nwasUnfixableAssertion = true;\n} else if (!supportRegexNamedGroups) {\nskip();\nreturn regexSyntaxError(('The lookbehind group `(?<` must be `(?<=` or `(?<!` because named groups are not supported in the currently targeted ES version, next char after `<` is `' + String.fromCharCode(c)) + '`');\n} else {\nuflagStatus = parseRegexGroupName(c, uflagStatus, true);\n++nCapturingParens;\n}\n} else if (((c === 0x3d) || (c === 0x21))) {\nskip();\nwasFixableAssertion = true;\n}\nif (pointer >= len) {\nreturn regexSyntaxError('Encountered early EOF');\n}\nc = cache;\n} else {\nreturn regexSyntaxError(('Illegal character after pseudo group marker `(?` [ord=' + c) + ']');\n}\n} else {\n++nCapturingParens;\n}\nlet subbad = _parseRegexBody(c, groupLevel + 1, 0);\nif (pointer >= len) {\nreturn regexSyntaxError('Encountered early EOF');\n}\nc = cache;\nif ((wasFixableAssertion || wasUnfixableAssertion)) {\nuflagStatus = cannotBeQuantifier(c, uflagStatus, !wasUnfixableAssertion, 'Regex A-ssertion \"atoms\" can not be quantified (so things like `^`, `$`, and `(?=` can not have `*`, `+`, `?`, or `{` following it)');\n}\nafterAtom = true;\nif (subbad === 4) {\nuflagStatus = 4;\n} else if (subbad === 2) {\nuflagStatus = updateRegexUflagIsIllegal(uflagStatus, lastPotentialRegexError);\n} else if (subbad === 1) {\nuflagStatus = updateRegexUflagIsMandatory(uflagStatus, lastPotentialRegexError);\n}\nbreak;\ncase 4:\nskip();\nif (groupLevel > 0) return uflagStatus;\nreturn regexSyntaxError('Found unescaped closing paren `)` without a group being open');\ncase 5:\nlet charClassEscapeStatus = parseRegexCharClass();\nif (charClassEscapeStatus === 4) {\nuflagStatus = 4;\n} else if (charClassEscapeStatus === 2) {\nuflagStatus = updateRegexUflagIsIllegal(uflagStatus, lastPotentialRegexError);\n} else if (charClassEscapeStatus === 1) {\nuflagStatus = updateRegexUflagIsMandatory(uflagStatus, lastPotentialRegexError);\n}\nafterAtom = true;\nbreak;\ncase 6:\n{\nskip();\nlet reason = 'Encountered unescaped closing square bracket `]` while not parsing a character class, which is only valid without u-flag';\nif (webCompat === false) {\nreturn regexSyntaxError(reason);\n}\nuflagStatus = updateRegexUflagIsIllegal(uflagStatus, reason);\nafterAtom = true;\nbreak;\n}\ncase 7:\n{\nskip();\nafterAtom = true;\nif (pointer >= len) {\nreturn regexSyntaxError('Early EOF');\n}\nlet d = cache;\nif (((d === 0x62) || (d === 0x42))) {\nskip();\nafterAtom = false;\n} else {\nlet escapeStatus = parseEscapeForRegexAtom(d);\nif (escapeStatus === 4) {\nuflagStatus = 4;\n} else if (escapeStatus === 2) {\nuflagStatus = updateRegexUflagIsIllegal(uflagStatus, lastPotentialRegexError);\n} else if (escapeStatus === 1) {\nuflagStatus = updateRegexUflagIsMandatory(uflagStatus, lastPotentialRegexError);\n} else if (escapeStatus === 8) {\nafterAtom = false;\n}\n}\n}\nbreak;\ncase 8:\nif (groupLevel !== 0) {\nreturn regexSyntaxError('Unclosed group');\n}\nskip();\nreturn uflagStatus;\ncase 9:\nskip();\nafterAtom = false;\nbreak;\ncase 10:\nskip();\nif (pointer < len) {\nc = cache;\nuflagStatus = cannotBeQuantifier(c, uflagStatus, c === 0x7b, 'Regex `A-ssertion` \"atoms\" can not be quantified but this `$` was quantified anyways');\n}\nafterAtom = false;\nbreak;\ncase 11:\nif (((c === 0x2028) || (c === 0x2029))) {\nreturn regexSyntaxError('Encountered early EOF');\n}\nskip();\nafterAtom = true;\nbreak;\ncase 12:\n{\nskip();\nif (pointer >= len) {\nreturn regexSyntaxError('Early EOF at the start of a regex quantifier');\n}\nlet c = cache;\nlet validBrace = (isAsciiNumber(c)? parseRegexCurlyQuantifier(c) : 3);\nif (validBrace === 1) {\nif (afterAtom) {\nafterAtom = false;\nif ((pointer < len && (cache === 0x3f))) {\nskip();\n}\nbreak;\n}\nreturn regexSyntaxError('A valid bracket quantifier requires an unqualified atom, but that was not the case');\n}\nif (validBrace === 2) {\nreturn regexSyntaxError('Parsed a braced quantifier that contained an illegal range (left>right)');\n}\nif (pointer >= len) return regexSyntaxError('Encountered EOF while parsing curly quantifier');\nif (webCompat === false) {\nif ((cache === 0x2c)) {\nreturn regexSyntaxError('The first digit of a regex curly quantifier is mandatory');\n}\nif ((cache === 0x7d)) {\nreturn regexSyntaxError('A regex curly quantifier had no content');\n}\nreturn regexSyntaxError('Found an unescaped `{` that was not the start of a valid quantifier');\n}\nafterAtom = true;\nuflagStatus = updateRegexUflagIsIllegal(uflagStatus, 'Found an unescaped `{` that was not the start of a valid quantifier');\nbreak;\n}\ncase 13:\n{\nskip();\nlet reason = 'Encountered unescaped closing curly `}` while not parsing a quantifier';\nif (webCompat === false) {\nreturn regexSyntaxError(reason);\n}\nuflagStatus = updateRegexUflagIsIllegal(uflagStatus, reason);\nafterAtom = true;\nbreak;\n}\ncase 14:\nskip();\nafterAtom = false;\nbreak;\ncase 15:\nreturn regexSyntaxError('Encountered early EOF');\n;\n}\nif (pointer >= len) break;\nc = cache;\n} while (true);\nreturn regexSyntaxError('Found EOF before regex was closed');\n}\nfunction parseRegexGroupName(c, uflagStatus, forCapturing) {\nlet r = _parseRegexGroupName(c, uflagStatus, forCapturing);\nif (!foundInvalidGroupName) return r;\nif (forCapturing === true) {\nreturn regexSyntaxError('An invalid name for a capturing group can never lead to a valid regex');\n}\nkCharClassEscaped = true;\nreturn r;\n}\nfunction _parseRegexGroupName(c, uflagStatus, forCapturing) {\nif (c === 0x3e) {\nfoundInvalidGroupName = true;\nlastCanonizedInput = '';\nlastCanonizedInputLen = 0;\nif (webCompat === true) {\nreffedGroupNames += '<>,';\nreturn updateRegexUflagIsIllegal(uflagStatus, 'Group name is not optional without webcompat, found empty `<>`');\n}\nreturn regexSyntaxError('Group name is not optional, found empty `<>`');\n}\nlet pointerStart = pointer;\nlastCanonizedInput = '';\nlastCanonizedInputLen = 0;\nlet first = true;\nlet lastPointer = 0;\nwhile (((((c !== 0x3e) && (uflagStatus !== 4))) && (lastPointer !== pointer))) {\nlastPointer = pointer;\nif (c === 0x5c) {\nuflagStatus = _parseRegexGroupNameEscape(first, uflagStatus, forCapturing);\n} else {\nuflagStatus = _parseRegexGroupNameChar(first, c, uflagStatus, forCapturing);\n}\nif (pointer >= len) {\nfoundInvalidGroupName = true;\nlastCanonizedInput = '';\nlastCanonizedInputLen = 0;\nreturn regexSyntaxError('Missing closing angle bracket of name of capturing group');\n}\nc = cache;\nfirst = false;\n}\nif (uflagStatus === 4) {\nfoundInvalidGroupName = true;\nlastCanonizedInput = '';\nlastCanonizedInputLen = 0;\nreturn 4;\n}\nif (lastPointer === pointer) {\nfoundInvalidGroupName = true;\nlastCanonizedInput = '';\nlastCanonizedInputLen = 0;\nreturn 2;\n}\nlastCanonizedInputLen = lastCanonizedInput.length;\nskip();\nif (lastCanonizedInputLen > 0) {\nlet next = lastCanonizedInput + ',';\nif (forCapturing === true) {\nif (declaredGroupNames.includes(',' + next)) {\nTHROW(('This group name (`' + lastCanonizedInput) + '`) was already used before', pointerStart, pointer - 1);\n}\ndeclaredGroupNames += next;\n} else {\nreffedGroupNames += next;\n}\n}\nreturn uflagStatus;\n}\nfunction _parseRegexGroupNameChar(start, c, uflagStatus, forCapturing) {\nlet wide = (start? isIdentStart(c, pointer) : isIdentRestChr(c, pointer));\nif (wide === (-2)) {\nskip();\nlastCanonizedInput += String.fromCharCode(c);\nreturn uflagStatus;\n}\nif (wide === (-1)) {\nfoundInvalidGroupName = true;\nif (((webCompat === false) || (forCapturing === true))) {\nreturn regexSyntaxError(('Tried to parse the name for a capturing group but it contained at least one invalid ident char (`' + String.fromCharCode(c)) + '`)');\n}\nreturn updateRegexUflagIsIllegal(uflagStatus, ('Tried to parse the name for a capturing group but it contained at least one invalid ident char (`' + String.fromCharCode(c)) + '`)');\n}\nskipFastWithoutUpdatingCache();\nskip();\nlastCanonizedInput += String.fromCodePoint(c);\nif (forCapturing === true) {\nreturn updateRegexUflagIsMandatory(uflagStatus, 'The start of the name of a capturing group had a surrogate pair and is therefor only valid with u-flag');\n}\nif (webCompat === false) {\nreturn updateRegexUflagIsMandatory(uflagStatus, 'The start of a `\\\\k` group name had a surrogate pair and is therefor only valid with u-flag');\n}\nreturn uflagStatus;\n}\nfunction _parseRegexGroupNameEscape(start, uflagStatus, forCapturing) {\nskip();\nif (pointer >= len) {\nfoundInvalidGroupName = true;\nreturn regexSyntaxError('Found EOF at start of a group name identifier');\n}\nif (!(cache === 0x75)) {\nfoundInvalidGroupName = true;\nreturn regexSyntaxError('Found invalid escape character at the start of a group name identifier');\n}\nskip();\nif (pointer >= len) {\nreturn updateRegexUflagIsIllegal(0, 'Unexpected EOF while parsing unicode escape');\n}\nlet c = cache;\nif (c === 0x7b) {\nc = parseUnicodeRubyEscape();\nuflagStatus = updateRegexUflagIsMandatory(0, 'Found a unicode ruby escape which is only valid with u-flag');\n} else {\nc = parseUnicodeQuadEscape(c, false);\nif (((c > 0xffff) && (forCapturing === true))) {\nuflagStatus = updateRegexUflagIsMandatory(uflagStatus, 'The name of a capturing group contained a double unicode quad escape which is valid as a surrogate pair which requires u-flag and which cannot be made valid without u-flag');\n}\n}\nif (pointer >= len) {\nfoundInvalidGroupName = true;\nreturn regexSyntaxError('Early EOF while parsing a group name');\n}\nif (c === 0x110000) {\nfoundInvalidGroupName = true;\nif (((webCompat === false) || (forCapturing === true))) {\nreturn regexSyntaxError('Regex contained a group name with invalid unicode escape');\n}\nreturn updateRegexUflagIsIllegal(uflagStatus, 'The name of a `\\\\k` escape contained a broken unicode ruby escape and this can not lead to a valid regex with u-flag');\n}\nlet firstCharStr = toStringExpensive(c);\nlastCanonizedInput += firstCharStr;\nlet wide = (start? isIdentStart(c, -1) : isIdentRestChr(c, -1));\nif (wide === (-2)) {\nreturn uflagStatus;\n}\nif (wide === (-3)) {\nif (forCapturing === true) {\nreturn updateRegexUflagIsMandatory(uflagStatus, 'Found a codepoint in a capturing group name that requires the u-flag to be considered valid');\n}\nif (webCompat === false) {\nreturn updateRegexUflagIsMandatory(uflagStatus, 'Found a codepoint in a `\\\\k` escape group name that requires the u-flag to be considered valid');\n}\nreturn uflagStatus;\n}\nif (forCapturing === true) {\nfoundInvalidGroupName = true;\nreturn regexSyntaxError('Encountered invalid unicode escape inside the group name of a capturing group, this cannot be valid');\n}\nif (webCompat === false) {\nfoundInvalidGroupName = true;\nreturn regexSyntaxError('Encountered invalid unicode escape inside the group name of a `\\\\k` escape, this can not become valid without web compat mode');\n}\nreturn updateRegexUflagIsIllegal(uflagStatus, 'Encountered invalid unicode escape inside the group name of a `\\\\k` escape, this is invalid with u-flag');\n}\nfunction parseEscapeForRegexAtom(c) {\nlet s = ((c > 0x7e)? 4 : regexAtomEscapeStartJumpTable[c]);\nswitch (s) {\ncase 0:\nskip();\nreturn 0;\ncase 2:\nskip();\nreturn parseUnicodeEscapeForRegexAtom();\ncase 3:\nskip();\nif (pointer >= len) {\nreturn regexSyntaxError('Encountered early EOF while parsing hex escape');\n}\nlet a = cache;\nlet va = getHexValue(a);\nif (va === 16) {\nlet reason = 'First char of hex escape not a valid digit';\nif (webCompat === true) {\nreturn updateRegexUflagIsIllegal(0, reason);\n}\nreturn regexSyntaxError(reason);\n}\nskip();\nif (pointer >= len) {\nreturn regexSyntaxError('Encountered early EOF while parsing hex escape');\n}\nlet b = cache;\nlet vb = getHexValue(b);\nif (vb === 16) {\nlet reason = 'Second char of hex escape not a valid digit';\nif (webCompat === true) {\nreturn updateRegexUflagIsIllegal(0, reason);\n}\nreturn regexSyntaxError(reason);\n}\nskip();\nreturn 0;\ncase 1:\nskip();\nreturn updateRegexUflagIsIllegal(0, 'Atoms can only escape certain non-special chars without u-flag');\ncase 4:\nlet wide = isIdentRestChr(c, pointer);\nif (wide === (-3)) {\nc = input.codePointAt(pointer);\nskipFastWithoutUpdatingCache();\nskip();\nif (webCompat === false) {\nreturn regexSyntaxError(((('Cannot use a surrogate pair as atom escape (' + c) + ', `') + String.fromCodePoint(c)) + '`)');\n}\nreturn updateRegexUflagIsIllegal(0, 'Atom escape can only escape certain syntax chars with u-flag');\n}\nif (wide === (-2)) {\nskip();\nif (webCompat === false) {\nreturn regexSyntaxError(((('Cannot escape this regular identifier character [ord=' + c) + '][') + String.fromCharCode(c)) + ']');\n}\nreturn updateRegexUflagIsIllegal(0, 'Atom escape can only escape certain syntax chars with u-flag');\n}\n;\nskip();\nif (((c === 0x2028) || (c === 0x2029))) {\nreturn regexSyntaxError('Regular expressions do not support line continuations (escaped newline)');\n}\nif (webCompat === false) {\nreturn regexSyntaxError(((('Cannot escape this non-identifier character [ord=' + c) + '][') + String.fromCharCode(c)) + ']');\n}\nreturn updateRegexUflagIsIllegal(0, 'Atom escape can only escape certain syntax chars with u-flag');\ncase 5:\nskip();\nif (pointer >= len) {\nreturn regexSyntaxError('Encountered early EOF while parsing char escape');\n}\nlet d = cache;\nif (isAsciiLetter(d)) {\nskip();\nreturn 0;\n}\nlet reason = ('Illegal char escape char (ord=' + d) + ')';\nif (webCompat === true) {\nreturn updateRegexUflagIsIllegal(0, reason);\n}\nreturn regexSyntaxError(reason);\ncase 6:\nconst FROM_ATOM = false;\nreturn parseRegexPropertyEscape(c, FROM_ATOM);\ncase 7:\nskip();\nif (pointer >= len) return 0;\nif (isAsciiNumber(cache)) {\nlet reason = 'Back references can not have more two or more consecutive numbers';\nif (webCompat === true) {\nreturn updateRegexUflagIsIllegal(0, reason);\n} else {\nreturn regexSyntaxError(reason);\n}\n}\nreturn 0;\ncase 8:\nreturn parseRegexDecimalEscape(c);\ncase 9:\n{\nlet uflagStatus = 0;\nskip();\nif (pointer >= len) return regexSyntaxError('Early EOF while parsing `\\\\k` escape in regex character class');\nc = cache;\nif (c !== 0x3c) {\nkCharClassEscaped = true;\nlet reason = 'Named back reference \\\\k; missing group name';\nif (webCompat === false) {\nreturn regexSyntaxError(reason, c);\n}\nreturn updateRegexUflagIsIllegal(0, reason);\n}\nskip();\nif (pointer >= len) return regexSyntaxError('Early EOF while parsing `\\\\k` escape in regex character class');\nc = cache;\nuflagStatus = parseRegexGroupName(c, uflagStatus, false);\nreturn uflagStatus;\n}\ncase 10:\nskip();\nreturn regexSyntaxError('Regular expressions do not support line continuations (escaped newline)');\ncase 11:\nskip();\nif (webCompat === true) {\nreturn updateRegexUflagIsIllegal(0, 'Atom escape can only escape certain letters without u-flag');\n}\nreturn regexSyntaxError(('Cannot escape this letter [' + String.fromCharCode(c)) + ']');\n;\n}\n}\nfunction parseRegexDecimalEscape(c) {\nskip();\nif (pointer >= len) return regexSyntaxError('Early EOF while parsing decimal escape in regex');\nlet d = cache;\nif (((d >= 0x30) && (d <= 0x39))) {\nskip();\nlet e = cache;\nif (((e >= 0x30) && (e <= 0x39))) {\nlet reason = 'Parsed too many digits';\nif (webCompat === true) {\nreturn updateRegexUflagIsIllegal(0, reason);\n} else {\nreturn regexSyntaxError(reason);\n}\n} else {\nlargestBackReference = Math.max(((c - 0x30) * 10) + (d - 0x30));\n}\n} else {\nlargestBackReference = Math.max(largestBackReference, c - 0x30);\n}\nreturn 0;\n}\nfunction parseRegexCharClass() {\nskip();\nlet prev = 0;\nlet surrogate = 0;\nlet isSurrogate = false;\nlet isSurrogateHead = false;\nlet wasSurrogate = true;\nlet wasSurrogateHead = false;\nlet urangeOpen = false;\nlet urangeLeft = -1;\nlet nrangeOpen = false;\nlet nrangeLeft = -1;\nlet flagState = 0;\nif (pointer >= len) return regexSyntaxError('Encountered early EOF while parsing char class (1)');\nlet c = cache;\nif (c === 0x5e) {\nskip();\nif (pointer >= len) return regexSyntaxError('Encountered early EOF while parsing char class (2)');\nc = cache;\n}\nwhile (c !== 0x5d) {\nlet wasEscape = false;\nlet wasDoubleQuad = false;\nlet wasBadUniEscape = false;\nlet wasPropEscape = false;\nlet wasPropOnly = false;\nlet wasBadPropEscape = false;\nlet wasRubyWebEscape = false;\nlet escapeCharUP = 0;\nif (c === 0x5c) {\nskip();\nwasEscape = true;\nif (pointer >= len) {\nregexSyntaxError('Early EOF after backslash in char class');\nreturn 0x110000;\n}\nc = cache;\nescapeCharUP = c;\nlet escapePointer = pointer;\nc = parseRegexCharClassEscape(c);\nif (escapeCharUP === 0x75) {\nif (c === 0x110000) {\nif (pointer >= len) return 0x110000;\nif (webCompat === false) return 0x110000;\nwasBadUniEscape = true;\nflagState = updateRegexUflagIsIllegal(flagState, 'A broken `\\\\u` escape can never be valid with u-flag');\nwasPropOnly = (pointer - escapePointer) === 1;\n} else if ((c & 67108864) > 0) {\nc ^= 67108864;\nwasRubyWebEscape = webCompat === true;\n} else if (c > 0xffff) {\nwasDoubleQuad = true;\n}\n} else if (((escapeCharUP === 0x70) || (escapeCharUP === 0x50))) {\nif (webCompat === true) {\nif (((((c === 0x110000) || (c === 34668544))) || ((c & 16777216) === 16777216))) {\nwasBadPropEscape = true;\n} else {\nwasPropEscape = true;\nwasPropOnly = (pointer - escapePointer) === 1;\n}\n}\n}\nif (c === 0x110000) {\nif (!wasBadUniEscape) {\nflagState = regexSyntaxError(lastPotentialRegexError);\n}\n} else if (c === 34668544) {\nflagState = regexSyntaxError(lastPotentialRegexError);\nc = 33554432;\n} else if (c === 33554432) {\n\n} else if (c === 0x110001) {\nif (webCompat === true) {\nflagState = updateRegexUflagIsIllegal(0, 'Char class can not contain `\\\\B`');\n} else {\nflagState = regexSyntaxError('Char class can not contain `\\\\B`');\n}\nc = 0x42;\n} else if (c === 0x110002) {\nflagState = updateRegexUflagIsIllegal(flagState, lastPotentialRegexError);\nc = 0x5c;\n} else {\nif (c & 16777216) {\nc = c ^ 16777216;\nflagState = updateRegexUflagIsIllegal(flagState, lastPotentialRegexError);\n}\nif (c & 8388608) {\nc = c ^ 8388608;\nflagState = updateRegexUflagIsMandatory(flagState, lastPotentialRegexError);\n}\n}\n} else if (((((((c === 0x0D) || (c === 0x0A))) || (c === 0x2028))) || (c === 0x2029))) {\nreturn regexSyntaxError('Encountered newline');\n} else {\nskip();\n}\nif (wasBadUniEscape) {\n\n} else if (wasEscape) {\nisSurrogate = c > 0xffff;\nif (isSurrogate) surrogate = c;\nisSurrogateHead = false;\n} else if ((wasSurrogateHead && isSurrogateTail(c))) {\nisSurrogate = true;\nisSurrogateHead = false;\nsurrogate = getSurrogate(prev, c);\n} else {\nisSurrogate = false;\nisSurrogateHead = isSurrogateLead(c);\n}\nif (urangeOpen) {\nlet urangeRight = (isSurrogate? surrogate : ((wasSurrogateHead? prev : c)));\nif (((urangeLeft === 33554432) || (urangeRight === 33554432))) {\nflagState = updateRegexUflagIsIllegal(flagState, 'Character class escapes `\\\\d \\\\D \\\\s \\\\S \\\\w \\\\W \\\\p \\\\P` not allowed in ranges with u');\n} else if (((!isSurrogateHead) || wasSurrogateHead)) {\nurangeOpen = false;\nif (urangeLeft > urangeRight) {\nflagState = updateRegexUflagIsIllegal(flagState, ((((((('Encountered incorrect range (left>right, ' + urangeLeft) + ' > ') + urangeRight) + ', 0x') + urangeLeft.toString(16)) + ' > 0x') + urangeRight.toString(16)) + ') which is illegal with u-flag');\n}\nurangeLeft = -1;\n} else {\n\n}\n} else if (((((c === 0x2d) && (!wasEscape))) && (urangeLeft !== (-1)))) {\nurangeOpen = true;\n} else {\nurangeLeft = (isSurrogate? surrogate : c);\n}\nlet cTmp = (((wasRubyWebEscape || wasPropEscape))? escapeCharUP : c);\nlet cTail = c;\nlet stillDataLeft = true;\nlet rubyHackLhs = (((wasRubyWebEscape || wasBadUniEscape)) || wasPropEscape);\nlet rubyHackRhsPeek = (wasBadUniEscape || ((wasBadPropEscape && (!wasPropOnly))));\nlet rubyHackRhsCurly = (wasRubyWebEscape || ((wasPropEscape && (!wasPropOnly))));\nwhile (stillDataLeft) {\nif (wasDoubleQuad) {\nwasDoubleQuad = false;\ncTail = codePointToSurrogateTail(cTmp);\ncTmp = codePointToSurrogateHead(cTmp);\n} else if (rubyHackLhs) {\nrubyHackLhs = false;\ncTmp = escapeCharUP;\nif (wasPropOnly) stillDataLeft = false;\n} else if (rubyHackRhsCurly) {\nrubyHackRhsCurly = false;\ncTmp = 0x7d;\nstillDataLeft = false;\n} else if (rubyHackRhsPeek) {\ncTmp = peekd(-1);\nrubyHackRhsPeek = false;\nstillDataLeft = false;\n} else {\nstillDataLeft = false;\ncTmp = cTail;\n}\nif (nrangeOpen) {\nconst nrangeRight = cTmp;\nif (((nrangeLeft === 33554432) || (nrangeRight === 33554432))) {\nif (webCompat === false) {\nflagState = updateRegexUflagIsMandatory(flagState, 'Character class escapes `\\\\d \\\\D \\\\s \\\\S \\\\w \\\\W \\\\p \\\\P` not allowed in ranges');\n}\n} else {\nif (nrangeLeft > nrangeRight) {\nflagState = updateRegexUflagIsMandatory(flagState, ((((((('Encountered incorrect range (left>right, ' + nrangeLeft) + ' > ') + nrangeRight) + ', 0x') + nrangeLeft.toString(16)) + ' > 0x') + nrangeRight.toString(16)) + ') when parsing as if without u-flag');\n}\n}\nnrangeLeft = -1;\nnrangeOpen = false;\n} else if (((((cTmp === 0x2d) && (!wasEscape))) && (nrangeLeft !== (-1)))) {\nnrangeOpen = true;\n} else {\nnrangeLeft = cTmp;\n}\n}\nwasSurrogate = isSurrogate;\nwasSurrogateHead = isSurrogateHead;\nprev = c;\nif (pointer >= len) {\nreturn regexSyntaxError('Unexpected early EOF while parsing character class');\n}\nc = cache;\n}\nskip();\nif ((urangeOpen && wasSurrogateHead)) {\nif (((urangeLeft === 33554432) || (prev === 33554432))) {\nreturn updateRegexUflagIsIllegal(flagState, 'Character class escapes `\\\\d \\\\D \\\\s \\\\S \\\\w \\\\W \\\\p \\\\P` are only ok as a range with webcompat, without uflag');\n}\nif (urangeLeft > prev) {\nreturn updateRegexUflagIsIllegal(flagState, ((((((('Encountered incorrect range end (left>right, ' + urangeLeft) + ' > ') + prev) + ', 0x') + urangeLeft.toString(16)) + ' > 0x') + prev.toString(16)) + ') which is illegal with u-flag');\n}\nreturn flagState;\n}\nreturn flagState;\n}\nfunction surrogateToCodepoint(head, tail) {\nreturn (((head & 0x3ff) << 10) | (tail & 0x3ff)) + 0x10000;\n}\nfunction codePointToSurrogateTail(codepoint) {\nreturn ((codepoint - 0x10000) & 0b1111111111) + 0xDC00;\n}\nfunction codePointToSurrogateHead(codepoint) {\nreturn ((codepoint - 0x10000) >> 10) + 0xD800;\n}\nfunction parseRegexCharClassEscape(c) {\nlet s = ((c >= 0x7f)? 1 : regexClassEscapeStartJumpTable[c]);\nswitch (s) {\ncase 0:\nskip();\n;\nif (webCompat === true) {\nupdateRegexUflagIsIllegal(0, ('Cannot escape `' + String.fromCharCode(c)) + '` in a regex char class with the u-flag');\nreturn c | 16777216;\n}\nif (isIdentRestChr(c, pointer) === (-1)) {\nupdateRegexUflagIsIllegal(0, ('Cannot escape `' + String.fromCharCode(c)) + '` in a regex char class with the u-flag');\nreturn c | 16777216;\n}\n;\nregexSyntaxError(('Cannot escape `' + String.fromCharCode(c)) + '` in a regex char class');\nreturn 0x110000;\ncase 1:\n{\nupdateRegexUflagIsIllegal(0, ('Cannot escape `' + String.fromCharCode(c)) + '` in a char class with the u-flag');\nif (webCompat === true) {\nskip();\nreturn c | 16777216;\n}\nlet wide = isIdentRestChr(c, -1);\nif (wide === (-2)) {\nregexSyntaxError(('Cannot escape `' + String.fromCodePoint(c)) + '` in a char class');\nreturn 0x110000;\n}\nif (((c === 0x2028) || (c === 0x2029))) {\nskip();\nregexSyntaxError('Regular expressions do not support line continuations (escaped x2028 x2029)');\nreturn 0x110000;\n}\nskip();\nreturn c | 16777216;\n}\ncase 2:\nskip();\nreturn parseUnicodeEscapeForRegexCharClass();\ncase 3:\nskip();\nif (eofd(1)) {\nregexSyntaxError('Found EOF before completely parsing a hex escape (in a char class of a regex)');\nreturn 0x110000;\n}\nlet a = cache;\nlet va = getHexValue(a);\nif (va === 16) {\nif (webCompat === true) {\nupdateRegexUflagIsIllegal(0, 'First character of hex escape was invalid');\nreturn 16777336;\n}\nregexSyntaxError('First character of hex escape was invalid');\nreturn 0x110000;\n}\nskip();\nlet b = cache;\nlet vb = getHexValue(b);\nif (vb === 16) {\nif (webCompat === true) {\nupdateRegexUflagIsIllegal(0, 'Second character of hex escape was invalid');\nreturn 16777336;\n}\nregexSyntaxError('Second character of hex escape was invalid');\nreturn 0x110000;\n}\nskip();\nreturn (va << 4) | vb;\ncase 4:\n{\nskip();\nif (pointer >= len) {\nregexSyntaxError('Early EOF while parsing `\\\\c` in a character class');\nreturn 0x110000;\n}\nlet d = cache;\nif (isAsciiLetter(d)) {\nskip();\nreturn d % 32;\n}\nlet reason = 'The `\\\\c` escape is only legal in a char class without u-flag and in webcompat mode';\nif (webCompat === true) {\nupdateRegexUflagIsIllegal(0, reason);\nreturn 0x110002;\n}\nregexSyntaxError(reason);\nreturn 0x110000;\n}\ncase 5:\nskip();\nif (webCompat === true) {\nkCharClassEscaped = true;\nupdateRegexUflagIsIllegal(0, 'Can only have `\\\\k` in a char class without u-flag and in webcompat mode');\nreturn 16777323;\n}\nregexSyntaxError('A character class is not allowed to have `\\\\k` back-reference');\nreturn 0x110000;\ncase 6:\nskip();\nreturn 8;\ncase 7:\n{\nskip();\nreturn 0x110001;\n}\ncase 8:\nskip();\nreturn 0x000C;\ncase 9:\nskip();\nreturn 0x000A;\ncase 10:\nskip();\nreturn 0x000D;\ncase 11:\nskip();\nreturn 0x0009;\ncase 12:\nskip();\nreturn 0x000B;\ncase 13:\nskip();\nreturn 33554432;\ncase 14:\nconst FROM_CHARCLASS = true;\nlet regexPropState = parseRegexPropertyEscape(c, FROM_CHARCLASS);\nif (regexPropState === 4) {\nreturn 34668544;\n}\nif (regexPropState === 2) {\nreturn 50331648;\n}\nif (regexPropState === 1) {\nreturn 41943040;\n}\n;\n;\nreturn 33554432;\ncase 15:\n{\nskip();\nif ((pointer < len && isAsciiNumber(cache))) {\nlet reason = 'An escaped zero cannot be followed by another number because that would be an octal escape';\nif (webCompat === true) {\nupdateRegexUflagIsIllegal(0, reason);\nreturn parseOctalFromSecondDigit(c) | 16777216;\n}\nregexSyntaxError(reason);\nreturn 0x110000;\n}\nreturn 0;\n}\ncase 16:\n{\nskip();\nlet reason = 'A character class is not allowed to have numeric back-reference';\nif (webCompat === true) {\nupdateRegexUflagIsIllegal(0, reason);\nreturn parseOctalFromSecondDigit(c) | 16777216;\n}\nregexSyntaxError(reason);\nreturn 0x110000;\n}\ncase 17:\nskip();\nreturn parseDecimalEscape(c);\ncase 18:\nskip();\nreturn c;\ncase 19:\n{\nskip();\nif (webCompat === true) {\nreturn 0x2d;\n}\nupdateRegexUflagIsMandatory(0, 'Escaping a dash in a char class is not allowed');\nreturn 8388653;\n}\ncase 20:\nskip();\nregexSyntaxError('Regular expressions do not support line continuations (escaped newline)');\nreturn 0x110000;\n;\n}\n}\nfunction parseRegexPropertyEscape(c, fromCharClass) {\nif (!supportRegexPropertyEscapes) {\nlet uflagState = updateRegexUflagIsIllegal(0, 'Property escapes are not supported by the currently targeted language version');\nif (webCompat === true) return uflagState;\nreturn updateRegexUflagIsMandatory(uflagState, 'Cannot escape `\\\\p` without u-flag');\n}\nskip();\nif (pointer >= len) return regexSyntaxError('Early EOF after a regex `\\\\p`');\nif (cache !== 0x7b) {\nif (webCompat === true) return updateRegexUflagIsIllegal(0, 'Property escape `\\\\p` must start with a curly bracket');\nreturn regexSyntaxError('Property escape `\\\\p` must start with a curly bracket');\n}\nc = skipPeek();\nlet pointerOffset = pointer;\nlet name = '';\nlet sawCommas = 0;\nlet hasEq = false;\nlet value = '';\ndo {\nif (((((((c >= 0x61) && (c <= 0x7a))) || (((c >= 0x41) && (c <= 0x5a))))) || (c === 0x5f))) {\n\n} else if (c === 0x7d) {\nbreak;\n} else if (c === 0x3d) {\nif (pointerOffset === pointer) {\nif (webCompat === true) {\nreturn updateRegexUflagIsIllegal(0, 'Property escape `\\\\p` had no value after the `=` which is illegal');\n}\nreturn regexSyntaxError('Property escape `\\\\p` had no value after the `=` which is illegal');\n}\nif (hasEq) {\nif (webCompat === true) {\nreturn updateRegexUflagIsIllegal(0, 'Property escape `\\\\p` contained double equal sign, which is not valid');\n}\nreturn regexSyntaxError('Property escape `\\\\p` contained double equal sign, which is not valid');\n}\nhasEq = true;\nname = slice(pointerOffset, pointer);\npointerOffset = pointer + 1;\n} else {\nif (webCompat === true) {\nreturn updateRegexUflagIsIllegal(0, ('Property escape `\\\\p` contained illegal character `' + slice(pointer, pointer + 1)) + '`');\n}\nreturn regexSyntaxError(('Property escape `\\\\p` contained illegal character `' + slice(pointer, pointer + 1)) + '`');\n}\nc = skipPeek();\nif (pointer >= len) {\nif (webCompat === true) {\nreturn updateRegexUflagIsIllegal(0, 'Encountered early EOF while parsing `\\\\p` property escape');\n}\nreturn regexSyntaxError('Encountered early EOF while parsing `\\\\p` property escape');\n}\n} while (true);\nif (pointerOffset === pointer) {\nif (webCompat === true) {\nif (hasEq) {\nreturn updateRegexUflagIsIllegal(0, 'Property escape `\\\\p` had no value after the `=` which is illegal');\n}\nreturn updateRegexUflagIsIllegal(0, ('Property escape `\\\\p` contained illegal character `' + slice(pointer, pointer + 1)) + '`');\n}\nif (hasEq) {\nreturn regexSyntaxError('Property escape `\\\\p` had no value after the `=` which is illegal');\n}\nreturn regexSyntaxError(('Property escape `\\\\p` contained illegal character `' + slice(pointer, pointer + 1)) + '`');\n}\nif (hasEq) value = slice(pointerOffset, pointer); else name = slice(pointerOffset, pointer);\nlet nc = (',' + name) + ',';\nif (hasEq) {\nif (!TABLE_NONBIN_UNI_PROPS.includes(nc)) {\nif (webCompat === true) {\nreturn updateRegexUflagIsIllegal(0, ('The `\\\\p` escaped binary property name `' + name) + '` is not valid (does not appear in \"table-nonbinary-unicode-properties\")');\n}\nreturn regexSyntaxError(('The `\\\\p` escaped binary property name `' + name) + '` is not valid (does not appear in \"table-nonbinary-unicode-properties\")');\n}\nlet vc = (',' + value) + ',';\nif (((!TABLE_GEN_CAT_VALUES.includes(vc)) && (!TABLE_SCRIPT_VALUES.includes(vc)))) {\nif (webCompat === true) {\nreturn updateRegexUflagIsIllegal(0, ('The escaped property value `' + value) + '` is not valid (does not appear in \"table-unicode-general-category-values\" nor \"table-unicode-script-values\")');\n}\nreturn regexSyntaxError(('The escaped property value `' + value) + '` is not valid (does not appear in \"table-unicode-general-category-values\" nor \"table-unicode-script-values\")');\n}\nskip();\nif (webCompat === true) {\nreturn 0;\n}\nreturn updateRegexUflagIsMandatory(0, 'The `\\\\p` property escape is only legal with a u-flag, or as a webcompat edge case');\n}\nif (((!TABLE_BIN_UNI_PROPS.includes(nc)) && (!TABLE_GEN_CAT_VALUES.includes(nc)))) {\nif (webCompat === true) {\nreturn updateRegexUflagIsIllegal(0, ('The escaped lone property name `' + name) + '` is not valid (does not appear in \"table-binary-unicode-properties\" nor \"table-unicode-general-category-values\")');\n}\nreturn regexSyntaxError(('The escaped lone property name `' + name) + '` is not valid (does not appear in \"table-binary-unicode-properties\" nor \"table-unicode-general-category-values\") with u-flag, and `\\\\p` is not valid without u-flag and without webcompat');\n}\nskip();\nif (webCompat === true) {\nreturn 0;\n}\nreturn updateRegexUflagIsMandatory(0, 'The `\\\\p` property escape is only legal with a u-flag, or as a webcompat edge case');\n}\nfunction parseRegexFlags() {\nlet g = 0;\nlet i = 0;\nlet m = 0;\nlet u = 0;\nlet y = 0;\nlet s = 0;\nwhile (pointer < len) {\nlet c = cache;\nswitch (c) {\ncase 0x67:\n++g;\nbreak;\ncase 0x69:\n++i;\nbreak;\ncase 0x6D:\n++m;\nbreak;\ncase 0x75:\n++u;\nbreak;\ncase 0x79:\n++y;\nbreak;\ncase 0x73:\nif (!supportRegexDotallFlag) {\nreturn THROW('The dotall flag `s` is not supported in the currently targeted language version', pointer, pointer);\n}\n++s;\nbreak;\ndefault:\nif ((isAsciiLetter(c) || (c === 0x5c))) {\nreturn regexSyntaxError(((('Unknown regex flag [ord=' + c) + ', `') + String.fromCharCode(c)) + '`)]');\n}\nif ((((((g | i) | m) | u) | y) | s) > 1) {\nreturn regexSyntaxError('Encountered at least one regex flag twice');\n}\nreturn ((u > 0)? 1 : 2);\n}\nskip();\n}\nif ((((((g | i) | m) | u) | y) | s) > 1) {\nreturn regexSyntaxError('Encountered at least one regex flag twice');\n}\nreturn ((u > 0)? 1 : 2);\n}\nfunction parseRegexCurlyQuantifier(c) {\nlet min = 0;\nwhile (isAsciiNumber(c)) {\nmin = (min * 10) + (c - 0x30);\nskip();\nif (pointer >= len) return 3;\nc = cache;\n}\nif (c !== 0x2c) {\nif (c !== 0x7d) return 3;\nskip();\nreturn 1;\n}\nskip();\nif (pointer >= len) return 3;\nc = cache;\nif (!isAsciiNumber(c)) {\nif (c !== 0x7d) return 3;\nskip();\nreturn 1;\n}\nlet max = 0;\ndo {\nmax = (max * 10) + (c - 0x30);\nskip();\nif (pointer >= len) return 3;\nc = cache;\n} while (isAsciiNumber(c));\nif (c !== 0x7d) return 3;\nskip();\nif (min <= max) return 1;\nreturn 2;\n}\nfunction isSurrogateLead(c) {\nreturn ((c >= 0xD800) && (c <= 0xDBFF));\n}\nfunction isSurrogateTail(c) {\nreturn ((c >= 0xDC00) && (c <= 0xDFFF));\n}\nfunction getSurrogate(c1, c2) {\nreturn (((c1 - 0xD800) * 0x400) + (c2 - 0xDC00)) + 0x10000;\n}\nfunction parseDecimalEscape(c) {\nlet reason = 'Cannot escape \\\\8 or \\\\9 in a regex char class with u-flag';\nif (webCompat === true) {\nupdateRegexUflagIsIllegal(0, reason);\nreturn c | 16777216;\n}\nregexSyntaxError(reason);\nreturn 0x110000;\n}\nfunction parseOctalFromSecondDigit(firstChar) {\nif (pointer >= len) return firstChar - 0x30;\nlet secondChar = cache;\nif (isLowerOctal(firstChar)) {\nif (isOctal(secondChar)) {\nskip();\nif (pointer >= len) return ((firstChar - 0x30) * 8) + (secondChar - 0x30);\nlet thirdChar = cache;\nif (isOctal(thirdChar)) {\nskip();\nreturn ((((firstChar - 0x30) * 8) * 8) + ((secondChar - 0x30) * 8)) + (thirdChar - 0x30);\n}\nreturn ((firstChar - 0x30) * 8) + (secondChar - 0x30);\n}\nreturn firstChar - 0x30;\n}\nif (isOctal(secondChar)) {\nskip();\nif (pointer >= len) return ((firstChar - 0x30) * 8) + (secondChar - 0x30);\nlet thirdChar = cache;\nif (isLowerOctal(thirdChar)) {\nskip();\nreturn ((((firstChar - 0x30) * 8) * 8) + ((secondChar - 0x30) * 8)) + (thirdChar - 0x30);\n}\nreturn ((firstChar - 0x30) * 8) + (secondChar - 0x30);\n}\nreturn firstChar - 0x30;\n}\nfunction isOctal(c) {\nreturn ((c >= 0x30) && (c <= 0x37));\n}\nfunction isLowerOctal(c) {\nreturn ((c >= 0x30) && (c <= 0x33));\n}\nfunction isUpperOctal(c) {\nreturn ((c >= 0x34) && (c <= 0x37));\n}\nfunction parseUnicodeEscapeForNonRegex() {\nlet c = cache;\nif (c !== 0x7b) {\nreturn parseUnicodeQuadEscape(c, true);\n}\nreturn parseUnicodeRubyEscape();\n}\nfunction parseUnicodeEscapeForRegexAtom() {\nif (pointer >= len) {\nreturn regexSyntaxError('Early EOF while trying to parse unicode escape');\n}\nlet c = cache;\nlet wasRuby = false;\nif (c === 0x7b) {\nc = parseUnicodeRubyEscape();\nwasRuby = true;\n} else {\nc = parseUnicodeQuadEscape(c, false);\n}\nif (pointer >= len) {\nreturn regexSyntaxError('EOF while trying to parse regex atom unicode escape');\n}\nif (c === 0x110000) {\nif (webCompat === true) {\nreturn updateRegexUflagIsIllegal(0, 'Error while trying to parse regex atom unicode escape');\n}\nreturn regexSyntaxError('Error while trying to parse regex atom unicode escape');\n}\nif ((wasRuby && (webCompat === false))) {\nreturn updateRegexUflagIsMandatory(0, 'A regex atom that is an unicode ruby escape is only legal with u-flag');\n}\nif ((((wasRuby && (webCompat === true))) && (!c.toString(16).match(/[a-z]/i)))) {\nif ((pointer < len && (cache === 0x3f))) {\nskip();\n}\nreturn 8;\n}\nreturn 0;\n}\nfunction parseUnicodeEscapeForRegexCharClass() {\nif (pointer >= len) {\nregexSyntaxError('Early EOF while parsing a unicode escape in a regex char class');\nreturn 0x110000;\n}\nlet c = cache;\nlet wasQuad = true;\nif (c === 0x7b) {\nc = parseUnicodeRubyEscape();\nwasQuad = false;\n} else {\nc = parseUnicodeQuadEscape(c, false);\n}\nif (pointer >= len) {\nregexSyntaxError('Early EOF while parsing a unicode escape in a regex char class');\nreturn 0x110000;\n}\nif (c === 0x110000) {\nreturn 0x110000;\n}\nlet rubyWebException = false;\nif (!wasQuad) {\nif (webCompat === false) {\nupdateRegexUflagIsMandatory(0, 'Found a unicode ruby escape which is only valid with u-flag');\nrubyWebException = true;\n}\nc |= 67108864;\n}\nif (rubyWebException) return c | 8388608;\nreturn c;\n}\nfunction parseUnicodeQuadEscape(a, noDouble) {\nif (eofd(3)) {\nupdateRegexUflagIsIllegal(0, 'Unexpected EOF while parsing unicode quad escape');\nreturn 0x110000;\n}\nlet b = peekd(1);\nlet c = peekd(2);\nlet d = peekd(3);\nlet va = getHexValue(a);\nlet vb = getHexValue(b);\nlet vc = getHexValue(c);\nlet vd = getHexValue(d);\nif ((((va | vb) | vc) | vd) > 15) {\nupdateRegexPotentialError('Attempted to parse a unicode quad escape but at least one digit was not a hex');\nreturn 0x110000;\n}\nskip();\nskip();\nskip();\nskip();\nlet firstPart = (((va << 12) | (vb << 8)) | (vc << 4)) | vd;\nif ((((((((((noDouble || (firstPart < 0xD800))) || (firstPart > 0xDBFF))) || eofd(5))) || (cache !== 0x5c))) || (peekd(1) !== 0x75))) {\nreturn firstPart;\n}\nlet e = peekd(2);\nlet f = peekd(3);\nlet g = peekd(4);\nlet h = peekd(5);\nlet ve = getHexValue(e);\nlet vf = getHexValue(f);\nlet vg = getHexValue(g);\nlet vh = getHexValue(h);\nif ((((ve | vf) | vg) | vh) > 15) {\nreturn firstPart;\n}\nlet secondPart = (((ve << 12) | (vf << 8)) | (vg << 4)) | vh;\nif (((secondPart < 0xDC00) || (secondPart > 0xDFFF))) {\nreturn firstPart;\n}\nskip();\nskip();\nskip();\nskip();\nskip();\nskip();\nlet codepoint = surrogateToCodepoint(firstPart, secondPart);\nupdateRegexPotentialError('A double unicode quad escape that represents a surrogate pair in char class or group name is only valid with u-flag');\nreturn codepoint;\n}\nfunction parseUnicodeRubyEscape() {\nskip();\nlet c = parseUnicodeRubyEscapeBody();\nif (((((c === 0x110000) || pointer >= len)) || (!(cache === 0x7d)))) {\nreturn 0x110000;\n}\nskip();\nreturn c;\n}\nfunction parseUnicodeRubyEscapeBody() {\nif (pointer >= len) return 0x110000;\nlet a = cache;\nlet v = getHexValue(a);\nif (v === 16) return 0x110000;\nskip();\nreturn parseUnicodeRubyEscapeBody2(v);\n}\nfunction parseUnicodeRubyEscapeBody2(v) {\nif (v === 0) {\nif (pointer >= len) return 0x110000;\nlet c = skipZeroes();\nv = getHexValue(c);\nif (v === 16) {\nreturn 0;\n}\nskip();\n}\nreturn parseUnicodeRubyEscapeBody3(v);\n}\nfunction parseUnicodeRubyEscapeBody3(v) {\nif (pointer >= len) return 0x110000;\nlet b = cache;\nlet vb = getHexValue(b);\nif (vb === 16) return v;\nskip();\nreturn parseUnicodeRubyEscapeBody4((v << 4) + vb);\n}\nfunction parseUnicodeRubyEscapeBody4(v) {\nif (pointer >= len) return 0x110000;\nlet c = cache;\nlet vc = getHexValue(c);\nif (vc === 16) return v;\nskip();\nreturn parseUnicodeRubyEscapeBody5((v << 4) + vc);\n}\nfunction parseUnicodeRubyEscapeBody5(v) {\nif (pointer >= len) return 0x110000;\nlet d = cache;\nlet vd = getHexValue(d);\nif (vd === 16) return v;\nskip();\nreturn parseUnicodeRubyEscapeBody6((v << 4) + vd);\n}\nfunction parseUnicodeRubyEscapeBody6(v) {\nif (pointer >= len) return 0x110000;\nlet e = cache;\nlet ve = getHexValue(e);\nif (ve === 16) return v;\nskip();\nreturn parseUnicodeRubyEscapeBody7((v << 4) + ve);\n}\nfunction parseUnicodeRubyEscapeBody7(v) {\nif (pointer >= len) return 0x110000;\nlet f = cache;\nlet vf = getHexValue(f);\nif (vf === 16) return v;\nskip();\nlet r = (v << 4) + vf;\nif (r >= 0x110000) return 0x110000;\nreturn r;\n}\nfunction parseOtherUnicode(c) {\nswitch (c) {\ncase 0xA0:\nreturn parseSpace();\ncase 0xFEFF:\nreturn parseSpace();\ncase 0x2028:\nreturn parseNewlineSolo();\ncase 0x2029:\nreturn parseNewlineSolo();\ndefault:\nlet t = parseIdentUnicodeOrError(c);\nif (t !== 2097175) return t;\nreturn parseWhitespaceUnicodeOrError(c);\n}\n}\nfunction parseIdentUnicodeOrError(c) {\nlet cu = input.codePointAt(pointer - 1);\nlet wide = isIdentStart(cu, pointer - 1);\nif (wide !== (-1)) {\nif (wide === (-3)) skip();\nreturn parseIdentifierRest(String.fromCodePoint(cu), ((wide === (-3))? 2 : 1));\n}\nif (!lastReportableLexerError) lastReportableLexerError = ((('Unexpected unicode character: ' + c) + ' (') + String.fromCharCode(c)) + ')';\nreturn 2097175;\n}\nfunction parseWhitespaceUnicodeOrError(c) {\nreturn ([0x1680, 0x2000, 0x2001, 0x2002, 0x2003, 0x2004, 0x2005, 0x2006, 0x2007, 0x2008, 0x2009, 0x200a, 0x202F, 0x205F, 0x3000].includes(c)? 257 : 2097175);\n}\nfunction THROW(str, tokenStart, tokenStop) {\n$error('Throwing this error:', str);\n_THROW('Lexer error! ' + str, tokenStart, tokenStop);\n}\nfunction _THROW(str, tokenStart, tokenStop, msg = '', withCodeFrame = errorCodeFrame, fullCodeFrameLocal = truncCodeFrame) {\nlet ectxt = (withCodeFrame? getErrorContext(tokenStart, tokenStop, msg, fullCodeFrameLocal) : '');\nlet context = (('\\n`````\\n' + (((ectxt[ectxt.length - 1] !== '\\n')? '\\n' : ''))) + ectxt) + '`````\\n';\n$log('Error at:' + context);\nif (gracefulErrors === false) throw new Error(((str + '\\n') + ((withCodeFrame? '\\n' : ''))) + ectxt); else $error(str);\n}\nfunction getErrorContext(tokenStart, tokenStop, msg, truncCodeFrame = false) {\nlet inputOffset = 0;\nif ((truncCodeFrame && (tokenStart > 100))) inputOffset = tokenStart - 100;\nlet inputLen = input.length - inputOffset;\nif ((truncCodeFrame && ((tokenStop + 100) < input.length))) inputLen = (tokenStop + 100) - inputOffset;\nlet isPointerIncluded = true;\nif ((inputOffset + inputLen) < pointer) {\nlet len = pointer - inputOffset;\nif (len < 1024) {\ninputLen = len;\n} else {\nisPointerIncluded = false;\n}\n}\nlet usedInput = input.slice(inputOffset, inputOffset + inputLen);\nlet tokenOffset = tokenStart - inputOffset;\nlet nl1 = usedInput.lastIndexOf('\\n', tokenOffset);\nlet nl2 = usedInput.indexOf('\\n', nl1 + 1);\nif (nl2 < 0) nl2 = usedInput.length;\nlet arrowCount = ((tokenStop - tokenStart) || 1);\nlet indentCount = tokenOffset - (nl1 + 1);\nlet pointerLine = currentLine;\nlet errorLine = currentLine;\nlet errorColumn = ((((inputOffset > 0) && (nl1 < 0)))? (-1) : ((tokenStart - inputOffset) - (((nl1 >= 0)? nl1 + 1 : 0))));\nif (isPointerIncluded) {\nlet relativePointer = pointer - inputOffset;\nlet searchPointer = relativePointer;\nwhile (searchPointer > 0) {\nsearchPointer = usedInput.lastIndexOf('\\n', searchPointer - 1);\n--pointerLine;\nif (searchPointer > nl1) --errorLine;\n}\nif (searchPointer !== 0) pointerLine += 1;\n}\nlet maxPointerlineLen = ('' + currentLine).length;\nlet gutterWidth = maxPointerlineLen + 4;\nlet pre = usedInput.slice(0, nl2).split('\\n');\nlet post = usedInput.slice(nl2 + 1, inputLen).split('\\n');\nwhile (((pre.length > 1) && (pre[0].length === 0))) {\npre.shift();\n++pointerLine;\n}\nwhile (((post.length > 0) && (post[post.length - 1].length === 0))) {\npost.pop();\n}\nlet lc = pointerLine;\nlet pre2 = pre.map(s => (((' ' + ('' + (lc++)).padStart(maxPointerlineLen, ' ')) + '  ') + s.trimRight())).join('\\n');\nlet post2 = post.map(s => (((' ' + ('' + (lc++)).padStart(maxPointerlineLen, ' ')) + '  ') + s.trimRight())).join('\\n');\nif (('' + lc).length > maxPointerlineLen) {\nmaxPointerlineLen = ('' + lc).length;\ngutterWidth = maxPointerlineLen + 4;\nlc = pointerLine;\npre2 = pre.map(s => (((' ' + ('' + (lc++)).padStart(maxPointerlineLen, ' ')) + '  ') + s.trimRight())).join('\\n');\npost2 = post.map(s => (((' ' + ('' + (lc++)).padStart(maxPointerlineLen, ' ')) + '  ') + s.trimRight())).join('\\n');\n}\nlet col = ((pointerLine === 1)? inputOffset : usedInput.lastIndexOf(inputOffset));\nlet top = ((((((('start@' + pointerLine) + ':') + (((col < 0)? '?' : col))) + ', error@') + errorLine) + ':') + (((errorColumn < 0)? '?' : errorColumn))) + '\\n';\nlet bar = ''.repeat(top.length - gutterWidth) + '\\n';\nlet header = ('' + ''.repeat(maxPointerlineLen)) + '';\nlet footer = ('' + ''.repeat(maxPointerlineLen)) + '';\nlet returnValue = ((((((((((((((((top + header) + bar) + pre2) + '\\n') + ' '.repeat(Math.max(0, maxPointerlineLen + 1))) + '  ') + ' '.repeat(Math.max(0, indentCount))) + '^'.repeat(Math.max(0, arrowCount))) + '------- error') + ((msg? ': ' + msg : ''))) + (((tokenOffset >= usedInput.length)? ' at EOF' : ''))) + ((post2? '\\n' : ''))) + post2) + '\\n') + footer) + bar) + '';\nreturn returnValue.split('\\n').map(s => (s.trimRight())).join('\\n');\n}\nreturn {tokens:tokenStorage, nextToken:nextToken, asi:addAsi, throw:_THROW, lexError:function() {\nTHROW(lastReportableLexerError, startForError, pointer);\n}, getTokenCountAny:function() {\nreturn anyTokenCount;\n}, getTokenCountSolid:function() {\nreturn solidTokenCount;\n}, prevEndColumn:function() {\nreturn prevTokenEndColumn;\n}, prevEndLine:function() {\nreturn prevTokenEndLine;\n}, prevEndPointer:function() {\nreturn prevTokenEndPointer;\n}, currColumn:function() {\nreturn pointer - currentColOffset;\n}, currLine:function() {\nreturn currentLine;\n}, currPointer:function() {\nreturn pointer;\n}, getNlwas:function() {\nreturn nlwas;\n}, getCanoN:function() {\nreturn lastCanonizedInput;\n}, getType:function() {\nreturn lastType;\n}, getStart:function() {\nreturn lastStart;\n}, getStop:function() {\nreturn lastStop;\n}, getLine:function() {\nreturn lastLine;\n}, getColumn:function() {\nreturn lastColumn;\n}, sliceInput:slice};\n}\nfunction isLfPsLs(c) {\nreturn ((c === 0x0A) || isPsLs(c));\n}\nfunction isPsLs(c) {\nreturn ((c === 0x2028) || (c === 0x2029));\n}\nfunction START(type) {\nswitch (type) {\ncase 1:\nreturn 'START_SPACE';\ncase 2:\nreturn 'START_ID';\ncase 3:\nreturn 'START_KEY';\ncase 4:\nreturn 'START_NL_SOLO';\ncase 5:\nreturn 'START_CR';\ncase 6:\nreturn 'START_STRING';\ncase 7:\nreturn 'START_DECIMAL';\ncase 8:\nreturn 'START_DOT';\ncase 9:\nreturn 'START_CURLY_CLOSE';\ncase 10:\nreturn 'START_EQ';\ncase 11:\nreturn 'START_DIV';\ncase 12:\nreturn 'START_PLUS';\ncase 13:\nreturn 'START_MIN';\ncase 14:\nreturn 'START_ZERO';\ncase 15:\nreturn 'START_TEMPLATE';\ncase 16:\nreturn 'START_EXCL';\ncase 17:\nreturn 'START_PERCENT';\ncase 18:\nreturn 'START_AND';\ncase 19:\nreturn 'START_STAR';\ncase 20:\nreturn 'START_CARET';\ncase 21:\nreturn 'START_LT';\ncase 22:\nreturn 'START_GT';\ncase 23:\nreturn 'START_OR';\ncase 24:\nreturn 'START_BSLASH';\ncase 26:\nreturn 'START_ERROR';\n}\nreturn ('S<' + T(type)) + '>';\n}\n// </lexer>\n\n// <parser>\nlet ASSERT_ASI_REGEX_NEXT = false;\nfunction sansFlag(flags, flag) {\nreturn (flags | flag) ^ flag;\n}\nfunction hasAllFlags(flags1, flags2) {\nreturn (flags1 & flags2) === flags2;\n}\nfunction hasAnyFlag(flags1, flags2) {\nreturn (flags1 & flags2) !== 0;\n}\nfunction hasNoFlag(flags, flag) {\nreturn (flags & flag) === 0;\n}\nfunction Parser(code, options = {}) {\nlet {goalMode:options_goalMode = false, collectTokens:options_collectTokens = 0, webCompat:options_webCompat = true, strictMode:options_strictMode = false, astRoot:options_astRoot = null, tokenStorage:options_tokenStorage, getLexer = null, allowGlobalReturn = false, targetEsVersion = Infinity, exposeScopes:options_exposeScopes = false, astUids = false, ranges:options_ranges = false, templateNewlineNormalization = true, errorCodeFrame = true, truncCodeFrame = true, $log = console.log, $warn = console.warn, $error = console.error, sourceField = '', babelCompat = false, babelTokenCompat = false, acornCompat = false, AST_directiveNodes = false} = options;\nlet goalMode = false;\nif ((typeof options_goalMode) === 'string') {\nif (options_goalMode === 'module') goalMode = true; else if (options_goalMode === 'script') goalMode = false; else return THROW_RANGE(('Unknown goal symbol value: `' + options_goalMode) + '`', tok_getStart(), tok_getStop());\n} else {\ngoalMode = options_goalMode;\n}\nlet collectTokens = 0;\nif ((typeof options_collectTokens) === 'string') {\nif (options_collectTokens === 'all') collectTokens = 2; else if (options_collectTokens === 'solid') collectTokens = 1; else if (options_collectTokens === 'none') collectTokens = 0; else if (options_collectTokens === 'types') collectTokens = 3; else return THROW_RANGE(('Unknown collectTokens value: `' + options_collectTokens) + '`', tok_getStart(), tok_getStop());\n} else {\ncollectTokens = options_collectTokens;\n}\nlet NODE_NAME_PROPERTY = (babelCompat? 'ObjectProperty' : 'Property');\nlet NODE_NAME_METHOD_OBJECT = (babelCompat? 'ObjectMethod' : 'Property');\nlet NODE_NAME_METHOD_CLASS = (babelCompat? 'ClassMethod' : 'MethodDefinition');\nlet tok = Lexer(code, {targetEsVersion, parsingGoal:goalMode, collectTokens, returnTokens:(babelCompat? 2 : 3), webCompat:options_webCompat, gracefulErrors:false, tokenStorage:options_tokenStorage, babelTokenCompat, errorCodeFrame, truncCodeFrame, $log, $warn, $error});\nlet tok_throw = tok.throw;\nlet tok_lexError = tok.lexError;\nlet tok_asi = tok.asi;\nlet tok_prevEndColumn = tok.prevEndColumn;\nlet tok_prevEndLine = tok.prevEndLine;\nlet tok_prevEndPointer = tok.prevEndPointer;\nlet tok_currColumn = tok.currColumn;\nlet tok_currLine = tok.currLine;\nlet tok_currPointer = tok.currPointer;\nlet tok_nextToken = tok.nextToken;\nlet tok_getNlwas = tok.getNlwas;\nlet tok_getCanoN = tok.getCanoN;\nlet tok_getType = tok.getType;\nlet tok_getStart = tok.getStart;\nlet tok_getStop = tok.getStop;\nlet tok_getLine = tok.getLine;\nlet tok_getColumn = tok.getColumn;\nlet tok_sliceInput = tok.sliceInput;\nlet assertExpectedFail = '';\nlet $tp_assertExpected_start = tok_getStart();\nlet $tp_assertExpected_stop = tok_getStop();\nlet allowExponentiation = ((targetEsVersion >= 7) || (targetEsVersion === Infinity));\nlet allowTrailingFunctionComma = ((targetEsVersion >= 8) || (targetEsVersion === Infinity));\nlet allowAsyncFunctions = ((targetEsVersion >= 8) || (targetEsVersion === Infinity));\nlet allowAsyncGenerators = ((targetEsVersion >= 9) || (targetEsVersion === Infinity));\nlet allowBadEscapesInTaggedTemplates = ((targetEsVersion >= 9) || (targetEsVersion === Infinity));\nlet allowOptionalCatchBinding = ((targetEsVersion >= 10) || (targetEsVersion === Infinity));\nlet allowDynamicImport = ((targetEsVersion >= 11) || (targetEsVersion === Infinity));\nlet allowExportStarAs = ((targetEsVersion >= 11) || (targetEsVersion === Infinity));\nif (getLexer) getLexer(tok);\nfunction THROW_RANGE(desc, tokenStart, tokenStop, ...args) {\nif (arguments.length < 3) throw new Error('Expecting 3 args for THROW_RANGE, received ' + arguments.length);\nif (tokenStart > tokenStop) throw new Error(((('range should be >=0, was [' + tokenStart) + ', ') + tokenStop) + ']');\n$log('\\n');\n$log('Error in parser:', desc, 'remaining throw args;', args);\nlet fullErrmsg = ('Parser error! ' + desc) + (((tok_getType() === 2097173)? ' (at EOF)' : ''));\ntok_throw(fullErrmsg, tokenStart, tokenStop, '');\n}\nlet uid_counter = 0;\nlet _tree = {type:'Program', loc:undefined, body:[]};\nif (babelCompat) {\n_tree = {type:'Program', loc:undefined, body:[], sourceType:((goalMode === false)? 'script' : 'module'), interpreter:null};\n}\nif (acornCompat) {\n_tree = {type:'Program', loc:undefined, body:[], sourceType:((goalMode === false)? 'script' : 'module')};\n}\nlet _path = [_tree];\nlet _pnames;\nif (options_astRoot) {\noptions_astRoot.root = _tree;\noptions_astRoot.path = _path;\n}\nfunction AST_getClosedLoc($tp_first_start, $tp_first_line, $tp_first_column) {\nreturn AST_getCloseLoc($tp_first_start, $tp_first_line, $tp_first_column, tok_prevEndPointer(), tok_prevEndLine(), tok_prevEndColumn());\n}\nfunction AST_getCloseLoc(startIndex, startLine, startColumn, endIndex, endLine, endColumn) {\nif (options_ranges) {\nreturn {start:{line:startLine | 0, column:startColumn | 0}, end:{line:endLine | 0, column:endColumn | 0}, range:{start:startIndex | 0, end:endIndex | 0}, source:sourceField};\n}\nreturn {start:{line:startLine, column:startColumn}, end:{line:endLine, column:endColumn}, source:sourceField};\n}\nfunction AST_open(prop, newNode) {\nAST_setNode(prop, newNode);\n_path[_path.length] = newNode;\n}\nfunction AST_close($tp_open_start, $tp_open_line, $tp_open_column) {\nAST_set('loc', AST_getCloseLoc($tp_open_start, $tp_open_line, $tp_open_column, tok_prevEndPointer(), tok_prevEndLine(), tok_prevEndColumn()));\n_path.pop();\n}\nfunction AST_closeTemplateElement(isTemplateDouble, $tp_tick_start, $tp_tick_line, $tp_tick_column) {\nlet colEnd = tok_prevEndColumn() - 1;\nlet pointerEnd = tok_prevEndPointer();\nif (isTemplateDouble) {\n--colEnd;\n--pointerEnd;\n}\nAST_set('loc', AST_getCloseLoc($tp_tick_start, $tp_tick_line, $tp_tick_column, pointerEnd, tok_prevEndLine(), colEnd));\n_path.pop();\n}\nfunction AST_set(prop, value) {\n_path[_path.length - 1][prop] = value;\n}\nfunction AST_setNode(astProp, node) {\nif (astUids) node.$uid = uid_counter++;\nlet parentNode = _path[_path.length - 1];\nlet p = parentNode[astProp];\nif (Array.isArray(p)) {\np[p.length] = node;\n} else {\nparentNode[astProp] = node;\n}\n}\nfunction AST_setNodeDangerously(astProp, node) {\nif (astUids) node.$uid = uid_counter++;\nlet parentNode = _path[_path.length - 1];\nlet p = parentNode[astProp];\nif (Array.isArray(p)) {\np[p.length] = node;\n} else {\nparentNode[astProp] = node;\n}\n}\nfunction AST_setIdent(astProp, $tp_ident_start, $tp_ident_stop, $tp_ident_line, $tp_ident_column, $tp_ident_canon) {\nlet identNode = AST_getIdentNode($tp_ident_start, $tp_ident_stop, $tp_ident_line, $tp_ident_column, $tp_ident_canon);\nAST_setNode(astProp, identNode);\n}\nfunction AST_getIdentNode($tp_ident_start, $tp_ident_stop, $tp_ident_line, $tp_ident_column, $tp_ident_canon) {\nlet col = $tp_ident_column;\nlet line = $tp_ident_line;\nlet len = $tp_ident_stop - $tp_ident_start;\nlet colEnd = col + len;\nlet identNode = {type:'Identifier', loc:AST_getCloseLoc($tp_ident_start, line, col, $tp_ident_stop, line, colEnd), name:$tp_ident_canon};\nif (babelCompat) identNode.loc.identifierName = $tp_ident_canon;\nreturn identNode;\n}\nfunction AST_setLiteral(astProp, $tp_lit_type, $tp_lit_start, $tp_lit_stop, $tp_lit_line, $tp_lit_column, $tp_lit_canon) {\n_AST_setLiteral(astProp, $tp_lit_type, $tp_lit_start, $tp_lit_stop, $tp_lit_line, $tp_lit_column, $tp_lit_canon, false);\n}\nfunction _AST_setLiteral(astProp, $tp_lit_type, $tp_lit_start, $tp_lit_stop, $tp_lit_line, $tp_lit_column, $tp_lit_canon, fromDirective) {\nif (isStringToken($tp_lit_type)) {\nAST_setStringLiteral(astProp, $tp_lit_start, $tp_lit_stop, $tp_lit_line, $tp_lit_column, $tp_lit_canon, fromDirective);\n} else if (isNumberToken($tp_lit_type)) {\nif (isBigintToken($tp_lit_type)) {\nAST_setBigInt(astProp, $tp_lit_start, $tp_lit_stop, $tp_lit_line, $tp_lit_column);\n} else {\nAST_setNumberLiteral(astProp, $tp_lit_type, $tp_lit_start, $tp_lit_stop, $tp_lit_line, $tp_lit_column);\n}\n} else {\nAST_setRegexLiteral(astProp, $tp_lit_start, $tp_lit_stop, $tp_lit_line, $tp_lit_column);\n}\n}\nfunction AST_getStringNode($tp_string_start, $tp_string_stop, $tp_string_line, $tp_string_column, $tp_string_canon, fromDirective) {\nif (babelCompat) return AST_babelGetStringNode($tp_string_start, $tp_string_stop, $tp_string_line, $tp_string_column, $tp_string_canon, fromDirective);\nlet node = {type:'Literal', loc:AST_getCloseLoc($tp_string_start, $tp_string_line, $tp_string_column, tok_prevEndPointer(), tok_prevEndLine(), tok_prevEndColumn()), value:$tp_string_canon, raw:tok_sliceInput($tp_string_start, $tp_string_stop)};\nreturn node;\n}\nfunction AST_setStringLiteral(astProp, $tp_string_start, $tp_string_stop, $tp_string_line, $tp_string_column, $tp_string_canon, fromDirective) {\nlet stringNode = AST_getStringNode($tp_string_start, $tp_string_stop, $tp_string_line, $tp_string_column, $tp_string_canon, fromDirective);\nAST_setNode(astProp, stringNode);\n}\nfunction AST_getNumberNode($tp_number_type, $tp_number_start, $tp_number_stop, $tp_number_line, $tp_number_column) {\nif (isBigintToken($tp_number_type)) return AST_getBigIntNode($tp_number_start, $tp_number_stop, $tp_number_line, $tp_number_column);\nif (babelCompat) return AST_babelGetNumberNode($tp_number_type, $tp_number_start, $tp_number_stop, $tp_number_line, $tp_number_column);\nlet str = tok_sliceInput($tp_number_start, $tp_number_stop);\nlet value = (($tp_number_type === 4105)? parseFloat(str) : ((($tp_number_type === 4104)? parseInt(str.slice(2), 16) : ((($tp_number_type === 4106)? parseInt(str.slice(2), 2) : ((($tp_number_type === 4107)? parseInt(str.slice(2), 8) : ((((str.includes('8') || str.includes('9')))? parseFloat(str.slice(1)) : parseInt(str.slice(1), 8))))))))));\nreturn {type:'Literal', loc:AST_getCloseLoc($tp_number_start, $tp_number_line, $tp_number_column, $tp_number_stop, $tp_number_line, $tp_number_column + ($tp_number_stop - $tp_number_start)), value:value, raw:str};\n}\nfunction AST_setNumberLiteral(astProp, $tp_number_type, $tp_number_start, $tp_number_stop, $tp_number_line, $tp_number_column) {\nlet numberNode = AST_getNumberNode($tp_number_type, $tp_number_start, $tp_number_stop, $tp_number_line, $tp_number_column);\nAST_setNode(astProp, numberNode);\n}\nfunction AST_getBigIntNode($tp_number_start, $tp_number_stop, $tp_number_line, $tp_number_column) {\nif (acornCompat) return AST_acornGetBigIntNode($tp_number_start, $tp_number_stop, $tp_number_line, $tp_number_column);\nif (babelCompat) return AST_babelGetBigIntNode($tp_number_start, $tp_number_stop, $tp_number_line, $tp_number_column);\nreturn {type:'BigIntLiteral', loc:AST_getCloseLoc($tp_number_start, $tp_number_line, $tp_number_column, $tp_number_stop, $tp_number_line, $tp_number_column + ($tp_number_stop - $tp_number_start)), value:null, bigint:tok_sliceInput($tp_number_start, $tp_number_stop - 1)};\n}\nfunction AST_setBigInt(astProp, $tp_number_start, $tp_number_stop, $tp_number_line, $tp_number_column) {\nlet bigintNode = AST_getBigIntNode($tp_number_start, $tp_number_stop, $tp_number_line, $tp_number_column);\nAST_setNode(astProp, bigintNode);\n}\nfunction AST_getRegexNode($tp_regex_start, $tp_regex_stop, $tp_regex_line, $tp_regex_column) {\nif (acornCompat) return AST_acornGetRegexNode($tp_regex_start, $tp_regex_stop, $tp_regex_line, $tp_regex_column);\nif (babelCompat) return AST_babelGetRegexNode($tp_regex_start, $tp_regex_stop, $tp_regex_line, $tp_regex_column);\nlet str = tok_sliceInput($tp_regex_start, $tp_regex_stop);\nlet pos = str.lastIndexOf('/');\nlet body = str.slice(1, pos);\nlet tail = str.slice(pos + 1);\nreturn {type:'Literal', loc:AST_getCloseLoc($tp_regex_start, $tp_regex_line, $tp_regex_column, $tp_regex_stop, $tp_regex_line, $tp_regex_column + ($tp_regex_stop - $tp_regex_start)), value:null, regex:{pattern:body, flags:tail}, raw:str};\n}\nfunction AST_setRegexLiteral(astProp, $tp_regex_start, $tp_regex_stop, $tp_regex_line, $tp_regex_column) {\nlet regexNode = AST_getRegexNode($tp_regex_start, $tp_regex_stop, $tp_regex_line, $tp_regex_column);\nAST_setNode(astProp, regexNode);\n}\nfunction AST_add(prop, value) {\nlet arr = _path[_path.length - 1][prop];\narr[arr.length] = value;\n}\nfunction AST_popNode(prop) {\nlet parent = _path[_path.length - 1];\nlet p = parent[prop];\nif (Array.isArray(p)) {\nreturn p.pop();\n} else {\nreturn p;\n}\n}\nfunction AST_wrapClosedCustom(prop, newNode, newProp) {\nlet child = AST_popNode(prop);\nAST_open(prop, newNode);\nAST_set(newProp, child);\n}\nfunction AST_wrapClosedIntoArrayCustom(prop, newNode, newProp) {\nlet child = AST_popNode(prop);\nAST_open(prop, newNode);\nAST_set(newProp, [child]);\n}\nfunction AST_destruct(prop) {\nlet parent = _path[_path.length - 1];\nlet node = parent[prop];\nif (Array.isArray(node)) {\nlet last = node.length - 1;\nAST__destruct(node[last], node, last);\nreturn;\n}\nAST__destruct(node, parent, prop);\n}\nfunction AST__destruct(node, parent, astProp) {\nswitch (node.type) {\ncase 'ArrayExpression':\nnode.type = 'ArrayPattern';\nlet elements = node.elements;\nlet e = elements.length;\nfor (let i = 0;i < e;++i) {\nlet element = elements[i];\nif (element) AST__destruct(element, elements, i);\n}\nreturn;\ncase 'ObjectExpression':\nnode.type = 'ObjectPattern';\nlet properties = node.properties;\nlet n = properties.length;\nfor (let i = 0;i < n;++i) {\nif (properties[i].type === NODE_NAME_PROPERTY) {\n\n} else {\n\n}\nAST__destruct(properties[i], properties, i);\n}\nreturn;\ncase 'AssignmentExpression':\nAST__destruct(node.left, node, 'left');\nAST_destructReplaceAssignment(parent, astProp);\nreturn;\ncase NODE_NAME_PROPERTY:\nAST__destruct(node.value, node, 'value');\nreturn;\ncase 'SpreadElement':\nnode.type = 'RestElement';\nAST__destruct(node.argument, node, 'argument');\nreturn;\n}\n}\nfunction AST_destructReplaceAssignment(parentNode, prop) {\nlet oldNode = parentNode[prop];\nif (oldNode.operator !== '=') {\nreturn THROW_RANGE('The destructuring assignment should be a regular assignment', tok_getStart(), tok_getStop());\n}\nlet newNode = {type:'AssignmentPattern', loc:oldNode.loc, left:oldNode.left, right:oldNode.right};\nparentNode[prop] = newNode;\n}\nfunction AST_convertArrayToPattern($tp_eq_type, astProp) {\nif ($tp_eq_type === 49264) {\nlet node = _path[_path.length - 1][astProp];\nif (Array.isArray(node)) {\nnode = node[node.length - 1];\n}\nif (((node.type === 'ArrayExpression') || (node.type === 'ObjectExpression'))) {\nAST_destruct(astProp);\n}\n}\n}\nfunction AST_throwIfIllegalUpdateArg(astProp) {\nlet head = _path[_path.length - 1];\nlet prev = (head && head[astProp]);\nif (((!prev) || (((prev instanceof Array)? (((!prev.length) || (((prev[prev.length - 1].type !== 'Identifier') && (prev[prev.length - 1].type !== 'MemberExpression'))))) : (((prev.type !== 'Identifier') && (prev.type !== 'MemberExpression'))))))) {\nreturn THROW_RANGE('Can only increment or decrement an identifier or member expression', tok_getStart(), tok_getStop());\n}\n}\nfunction AST_patchAsyncCall($tp_async_start, $tp_async_stop, $tp_async_line, $tp_async_column, $tp_async_canon, astProp) {\nlet node = _path[_path.length - 1];\nlet args = node[astProp];\nif (args instanceof Array) args = args[0];\nif (args.type === 'SequenceExpression') args = args.expressions; else args = [args];\nif (node[astProp] instanceof Array) node[astProp] = []; else node[astProp] = undefined;\nAST_setNode(astProp, {type:'CallExpression', loc:AST_getClosedLoc($tp_async_start, $tp_async_line, $tp_async_column), callee:AST_getIdentNode($tp_async_start, $tp_async_stop, $tp_async_line, $tp_async_column, $tp_async_canon), arguments:args});\n}\nfunction AST_babelDirectives() {\nlet node = _path[_path.length - 1];\nlet dirs = [];\nAST_set('directives', dirs);\nwhile ((node.body.length && (node.body[0].directive !== undefined))) {\nlet dir = node.body.shift();\ndirs[dirs.length] = {type:'Directive', loc:dir.loc, value:dir.expression};\ndir.expression.type = 'DirectiveLiteral';\n}\n}\nfunction AST_babelParenthesizesClosed($tp_parenOpen_start, astProp) {\nlet parent = _path[_path.length - 1];\nlet child = parent[astProp];\nif (Array.isArray(child)) {\nchild = child[child.length - 1];\n}\nif (child.extra) {\nchild.extra.parenthesized = true;\nchild.extra.parenStart = $tp_parenOpen_start;\n} else {\nchild.extra = {parenthesized:true, parenStart:$tp_parenOpen_start};\n}\n}\nfunction AST_babelAddComment($tp_comment_start, $tp_comment_stop, $tp_comment_line, $tp_comment_column, $tp_comment_type) {\nif (!_path[_path.length - 1].innerComments) _path[_path.length - 1].innerComments = [];\nlet str = tok_sliceInput($tp_comment_start, $tp_comment_stop);\nlet typeName = 'CommentLine';\nlet value = '';\nif ($tp_comment_type === 1285) {\nvalue = tok_sliceInput($tp_comment_start + 2, $tp_comment_stop);\n} else if ($tp_comment_type === 1286) {\ntypeName = 'CommentBlock';\nvalue = tok_sliceInput($tp_comment_start + 2, $tp_comment_stop - 2);\n} else {\nvalue = ((str.slice(0, 3) === '--\x3e')? tok_sliceInput($tp_comment_start + 3, $tp_comment_stop) : tok_sliceInput($tp_comment_start + 4, $tp_comment_stop));\n}\nlet commentNode = {type:typeName, loc:AST_getCloseLoc($tp_comment_start, $tp_comment_line, $tp_comment_column, tok_currPointer(), tok_currLine(), tok_currColumn()), value:value};\nAST_setNode('innerComments', commentNode);\nreturn commentNode;\n}\nfunction AST_babelGetStringNode($tp_string_start, $tp_string_stop, $tp_string_line, $tp_string_column, $tp_string_canon, fromDirective) {\nlet str = tok_sliceInput($tp_string_start, $tp_string_stop);\nlet value = (fromDirective? str.slice(1, -1) : $tp_string_canon);\nreturn {type:'StringLiteral', loc:AST_getCloseLoc($tp_string_start, $tp_string_line, $tp_string_column, tok_prevEndPointer(), tok_prevEndLine(), tok_prevEndColumn()), value:value, extra:{rawValue:value, raw:str}};\n}\nfunction AST_babelGetNumberNode($tp_number_type, $tp_number_start, $tp_number_stop, $tp_number_line, $tp_number_column) {\nlet str = tok_sliceInput($tp_number_start, $tp_number_stop);\nlet value = (($tp_number_type === 4105)? parseFloat(str) : ((($tp_number_type === 4104)? parseInt(str.slice(2), 16) : ((($tp_number_type === 4106)? parseInt(str.slice(2), 2) : ((($tp_number_type === 4107)? parseInt(str.slice(2), 8) : ((((str.includes('8') || str.includes('9')))? parseFloat(str.slice(1)) : parseInt(str.slice(1), 8))))))))));\nreturn {type:'NumericLiteral', loc:AST_getCloseLoc($tp_number_start, $tp_number_line, $tp_number_column, $tp_number_stop, $tp_number_line, $tp_number_column + ($tp_number_stop - $tp_number_start)), value:value, extra:{rawValue:value, raw:str}};\n}\nfunction AST_babelGetBigIntNode($tp_number_start, $tp_number_stop, $tp_number_line, $tp_number_column) {\nlet str = tok_sliceInput($tp_number_start, $tp_number_stop - 1);\nreturn {type:'BigIntLiteral', loc:AST_getCloseLoc($tp_number_start, $tp_number_line, $tp_number_column, $tp_number_stop, $tp_number_line, $tp_number_column + ($tp_number_stop - $tp_number_start)), value:str, extra:{rawValue:str, raw:str + 'n'}};\n}\nfunction AST_babelGetRegexNode($tp_regex_start, $tp_regex_stop, $tp_regex_line, $tp_regex_column) {\nlet str = tok_sliceInput($tp_regex_start, $tp_regex_stop);\nlet pos = str.lastIndexOf('/');\nlet body = str.slice(1, pos);\nlet tail = str.slice(pos + 1);\nreturn {type:'RegExpLiteral', loc:AST_getCloseLoc($tp_regex_start, $tp_regex_line, $tp_regex_column, $tp_regex_stop, $tp_regex_line, $tp_regex_column + ($tp_regex_stop - $tp_regex_start)), pattern:body, flags:tail, extra:{rawValue:undefined, raw:str}, value:undefined};\n}\nfunction AST_acornGetBigIntNode($tp_number_start, $tp_number_stop, $tp_number_line, $tp_number_column) {\nlet strn = tok_sliceInput($tp_number_start, $tp_number_stop);\nlet str = strn.slice(0, -1);\nreturn {type:'Literal', loc:AST_getCloseLoc($tp_number_start, $tp_number_line, $tp_number_column, $tp_number_stop, $tp_number_line, $tp_number_column + ($tp_number_stop - $tp_number_start)), raw:strn, bigint:str, value:BigInt(str)};\n}\nfunction AST_acornGetRegexNode($tp_regex_start, $tp_regex_stop, $tp_regex_line, $tp_regex_column) {\nlet str = tok_sliceInput($tp_regex_start, $tp_regex_stop);\nlet pos = str.lastIndexOf('/');\nlet body = str.slice(1, pos);\nlet tail = str.slice(pos + 1);\nreturn {type:'Literal', loc:AST_getCloseLoc($tp_regex_start, $tp_regex_line, $tp_regex_column, $tp_regex_stop, $tp_regex_line, $tp_regex_column + ($tp_regex_stop - $tp_regex_start)), value:new RegExp(body, tail), regex:{pattern:body, flags:tail}, raw:str};\n}\nfunction initLexer(lexerFlags) {\nskipToStatementStart(lexerFlags);\n}\nfunction skipRex(lexerFlags) {\n_skip(lexerFlags | 4);\n}\nfunction skipDiv(lexerFlags) {\n_skip(lexerFlags);\n}\nfunction skipAny(lexerFlags) {\n_skip(lexerFlags);\n}\nfunction _skip(lexerFlags) {\ntok_nextToken(lexerFlags);\nif (tok_getType() === 2097175) {\nreturn tok_lexError();\n}\nif (!babelCompat) return;\nlet $tp_maybeComment_type = tok_getType();\nlet $tp_maybeComment_line = tok_getLine();\nlet $tp_maybeComment_column = tok_getColumn();\nlet $tp_maybeComment_start = tok_getStart();\nlet $tp_maybeComment_stop = tok_getStop();\nwhile (isCommentToken($tp_maybeComment_type)) {\ntok_nextToken(lexerFlags);\nif (tok_getType() === 2097175) {\nreturn tok_lexError();\n}\nAST_babelAddComment($tp_maybeComment_start, $tp_maybeComment_stop, $tp_maybeComment_line, $tp_maybeComment_column, $tp_maybeComment_type);\n$tp_maybeComment_type = tok_getType();\n$tp_maybeComment_line = tok_getLine();\n$tp_maybeComment_column = tok_getColumn();\n$tp_maybeComment_start = tok_getStart();\n$tp_maybeComment_stop = tok_getStop();\n}\n}\nfunction skipToParenOpenOrDie(lexerFlags) {\nskipAny(lexerFlags);\nif (tok_getType() !== 16471) {\nreturn THROW_RANGE(('Expected to parse an opening paren, found `' + tok_sliceInput(tok_getStart(), tok_getStop())) + '`', tok_getStart(), tok_getStop());\n}\n}\nfunction skipToCurlyOpenOrDie(lexerFlags) {\nskipAny(lexerFlags);\nif (tok_getType() !== 16513) {\nreturn THROW_RANGE(('Expected to parse an opening curly, found `' + tok_sliceInput(tok_getStart(), tok_getStop())) + '`', tok_getStart(), tok_getStop());\n}\n}\nfunction skipToFromOrDie(lexerFlags) {\nskipAny(lexerFlags);\nif (tok_getType() !== 2094) {\nreturn THROW_RANGE(('Next token should be the ident `from` but was `' + tok_sliceInput(tok_getStart(), tok_getStop())) + '`', tok_getStart(), tok_getStop());\n}\n}\nfunction skipToStringOrDie(lexerFlags) {\nskipAny(lexerFlags);\nif (!isStringToken(tok_getType())) {\nreturn THROW_RANGE(('Next token should be a string but was `' + tok_sliceInput(tok_getStart(), tok_getStop())) + '`', tok_getStart(), tok_getStop());\n}\n}\nfunction skipToIdentOrDie(lexerFlags) {\nskipAny(lexerFlags);\nif (!isIdentToken(tok_getType())) {\nreturn THROW_RANGE(('Next token should be an ident but was `' + tok_sliceInput(tok_getStart(), tok_getStop())) + '`', tok_getStart(), tok_getStop());\n}\n}\nfunction skipToArrowOrDie(lexerFlags) {\nskipAny(lexerFlags);\nif (tok_getType() !== 16499) {\nreturn THROW_RANGE(('Next token should be `=>` but was `' + tok_sliceInput(tok_getStart(), tok_getStop())) + '`', tok_getStart(), tok_getStop());\n}\n}\nfunction skipToAsCommaCurlyClose(lexerFlags) {\nskipAny(lexerFlags);\n}\nfunction skipToAsCommaFrom(lexerFlags) {\nskipAny(lexerFlags);\n}\nfunction skipToColonOrDie(lexerFlags) {\nskipAny(lexerFlags);\nif (tok_getType() !== 16489) {\nreturn THROW_RANGE(('Next token should be `:` but was `' + tok_sliceInput(tok_getStart(), tok_getStop())) + '`', tok_getStart(), tok_getStop());\n}\n}\nfunction skipToTargetOrDie(lexerFlags) {\nskipAny(lexerFlags);\nif (tok_getType() !== 2116) {\nreturn THROW_RANGE(('Next token should be `target` but was `' + tok_sliceInput(tok_getStart(), tok_getStop())) + '`', tok_getStart(), tok_getStop());\n}\n}\nfunction skipToStatementStart(lexerFlags) {\nskipRex(lexerFlags);\n}\nfunction skipToExpressionStart(lexerFlags) {\nskipRex(lexerFlags);\n}\nfunction skipToExpressionStartGrouped(lexerFlags) {\nskipRex(lexerFlags);\n}\nfunction skipToExpressionStartSemi(lexerFlags) {\nskipRex(lexerFlags);\n}\nfunction skipToExpressionStartSquareCloseComma(lexerFlags) {\nskipRex(lexerFlags);\n}\nfunction skipToAfterNew(lexerFlags) {\nskipRex(lexerFlags);\n}\nfunction skipToSwitchBody(lexerFlags) {\nskipAny(lexerFlags);\n}\nfunction skipToBindingStart(lexerFlags) {\nskipAny(lexerFlags);\n}\nfunction skipToBindingStartGrouped(lexerFlags) {\nskipAny(lexerFlags);\n}\nfunction skipToColonParenOpen(lexerFlags) {\nskipAny(lexerFlags);\n}\nfunction skipToIdentParenOpen(lexerFlags) {\nskipAny(lexerFlags);\n}\nfunction skipToIdentStarParenOpen(lexerFlags) {\nskipAny(lexerFlags);\n}\nfunction skipToIdentStarCurlyOpen(lexerFlags) {\nskipAny(lexerFlags);\n}\nfunction skipToIdentCurlyOpen(lexerFlags) {\nskipAny(lexerFlags);\n}\nfunction skipToIdentCurlyClose(lexerFlags) {\nskipAny(lexerFlags);\n}\nfunction skipToIdentStarCurlyOpenParenOpenString(lexerFlags) {\nskipAny(lexerFlags);\n}\nfunction skipToAwaitParenOpen(lexerFlags) {\nskipAny(lexerFlags);\n}\nfunction skipToIdentStringNumberSquareOpen(lexerFlags) {\nskipAny(lexerFlags);\n}\nfunction skipIdentSafeSlowAndExpensive(lexerFlags, leftHandSideExpression) {\nswitch (tok_getType()) {\ncase 2084:\n\ncase 2121:\n\ncase 2123:\nif (leftHandSideExpression === true) {\nreturn THROW_RANGE('A unary expression is not allowed here', tok_getStart(), tok_getStop());\n}\nskipToExpressionStart(lexerFlags);\nreturn;\ncase 2104:\nskipToAfterNew(lexerFlags);\nreturn;\ncase 2075:\nif (((goalMode === true) || ((lexerFlags & 8) !== 0))) {\nif (leftHandSideExpression === true) {\nreturn THROW_RANGE('An `await` expression is not allowed here', tok_getStart(), tok_getStop());\n}\nskipToExpressionStart(lexerFlags);\nreturn;\n}\nskipDiv(lexerFlags);\nreturn 0;\ncase 2126:\nif ((lexerFlags & 8320) !== 0) {\nif (leftHandSideExpression === true) {\nreturn THROW_RANGE('A `yield` expression is not allowed here', tok_getStart(), tok_getStop());\n}\nskipRex(lexerFlags);\nreturn;\n}\nskipDiv(lexerFlags);\nreturn;\n}\nskipDiv(lexerFlags);\n}\nfunction parseTopLevels(lexerFlags) {\nlet scoop = SCOPE_createGlobal('_parseTopLevels');\nif (options_exposeScopes) AST_set('$scope', scoop);\nlet exportedNames = new Set();\nlet exportedBindings = new Set();\nlet len;\nlet bak;\nparseBodyPartsWithDirectives(lexerFlags, scoop, exportedNames, exportedBindings, 1, 0, 0, 0, 0, 0, '', true, 'body');\nif (goalMode === true) {\nlet globalNames = scoop.names;\nexportedBindings.forEach(name => {\nif (((name !== 'default') && (((globalNames === null) || (!globalNames.has(name)))))) {\nreturn THROW_RANGE(('Exporting a name that was not bound in global: `' + name) + '`', tok_getStart(), tok_getStop());\n}\n});\n}\n}\nfunction SCOPE_createGlobal(desc) {\nlet scoop = {parent:null, type:0, names:null, dupeParamErrorStart:0, dupeParamErrorStop:0};\nif (astUids) scoop.$uid = uid_counter++;\nreturn scoop;\n}\nfunction SCOPE_addLayer(scoop, scopeType, desc) {\nlet scoopNew = {parent:scoop, type:scopeType, names:null, dupeParamErrorStart:0, dupeParamErrorStop:0};\nreturn scoopNew;\n}\nfunction SCOPE_addFuncDeclName(lexerFlags, scoop, $tp_bindingIdent_start, $tp_bindingIdent_stop, $tp_bindingIdent_canon, bindingType, fdState) {\nif (bindingType === 3) {\nSCOPE_addVarBinding(lexerFlags, scoop, $tp_bindingIdent_start, $tp_bindingIdent_stop, $tp_bindingIdent_canon, bindingType);\n} else {\nSCOPE_addLexBinding(scoop, $tp_bindingIdent_start, $tp_bindingIdent_stop, $tp_bindingIdent_canon, bindingType, fdState);\n}\n}\nfunction SCOPE_actuallyAddBinding(lexerFlags, scoop, $tp_bindingIdent_start, $tp_bindingIdent_stop, $tp_bindingIdent_canon, bindingType) {\nif (bindingType === 2) {\nSCOPE_addVarBinding(lexerFlags, scoop, $tp_bindingIdent_start, $tp_bindingIdent_stop, $tp_bindingIdent_canon, bindingType);\n} else {\nSCOPE_addLexBinding(scoop, $tp_bindingIdent_start, $tp_bindingIdent_stop, $tp_bindingIdent_canon, bindingType, 1);\n}\n}\nfunction SCOPE_addVarBinding(lexerFlags, scoop, $tp_bindingIdent_start, $tp_bindingIdent_stop, $tp_bindingIdent_canon, bindingType) {\nlet currScoop = scoop;\ndo {\nif (currScoop.names === null) {\ncurrScoop.names = new Map();\n} else if (currScoop.names.has($tp_bindingIdent_canon)) {\nlet bindingType = currScoop.names.get($tp_bindingIdent_canon);\nverifyDuplicateVarBinding(lexerFlags, bindingType, $tp_bindingIdent_start, $tp_bindingIdent_stop, $tp_bindingIdent_canon);\n}\ncurrScoop.names.set($tp_bindingIdent_canon, bindingType);\ncurrScoop = currScoop.parent;\n} while ((currScoop && (currScoop.type !== 9)));\n}\nfunction verifyDuplicateVarBinding(lexerFlags, value, $tp_bindingIdent_start, $tp_bindingIdent_stop, $tp_bindingIdent_canon) {\nswitch (value) {\ncase 0:\n\ncase 1:\n\ncase 2:\n\ncase 3:\n\ncase 4:\nreturn;\ncase 5:\n\ncase 6:\n\ncase 7:\n\ncase 8:\nreturn THROW_RANGE('Found a var binding that is duplicate of a lexical binding on the same or lower statement level', $tp_bindingIdent_start, $tp_bindingIdent_stop);\ncase 10:\nreturn THROW_RANGE(('Can not create a binding for `' + $tp_bindingIdent_canon) + '` because was already bound as a catch clause pattern binding', $tp_bindingIdent_start, $tp_bindingIdent_stop);\ncase 9:\nif (options_webCompat === false) {\nreturn THROW_RANGE(('Can not create a binding for `' + $tp_bindingIdent_canon) + '` because was already bound as a catch clause binding', $tp_bindingIdent_start, $tp_bindingIdent_stop);\n}\nreturn;\n}\n}\nfunction SCOPE_addLexBinding(scoop, $tp_bindingIdent_start, $tp_bindingIdent_stop, $tp_bindingIdent_canon, bindingType, fdState) {\nif (scoop === null) {\nreturn;\n}\nlet value = ((((scoop.names === null) || (!scoop.names.has($tp_bindingIdent_canon))))? 0 : scoop.names.get($tp_bindingIdent_canon));\nif (value !== 0) {\nif (bindingType === 1) {\nscoop.dupeParamErrorStart = $tp_bindingIdent_start + 1;\nscoop.dupeParamErrorStop = $tp_bindingIdent_stop;\n} else if (((((options_webCompat !== true) || (value !== 5))) || (fdState !== 3))) {\nreturn THROW_RANGE(('Attempted to create a lexical binding for `' + $tp_bindingIdent_canon) + '` but another binding already existed on the same level', $tp_bindingIdent_start, $tp_bindingIdent_stop);\n} else {\n\n}\n}\nif (((((scoop.type === 10) && (scoop.parent.names !== null))) && scoop.parent.names.has($tp_bindingIdent_canon))) {\nreturn THROW_RANGE(('Cannot create lexical binding for `' + $tp_bindingIdent_canon) + '` because it shadows a function parameter', $tp_bindingIdent_start, $tp_bindingIdent_stop);\n}\nif (((((scoop.type === 11) && (value !== 0))) && (bindingType === 1))) {\nscoop.dupeParamErrorStart = $tp_bindingIdent_start + 1;\nscoop.dupeParamErrorStop = $tp_bindingIdent_stop;\n}\nif (scoop.type === 6) {\nlet parentValue = ((((scoop.parent.names === null) || (!scoop.parent.names.has($tp_bindingIdent_canon))))? 0 : scoop.parent.names.get($tp_bindingIdent_canon));\nif (((parentValue === 9) || (parentValue === 10))) {\nreturn THROW_RANGE(('Can not create a lexical binding for `' + $tp_bindingIdent_canon) + '` because it shadows a catch clause binding', $tp_bindingIdent_start, $tp_bindingIdent_stop);\n}\n}\nif (scoop.names === null) scoop.names = new Map();\nscoop.names.set($tp_bindingIdent_canon, bindingType);\n}\nfunction parseDirectivePrologues(lexerFlags, astProp) {\nlet hadUseStrict = false;\nlet isStrict = (lexerFlags & 8192) === 8192;\nlet hadOctal = false;\nwhile (isStringToken(tok_getType())) {\nlet $tp_string_type = tok_getType();\nlet $tp_string_line = tok_getLine();\nlet $tp_string_column = tok_getColumn();\nlet $tp_string_start = tok_getStart();\nlet $tp_string_stop = tok_getStop();\nlet $tp_string_canon = tok_getCanoN();\nskipDiv(lexerFlags);\n_AST_setLiteral(astProp, $tp_string_type, $tp_string_start, $tp_string_stop, $tp_string_line, $tp_string_column, $tp_string_canon, true);\nlet $tp_next_start = tok_getStart();\nif (tok_getType() !== 16490) {\nparseExpressionAfterLiteral(lexerFlags, $tp_string_start, $tp_string_stop, $tp_string_line, $tp_string_column, astProp);\nif (tok_getType() !== 16490) {\nparseExpressionFromOp(lexerFlags, $tp_string_start, $tp_string_stop, $tp_string_line, $tp_string_column, 16, astProp);\nif (tok_getType() === 16480) {\n_parseExpressions(lexerFlags, $tp_string_start, $tp_string_line, $tp_string_column, 16, astProp);\n}\n}\n}\nif (tok_getStart() === $tp_next_start) {\nlet dir = tok_sliceInput($tp_string_start + 1, $tp_string_stop - 1);\nif (((!isStrict) && /(^|[^\\\\])(\\\\\\\\)*\\\\(?:0\\d|[1-9])/.test(dir))) {\nhadOctal = true;\n}\nif (dir === 'use strict') {\nhadUseStrict = true;\nlexerFlags = lexerFlags | 8192;\nif (!isStrict) {\nif (tok_getType() === 4108) {\nreturn THROW_RANGE('Illegal legacy octal literal in strict mode', tok_getStart(), tok_getStop());\n}\nif (((!hadOctal) && /(^|[^\\\\])(\\\\\\\\)*\\\\(?:0\\d|[1-9])/.test(tok_sliceInput(tok_getStart(), tok_getStop())))) {\nreturn THROW_RANGE('Octal in directive with strict mode directive or in strict mode is always illegal', tok_getStart(), tok_getStop());\n}\n}\nisStrict = true;\n}\nif ((AST_directiveNodes && (!babelCompat))) {\nAST_setNodeDangerously(astProp, {type:'Directive', loc:AST_getClosedLoc($tp_string_start, $tp_string_line, $tp_string_column), directive:dir});\nparseSemiOrAsi(lexerFlags);\n} else {\nparseSemiOrAsi(lexerFlags);\nAST_setNodeDangerously(astProp, {type:'ExpressionStatement', loc:AST_getClosedLoc($tp_string_start, $tp_string_line, $tp_string_column), expression:AST_popNode(astProp), directive:dir});\n}\n} else {\nparseSemiOrAsi(lexerFlags);\nAST_setNodeDangerously(astProp, {type:'ExpressionStatement', loc:AST_getClosedLoc($tp_string_start, $tp_string_line, $tp_string_column), expression:AST_popNode(astProp)});\nbreak;\n}\n}\nif ((hadOctal && isStrict)) {\nreturn THROW_RANGE('Octal in directive with strict mode directive or in strict mode is always illegal', tok_getStart(), tok_getStop());\n}\nreturn hadUseStrict;\n}\nfunction parseBodyPartsWithDirectives(lexerFlags, scoop, exportedNames, exportedBindings, paramsSimple, dupeParamErrorStart, dupeParamErrorStop, $tp_functionNameToVerify_type, $tp_functionNameToVerify_start, $tp_functionNameToVerify_stop, $tp_functionNameToVerify_canon, isGlobalToplevel, astProp) {\nlet wasStrict = (lexerFlags & 8192) === 8192;\nlet isStrict = wasStrict;\nlet hasUseStrict = parseDirectivePrologues(lexerFlags, 'body');\nif (hasUseStrict) {\nisStrict = true;\nif (((paramsSimple === 2) || (paramsSimple === 3))) {\nreturn THROW_RANGE('Can only declare use strict if func params are \"simple\"', tok_getStart(), tok_getStop());\n}\nif (((((!wasStrict) && ($tp_functionNameToVerify_start !== 0))) && isStrictOnlyKeyword($tp_functionNameToVerify_type, $tp_functionNameToVerify_start, $tp_functionNameToVerify_stop, $tp_functionNameToVerify_canon))) {\nreturn THROW_RANGE(('Can not use reserved keyword `' + $tp_functionNameToVerify_canon) + '` in strict mode as id for function that has a use strict directive', $tp_functionNameToVerify_start, $tp_functionNameToVerify_stop);\n}\nlexerFlags |= 8192;\n}\nif (((dupeParamErrorStart !== 0) && (((paramsSimple === 3) || isStrict)))) {\nreturn THROW_RANGE('Function had duplicate params', dupeParamErrorStart - 1, dupeParamErrorStop);\n}\nwhile (((tok_getType() !== 2097173) && (tok_getType() !== 16517))) {\nparseBodyPart(lexerFlags, scoop, null, exportedNames, exportedBindings, isGlobalToplevel, false, 4, null, astProp);\n}\nif (babelCompat) AST_babelDirectives();\n}\nfunction wrapLabelSet(labelSet, desc) {\nlet set = {parentLabels:labelSet, statementLabels:new Set(), iterationLabels:null};\nreturn set;\n}\nfunction parseStatementHeader(lexerFlags, headProp) {\nlet $tp_openParan_start = tok_getStart();\nskipToExpressionStart(lexerFlags);\nparseExpressions(((lexerFlags | 4096) | 1792) ^ 1792, headProp);\nif (tok_getType() !== 16472) {\nreturn THROW_RANGE(('Missing closing paren of statement header, found `' + tok_sliceInput(tok_getStart(), tok_getStop())) + '` instead', $tp_openParan_start, tok_getStop());\n}\nskipToStatementStart(lexerFlags);\n}\nfunction parseSemiOrAsi(lexerFlags) {\nif (tok_getType() === 16490) {\nskipToStatementStart(lexerFlags);\nreturn;\n}\nif (((((tok_getType() === 16517) || (tok_getNlwas() === true))) || (tok_getType() === 2097173))) {\ntok_asi();\n} else {\n$log('parse error at curent token');\nreturn THROW_RANGE('Unable to ASI', tok_getStart(), tok_getStop());\n}\n}\nfunction parseNestedBodyPart(lexerFlags, scoop, labelSet, isLabelled, fdState, nestedLabels, astProp) {\nparseBodyPart(lexerFlags, scoop, labelSet, undefined, undefined, false, isLabelled, fdState, nestedLabels, astProp);\n}\nfunction parseBodyPart(lexerFlags, scoop, labelSet, exportedNames, exportedBindings, isGlobalToplevel, isLabelled, fdState, nestedLabels, astProp) {\nif (isIdentToken(tok_getType())) {\nparseIdentStatement(lexerFlags, scoop, labelSet, exportedNames, exportedBindings, isGlobalToplevel, isLabelled, fdState, nestedLabels, astProp);\nreturn;\n}\nif (isPunctuatorToken(tok_getType())) {\nparsePunctuatorStatement(lexerFlags, scoop, labelSet, astProp);\nreturn;\n}\nif (isNumberToken(tok_getType())) {\nparseFromNumberStatement(lexerFlags, astProp);\nreturn;\n}\nif (isStringToken(tok_getType())) {\nparseFromStringStatement(lexerFlags, astProp);\nreturn;\n}\nif (isTickToken(tok_getType())) {\nparseTickStatement(lexerFlags, astProp);\nreturn;\n}\nif (isRegexToken(tok_getType())) {\nparseFromRegexStatement(lexerFlags, astProp);\nreturn;\n}\nTHROW_RANGE('Unexpected EOF', tok_getStart(), tok_getStop());\n}\nfunction parseFunctionDeclaration(lexerFlags, scoop, isFuncDecl, isRealFuncExpr, $tp_async_type, $tp_astRange_start, $tp_astRange_line, $tp_astRange_column, $tp_funcHead_start, $tp_funcHead_stop, optionalIdent, isLabelled, fdState, astProp) {\nskipToIdentStarParenOpen(lexerFlags);\nlet $tp_star_type = 0;\nif (tok_getType() === 82009) {\n$tp_star_type = 82009;\n$tp_funcHead_stop = tok_getStop();\nskipToIdentParenOpen(lexerFlags);\nif ((($tp_async_type === 2074) && (!allowAsyncGenerators))) {\nreturn THROW_RANGE('Async generators are not supported by the currently targeted language version, they were introduced in ES9/ES2018', $tp_funcHead_start, $tp_funcHead_stop);\n}\n}\nif (isLabelled === true) {\nif (fdState === 1) {\nreturn THROW_RANGE('A \"labelled function declaration\" is not allowed in this situation', $tp_funcHead_start, $tp_funcHead_stop);\n}\nif ($tp_async_type === 2074) {\nreturn THROW_RANGE('A \"labelled function declaration\" can not be async', $tp_funcHead_start, $tp_funcHead_stop);\n}\nif ($tp_star_type === 82009) {\nreturn THROW_RANGE('A \"labelled function declaration\" can not be a generator', $tp_funcHead_start, $tp_funcHead_stop);\n}\nif (((options_webCompat === false) || ((lexerFlags & 8192) === 8192))) {\nreturn THROW_RANGE('A \"labelled function declaration\" is only allowed in sloppy web compat mode', $tp_funcHead_start, $tp_funcHead_stop);\n}\n} else if (fdState === 2) {\nif ($tp_async_type === 2074) {\nreturn THROW_RANGE('An async function declaration in web compat mode is still not allowed as `if-else` child, only plain func decls are allowed there', $tp_funcHead_start, $tp_funcHead_stop);\n}\nif ($tp_star_type === 82009) {\nreturn THROW_RANGE('A generator function declaration in web compat mode is still not allowed as `if-else` child, only plain func decls are allowed there', $tp_funcHead_start, $tp_funcHead_stop);\n}\nif (((options_webCompat === false) || ((lexerFlags & 8192) === 8192))) {\nreturn THROW_RANGE('A function declaration can only be the child of an `if`/`else` in sloppy web compat mode', $tp_funcHead_start, $tp_funcHead_stop);\n}\nscoop = SCOPE_addLayer(scoop, 12, 'special \"fake-block\" function statement for label');\n} else if (((isFuncDecl === true) && (fdState === 1))) {\nreturn THROW_RANGE('Cannot parse a function declaration here, only expecting statements here', $tp_funcHead_start, $tp_funcHead_stop);\n}\nreturn parseFunctionAfterKeyword(lexerFlags, scoop, isFuncDecl, isRealFuncExpr, optionalIdent, false, false, $tp_async_type, $tp_star_type, 0, 0, $tp_astRange_start, $tp_astRange_line, $tp_astRange_column, fdState, astProp);\n}\nfunction parseFunctionExpression(lexerFlags, $tp_function_start, $tp_function_line, $tp_function_column, astProp) {\nif (tok_getType() === 82009) {\nreturn parseGeneratorFunctionExpression(lexerFlags, $tp_function_start, $tp_function_line, $tp_function_column, astProp);\n}\nparseFunctionAfterKeyword(lexerFlags, null, false, true, false, false, false, 0, 0, 0, 0, $tp_function_start, $tp_function_line, $tp_function_column, 1, astProp);\n}\nfunction parseGeneratorFunctionExpression(lexerFlags, $tp_function_start, $tp_function_line, $tp_function_column, astProp) {\nskipToIdentParenOpen(lexerFlags);\nparseFunctionAfterKeyword(lexerFlags, null, false, true, false, false, false, 0, 82009, 0, 0, $tp_function_start, $tp_function_line, $tp_function_column, 1, astProp);\n}\nfunction parseAsyncFunctionDecl(lexerFlags, $tp_async_start, $tp_async_line, $tp_async_column, fromStmtOrExpr, scoop, isExport, exportedBindings, isLabelled, fdState, astProp) {\nlet $tp_function_stop = tok_getStop();\nlet canonName = parseFunctionDeclaration(lexerFlags, scoop, ((fromStmtOrExpr === 1)? false : true), ((fromStmtOrExpr === 1)? true : false), 2074, $tp_async_start, $tp_async_line, $tp_async_column, $tp_async_start, $tp_function_stop, ((((isExport === true) || (fromStmtOrExpr === 1)))? true : false), isLabelled, fdState, astProp);\nif (isExport === true) {\naddBindingToExports(exportedBindings, canonName);\n}\nreturn 16;\n}\nfunction parseFunctionAfterKeyword(lexerFlags, outerScoop, isFuncDecl, isRealFuncExpr, optionalIdent, isClassConstructor, isMethod, $tp_async_type, $tp_star_type, $tp_get_type, $tp_set_type, $tp_astRange_start, $tp_astRange_line, $tp_astRange_column, fdState, astProp) {\nif ((babelCompat && (isMethod !== false))) {\nAST_set('generator', $tp_star_type === 82009);\nAST_set('async', $tp_async_type === 2074);\n} else if (acornCompat) {\nif (allowAsyncFunctions) {\nAST_open(astProp, {type:((isFuncDecl === true)? 'FunctionDeclaration' : 'FunctionExpression'), loc:undefined, generator:$tp_star_type === 82009, async:$tp_async_type === 2074, expression:false, id:undefined, params:[], body:undefined});\n} else {\nAST_open(astProp, {type:((isFuncDecl === true)? 'FunctionDeclaration' : 'FunctionExpression'), loc:undefined, generator:$tp_star_type === 82009, expression:false, id:undefined, params:[], body:undefined});\n}\n} else {\nAST_open(astProp, {type:((isFuncDecl === true)? 'FunctionDeclaration' : 'FunctionExpression'), loc:undefined, generator:$tp_star_type === 82009, async:$tp_async_type === 2074, id:undefined, params:[], body:undefined});\n}\nlet innerScoop = SCOPE_createGlobal('parseFunctionAfterKeyword_main_func_scope');\nlet $tp_functionNameToVerify_type = 0;\nlet $tp_functionNameToVerify_line = 0;\nlet $tp_functionNameToVerify_column = 0;\nlet $tp_functionNameToVerify_start = 0;\nlet $tp_functionNameToVerify_stop = 0;\nlet $tp_functionNameToVerify_canon = '';\nlet canonName = '';\nif (isIdentToken(tok_getType())) {\n$tp_functionNameToVerify_type = tok_getType();\n$tp_functionNameToVerify_line = tok_getLine();\n$tp_functionNameToVerify_column = tok_getColumn();\n$tp_functionNameToVerify_start = tok_getStart();\n$tp_functionNameToVerify_stop = tok_getStop();\n$tp_functionNameToVerify_canon = tok_getCanoN();\nlet bindingFlags = ((lexerFlags | 136) ^ 136) | getFuncIdentAsyncGenState(isRealFuncExpr, lexerFlags, $tp_star_type, $tp_async_type);\nlet nameBindingType = ((((((isFuncDecl === true) && (fdState === 4))) && ((((lexerFlags & 256) === 0) || (goalMode === false)))))? 3 : 5);\ncanonName = $tp_functionNameToVerify_canon;\nfatalBindingIdentCheck($tp_functionNameToVerify_type, $tp_functionNameToVerify_start, $tp_functionNameToVerify_stop, $tp_functionNameToVerify_canon, nameBindingType, bindingFlags);\nif (isFuncDecl === true) {\nSCOPE_addFuncDeclName(lexerFlags, outerScoop, $tp_functionNameToVerify_start, $tp_functionNameToVerify_stop, canonName, nameBindingType, fdState);\n}\ninnerScoop = SCOPE_addLayer(innerScoop, 9, 'parseFunctionAfterKeyword_hide_func_name');\nskipToParenOpenOrDie(lexerFlags);\nAST_setIdent('id', $tp_functionNameToVerify_start, $tp_functionNameToVerify_stop, $tp_functionNameToVerify_line, $tp_functionNameToVerify_column, $tp_functionNameToVerify_canon);\n} else if (((isFuncDecl === true) && (optionalIdent === false))) {\nreturn THROW_RANGE('Function decl missing required ident', tok_getStart(), tok_getStop());\n} else {\nAST_set('id', null);\n}\nlexerFlags = resetLexerFlagsForFuncAndArrow(lexerFlags, $tp_star_type, $tp_async_type, false);\nif (isClassConstructor === true) {\nlexerFlags |= 16;\n} else {\nlexerFlags = (lexerFlags | 16400) ^ 16400;\n}\nif (isMethod === true) lexerFlags |= 32768; else lexerFlags = (lexerFlags | 32768) ^ 32768;\nparseFunctionFromParams(lexerFlags, innerScoop, (($tp_async_type === 0)? 6 : 5), ((isFuncDecl === true)? 2 : 1), $tp_functionNameToVerify_type, $tp_functionNameToVerify_start, $tp_functionNameToVerify_stop, $tp_functionNameToVerify_canon, isMethod, $tp_get_type, $tp_set_type);\nif (((!babelCompat) || (isMethod === false))) {\nAST_close($tp_astRange_start, $tp_astRange_line, $tp_astRange_column);\n}\nreturn canonName;\n}\nfunction getFuncIdentGeneratorState(isRealFuncExpr, enclosingScopeFlags, $tp_star_type) {\nif ((enclosingScopeFlags & 8192) === 8192) return 128;\nif (isRealFuncExpr === true) return (($tp_star_type === 82009)? 128 : 0);\nreturn (((enclosingScopeFlags & 128) !== 0)? 128 : 0);\n}\nfunction getFuncIdentAsyncState(isRealFuncExpr, enclosingScopeFlags, $tp_async_type) {\nif (goalMode === true) return 8;\nif (isRealFuncExpr === true) return (($tp_async_type === 2074)? 8 : 0);\nreturn (((enclosingScopeFlags & 8) !== 0)? 8 : 0);\n}\nfunction getFuncIdentAsyncGenState(isRealFuncExpr, enclosingScopeFlags, $tp_star_type, $tp_async_type) {\nreturn getFuncIdentGeneratorState(isRealFuncExpr, enclosingScopeFlags, $tp_star_type) | getFuncIdentAsyncState(isRealFuncExpr, enclosingScopeFlags, $tp_async_type);\n}\nfunction resetLexerFlagsForFuncAndArrow(lexerFlags, $tp_star_type, $tp_async_type, funcType) {\nlexerFlags = lexerFlags & 59392;\nif ($tp_async_type === 2074) {\nlexerFlags |= 8;\n}\nif ($tp_star_type === 82009) {\nlexerFlags |= 128;\n}\nif (funcType === false) lexerFlags = lexerFlags | 2;\nreturn lexerFlags;\n}\nfunction parseFunctionFromParams(lexerFlags, scoop, bindingFrom, expressionState, $tp_functionNameToVerify_type, $tp_functionNameToVerify_start, $tp_functionNameToVerify_stop, $tp_functionNameToVerify_canon, isMethod, $tp_get_type, $tp_set_type) {\nlet paramScoop = SCOPE_addLayer(scoop, 3, 'parseFunctionFromParams(arg)');\nlet paramsSimple = parseFuncArguments(lexerFlags | 4096, paramScoop, bindingFrom, $tp_get_type, $tp_set_type);\nlet dupeParamErrorStart = paramScoop.dupeParamErrorStart;\nlet dupeParamErrorStop = paramScoop.dupeParamErrorStop;\nif (((isMethod === true) && (dupeParamErrorStart !== 0))) {\nreturn THROW_RANGE('Method had duplicate params', dupeParamErrorStart - 1, dupeParamErrorStop);\n}\nlet finalFuncScope = SCOPE_addLayer(paramScoop, 10, 'parseFunctionFromParams(body)');\nif (options_exposeScopes) AST_set('$scope', finalFuncScope);\nparseFunctionBody(lexerFlags, finalFuncScope, expressionState, paramsSimple, dupeParamErrorStart, dupeParamErrorStop, $tp_functionNameToVerify_type, $tp_functionNameToVerify_start, $tp_functionNameToVerify_stop, $tp_functionNameToVerify_canon, false);\n}\nfunction parseFuncArguments(lexerFlags, scoop, bindingFrom, $tp_get_type, $tp_set_type) {\nlexerFlags = lexerFlags | 64;\nif (tok_getType() !== 16471) {\nreturn THROW_RANGE('Must have func arguments next but did not find `(`', tok_getStart(), tok_getStop());\n}\nskipToBindingStartGrouped(lexerFlags);\nif (tok_getType() === 16472) {\nif ($tp_set_type === 2112) {\nreturn THROW_RANGE('Setters must have exactly one parameter', tok_getStart(), tok_getStop());\n}\nskipToCurlyOpenOrDie(lexerFlags);\nreturn 1;\n}\nif ($tp_get_type === 2096) {\nreturn THROW_RANGE('Getters can not have any parameters', tok_getStart(), tok_getStop());\n}\nlet paramsSimple = parseBindings(lexerFlags, scoop, 1, bindingFrom, false, $tp_set_type, undefined, undefined, 'params');\nAST_destruct('params');\nif (tok_getType() !== 16472) {\nreturn THROW_RANGE(('Missing function param definition closing parenthesis, found `' + tok_sliceInput(tok_getStart(), tok_getStop())) + '` instead', tok_getStart(), tok_getStop());\n}\nskipToCurlyOpenOrDie(lexerFlags);\nreturn paramsSimple;\n}\nfunction parseFunctionBody(lexerFlags, scoop, blockType, paramsSimple, dupeParamErrorStart, dupeParamErrorStop, $tp_functionNameToVerify_type, $tp_functionNameToVerify_start, $tp_functionNameToVerify_stop, $tp_functionNameToVerify_canon, isArrow) {\nlet lexerFlagsNoTemplate = (lexerFlags | 7936) ^ 7936;\nlet $tp_curly_line = tok_getLine();\nlet $tp_curly_column = tok_getColumn();\nlet $tp_curly_start = tok_getStart();\nskipToStatementStart(lexerFlagsNoTemplate);\nAST_open('body', {type:'BlockStatement', loc:undefined, body:[]});\nif (options_exposeScopes) AST_set('$scope', scoop);\nparseBodyPartsWithDirectives(lexerFlagsNoTemplate, scoop, undefined, undefined, paramsSimple, dupeParamErrorStart, dupeParamErrorStop, $tp_functionNameToVerify_type, $tp_functionNameToVerify_start, $tp_functionNameToVerify_stop, $tp_functionNameToVerify_canon, false, 'body');\nif (tok_getType() !== 16517) {\nreturn THROW_RANGE(('Missing function body closing curly, found `' + tok_sliceInput(tok_getStart(), tok_getStop())) + '` instead', tok_getStart(), tok_getStop());\n}\nif (isArrow) {\nskipRex(lexerFlags);\nif (((tok_getNlwas() === true) && isRegexToken(tok_getType()))) {\nASSERT_ASI_REGEX_NEXT = true;\n}\n} else if (blockType === 1) {\nskipDiv(lexerFlags);\n} else {\nskipToStatementStart(lexerFlags);\n}\nAST_close($tp_curly_start, $tp_curly_line, $tp_curly_column);\nif (tok_getType() === 49264) {\nreturn THROW_RANGE('Object destructuring is not allowed at the start of statement or arrow body, must wrap the object in parenthesis for that to work', tok_getStart(), tok_getStop());\n}\n}\nfunction parseIdentStatement(lexerFlags, scoop, labelSet, exportedNames, exportedBindings, isGlobalToplevel, isLabelled, fdState, nestedLabels, astProp) {\nlet $tp_ident_type = tok_getType();\nlet $tp_ident_line = tok_getLine();\nlet $tp_ident_column = tok_getColumn();\nlet $tp_ident_start = tok_getStart();\nlet $tp_ident_stop = tok_getStop();\nlet $tp_ident_canon = tok_getCanoN();\nswitch ($tp_ident_type) {\ncase 2074:\nskipDiv(lexerFlags);\nif (tok_getType() === 16489) {\nreturn parseLabeledStatementInstead(lexerFlags, scoop, labelSet, 2074, $tp_ident_start, $tp_ident_stop, $tp_ident_line, $tp_ident_column, $tp_ident_canon, fdState, nestedLabels, astProp);\n}\nparseAsyncStatement(lexerFlags, scoop, $tp_ident_start, $tp_ident_stop, $tp_ident_line, $tp_ident_column, $tp_ident_canon, false, undefined, isLabelled, fdState, astProp);\nreturn;\ncase 2076:\nparseBreakStatement(lexerFlags, labelSet, astProp);\nreturn;\ncase 2079:\nparseClassDeclaration(lexerFlags, scoop, false, isLabelled, fdState, astProp);\nreturn;\ncase 2080:\nparseConstStatement(lexerFlags, scoop, isLabelled, fdState, astProp);\nreturn;\ncase 2081:\nparseContinueStatement(lexerFlags, labelSet, astProp);\nreturn;\ncase 2082:\nparseDebuggerStatement(lexerFlags, astProp);\nreturn;\ncase 2085:\nparseDoStatement(lexerFlags, scoop, labelSet, astProp);\nreturn;\ncase 2089:\nparseExportStatement(lexerFlags, scoop, exportedNames, exportedBindings, isGlobalToplevel, astProp);\nreturn;\ncase 2093:\nparseForStatement(lexerFlags, scoop, labelSet, astProp);\nreturn;\ncase 2095:\n;\nparseFunctionDeclaration(lexerFlags, scoop, true, false, 0, $tp_ident_start, $tp_ident_line, $tp_ident_column, $tp_ident_start, $tp_ident_stop, false, isLabelled, fdState, astProp);\nreturn;\ncase 2097:\nparseIfStatement(lexerFlags, scoop, labelSet, astProp);\nreturn;\ncase 2099:\nparseImportDeclaration(lexerFlags, scoop, isGlobalToplevel, astProp);\nreturn;\ncase 2103:\nif (((((isLabelled === true) || (fdState === 1))) || (fdState === 2))) {\nparseLetExpressionStatement(lexerFlags, scoop, labelSet, fdState, nestedLabels, astProp);\n} else {\nparseLetDeclaration(lexerFlags, $tp_ident_start, $tp_ident_line, $tp_ident_column, scoop, labelSet, fdState, nestedLabels, astProp);\n}\nreturn;\ncase 2111:\nparseReturnStatement(lexerFlags, astProp);\nreturn;\ncase 2115:\nparseSwitchStatement(lexerFlags, scoop, labelSet, astProp);\nreturn;\ncase 2118:\nparseThrowStatement(lexerFlags, astProp);\nreturn;\ncase 2120:\nparseTryStatement(lexerFlags, scoop, labelSet, astProp);\nreturn;\ncase 2122:\nparseVarStatement(lexerFlags, scoop, astProp);\nreturn;\ncase 2124:\nparseWhileStatement(lexerFlags, scoop, labelSet, astProp);\nreturn;\ncase 2125:\nparseWithStatement(lexerFlags, scoop, labelSet, astProp);\nreturn;\n}\nparseIdentLabelOrExpressionStatement(lexerFlags, scoop, labelSet, fdState, nestedLabels, astProp);\n}\nfunction parseFromNumberStatement(lexerFlags, astProp) {\nlet $tp_number_type = tok_getType();\nlet $tp_number_line = tok_getLine();\nlet $tp_number_column = tok_getColumn();\nlet $tp_number_start = tok_getStart();\nlet $tp_number_stop = tok_getStop();\nskipDiv(lexerFlags);\nAST_open(astProp, {type:'ExpressionStatement', loc:undefined, expression:AST_getNumberNode($tp_number_type, $tp_number_start, $tp_number_stop, $tp_number_line, $tp_number_column)});\nparseExpressionAfterLiteral(lexerFlags, $tp_number_start, $tp_number_stop, $tp_number_line, $tp_number_column, 'expression');\nif (tok_getType() === 16480) {\n_parseExpressions(lexerFlags, $tp_number_start, $tp_number_line, $tp_number_column, 16, 'expression');\n}\nparseSemiOrAsi(lexerFlags);\nAST_close($tp_number_start, $tp_number_line, $tp_number_column);\n}\nfunction parseFromStringStatement(lexerFlags, astProp) {\nlet $tp_string_line = tok_getLine();\nlet $tp_string_column = tok_getColumn();\nlet $tp_string_start = tok_getStart();\nlet $tp_string_stop = tok_getStop();\nlet $tp_string_canon = tok_getCanoN();\nskipDiv(lexerFlags);\nAST_open(astProp, {type:'ExpressionStatement', loc:undefined, expression:AST_getStringNode($tp_string_start, $tp_string_stop, $tp_string_line, $tp_string_column, $tp_string_canon, false)});\nparseExpressionAfterLiteral(lexerFlags, $tp_string_start, $tp_string_stop, $tp_string_line, $tp_string_column, 'expression');\nif (tok_getType() === 16480) {\n_parseExpressions(lexerFlags, $tp_string_start, $tp_string_line, $tp_string_column, 16, 'expression');\n}\nparseSemiOrAsi(lexerFlags);\nAST_close($tp_string_start, $tp_string_line, $tp_string_column);\n}\nfunction parseFromRegexStatement(lexerFlags, astProp) {\nlet $tp_regex_line = tok_getLine();\nlet $tp_regex_column = tok_getColumn();\nlet $tp_regex_start = tok_getStart();\nlet $tp_regex_stop = tok_getStop();\nskipDiv(lexerFlags);\nAST_open(astProp, {type:'ExpressionStatement', loc:undefined, expression:AST_getRegexNode($tp_regex_start, $tp_regex_stop, $tp_regex_line, $tp_regex_column)});\nparseExpressionAfterLiteral(lexerFlags, $tp_regex_start, $tp_regex_stop, $tp_regex_line, $tp_regex_column, 'expression');\nif (tok_getType() === 16480) {\n_parseExpressions(lexerFlags, $tp_regex_start, $tp_regex_line, $tp_regex_column, 16, 'expression');\n}\nparseSemiOrAsi(lexerFlags);\nAST_close($tp_regex_start, $tp_regex_line, $tp_regex_column);\n}\nfunction parseTickStatement(lexerFlags, astProp) {\nlet $tp_tick_line = tok_getLine();\nlet $tp_tick_column = tok_getColumn();\nlet $tp_tick_start = tok_getStart();\nlet $tp_tick_stop = tok_getStop();\nAST_open(astProp, {type:'ExpressionStatement', loc:undefined, expression:undefined});\nparseTickExpression(lexerFlags, $tp_tick_start, $tp_tick_stop, $tp_tick_line, $tp_tick_column, 'expression');\nparseExpressionAfterLiteral(lexerFlags, $tp_tick_start, $tp_tick_stop, $tp_tick_line, $tp_tick_column, 'expression');\nif (tok_getType() === 16480) {\n_parseExpressions(lexerFlags, $tp_tick_start, $tp_tick_line, $tp_tick_column, 16, 'expression');\n}\nparseSemiOrAsi(lexerFlags);\nAST_close($tp_tick_start, $tp_tick_line, $tp_tick_column);\n}\nfunction parseAsyncStatement(lexerFlags, scoop, $tp_async_start, $tp_async_stop, $tp_async_line, $tp_async_column, $tp_async_canon, isExport, exportedBindings, isLabelled, fdState, astProp) {\n_parseAsync(lexerFlags, scoop, 2, $tp_async_start, $tp_async_stop, $tp_async_line, $tp_async_column, $tp_async_canon, 4, isExport, true, exportedBindings, isLabelled, fdState, false, astProp);\n}\nfunction parseAsyncExpression(lexerFlags, $tp_async_start, $tp_async_stop, $tp_async_line, $tp_async_column, $tp_async_canon, isNewArg, isExport, allowAssignment, leftHandSideExpression, astProp) {\nreturn _parseAsync(lexerFlags, null, 1, $tp_async_start, $tp_async_stop, $tp_async_line, $tp_async_column, $tp_async_canon, isNewArg, isExport, allowAssignment, undefined, false, 1, leftHandSideExpression, astProp);\n}\nfunction _parseAsync(lexerFlags, scoop, fromStmtOrExpr, $tp_async_start, $tp_async_stop, $tp_async_line, $tp_async_column, $tp_async_canon, isNewArg, isExport, allowAssignment, exportedBindings, isLabelled, fdState, leftHandSideExpression, astProp) {\nif (!allowAsyncFunctions) {\nif (((tok_getType() === 2095) && (!tok_getNlwas()))) {\nreturn THROW_RANGE('Async functions are not supported in the currently targeted version, they are >= ES8 / ES2017', $tp_async_start, tok_getStop());\n}\nreturn parseExpressionAfterAsyncAsVarName(lexerFlags, fromStmtOrExpr, $tp_async_start, $tp_async_stop, $tp_async_line, $tp_async_column, $tp_async_canon, isNewArg, allowAssignment, astProp);\n}\nlet newlineAfterAsync = tok_getNlwas() === true;\nlet $tp_afterAsync_type = tok_getType();\nif (isIdentToken($tp_afterAsync_type)) {\nlet $tp_ident_stop = tok_getStop();\nif (newlineAfterAsync) {\nreturn parseExpressionAfterAsyncAsVarName(lexerFlags, fromStmtOrExpr, $tp_async_start, $tp_async_stop, $tp_async_line, $tp_async_column, $tp_async_canon, isNewArg, allowAssignment, astProp);\n}\nif ($tp_afterAsync_type === 2095) {\nif (leftHandSideExpression === true) {\nreturn THROW_RANGE('An async function expression is not allowed here', $tp_async_start, $tp_ident_stop);\n}\nreturn parseAsyncFunctionDecl(lexerFlags, $tp_async_start, $tp_async_line, $tp_async_column, fromStmtOrExpr, scoop, isExport, exportedBindings, isLabelled, fdState, astProp);\n}\nif ((($tp_afterAsync_type === 67636) || ($tp_afterAsync_type === 67637))) {\nreturn parseExpressionAfterAsyncAsVarName(lexerFlags, fromStmtOrExpr, $tp_async_start, $tp_async_stop, $tp_async_line, $tp_async_column, $tp_async_canon, isNewArg, allowAssignment, astProp);\n}\nif (isNewArg === 3) {\nreturn THROW_RANGE('Cannot apply `new` to an (async) arrow', $tp_async_start, $tp_ident_stop);\n}\nif (leftHandSideExpression === true) {\nreturn THROW_RANGE('An async function expression is not allowed here', $tp_async_start, $tp_ident_stop);\n}\nparseParenlessArrowAfterAsync(lexerFlags, fromStmtOrExpr, allowAssignment, $tp_async_start, $tp_async_line, $tp_async_column, astProp);\nreturn 16;\n}\nif ($tp_afterAsync_type === 16471) {\nif (isNewArg === 3) {\nAST_setIdent('callee', $tp_async_start, $tp_async_stop, $tp_async_line, $tp_async_column, $tp_async_canon);\nreturn 32;\n}\nif (fromStmtOrExpr === 2) {\nAST_open(astProp, {type:'ExpressionStatement', loc:undefined, expression:undefined});\nastProp = 'expression';\n}\nlet r = parseGroupToplevels(lexerFlags, fromStmtOrExpr, allowAssignment, 2074, $tp_async_start, $tp_async_stop, $tp_async_line, $tp_async_column, $tp_async_canon, (newlineAfterAsync? true : false), leftHandSideExpression, astProp);\nif (fromStmtOrExpr === 2) {\nAST_close($tp_async_start, $tp_async_line, $tp_async_column);\n}\nreturn r;\n}\nreturn parseExpressionAfterAsyncAsVarName(lexerFlags, fromStmtOrExpr, $tp_async_start, $tp_async_stop, $tp_async_line, $tp_async_column, $tp_async_canon, isNewArg, allowAssignment, astProp);\n}\nfunction isAssignable(state) {\nreturn (state & 32) === 32;\n}\nfunction notAssignable(state) {\nreturn (state & 16) === 16;\n}\nfunction setAssignable(state) {\nreturn ((state | 32) | 16) ^ 16;\n}\nfunction setNotAssignable(state) {\nreturn ((state | 32) | 16) ^ 32;\n}\nfunction mergeAssignable(override, state) {\nreturn override | (((state | 16) | 32) ^ 48);\n}\nfunction parseAwait(lexerFlags, $tp_await_type, $tp_await_start, $tp_await_stop, $tp_await_line, $tp_await_column, $tp_await_canon, isNewArg, allowAssignment, astProp) {\nif ((lexerFlags & 8) !== 0) {\nreturn parseAwaitKeyword(lexerFlags, $tp_await_start, $tp_await_stop, $tp_await_line, $tp_await_column, isNewArg, astProp);\n}\nif (goalMode === false) {\nreturn parseAwaitVar(lexerFlags, $tp_await_start, $tp_await_stop, $tp_await_line, $tp_await_column, $tp_await_type, $tp_await_canon, isNewArg, allowAssignment, astProp);\n}\nreturn THROW_RANGE('Cannot use `await` as var when goal=module but found `await` outside an async function', tok_getStart(), tok_getStart() + 1);\n}\nfunction parseAwaitKeyword(lexerFlags, $tp_await_start, $tp_await_stop, $tp_await_line, $tp_await_column, isNewArg, astProp) {\nif (isNewArg === 3) {\nreturn THROW_RANGE('Cannot `await` as the arg of `new`', $tp_await_start, $tp_await_stop);\n}\nif ((lexerFlags & 64) === 64) {\nreturn THROW_RANGE('Await is illegal as default arg value', $tp_await_start, $tp_await_stop);\n}\nAST_open(astProp, {type:'AwaitExpression', loc:undefined, argument:undefined});\nparseValue(lexerFlags, false, 4, false, 'argument');\nif (tok_getType() === 82010) {\nreturn THROW_RANGE('The lhs of ** can not be this kind of unary expression (syntactically not allowed, you have to wrap something)', tok_getStart(), tok_getStop());\n}\nAST_close($tp_await_start, $tp_await_line, $tp_await_column);\nreturn 80;\n}\nfunction parseAwaitVar(lexerFlags, $tp_await_start, $tp_await_stop, $tp_await_line, $tp_await_column, $tp_await_type, $tp_await_canon, isNewArg, allowAssignment, astProp) {\nlet assignable = parseIdentOrParenlessArrow(lexerFlags, $tp_await_type, $tp_await_start, $tp_await_stop, $tp_await_line, $tp_await_column, $tp_await_canon, 32, allowAssignment, astProp);\nassignable = parseValueTail(lexerFlags, $tp_await_start, $tp_await_line, $tp_await_column, assignable, isNewArg, false, astProp);\nreturn assignable | 64;\n}\nfunction parseBlockStatement(lexerFlags, scoop, labelSet, astProp) {\nlet lexerFlagsNoTemplate = (lexerFlags | 6144) ^ 6144;\nlet $tp_curly_line = tok_getLine();\nlet $tp_curly_column = tok_getColumn();\nlet $tp_curly_start = tok_getStart();\nskipToStatementStart(lexerFlagsNoTemplate);\nif (babelCompat) {\nAST_open(astProp, {type:'BlockStatement', loc:undefined, directives:[], body:[]});\n} else {\nAST_open(astProp, {type:'BlockStatement', loc:undefined, body:[]});\n}\nif (options_exposeScopes) AST_set('$scope', scoop);\nwhile (tok_getType() !== 16517) {\nparseNestedBodyPart(lexerFlagsNoTemplate, scoop, labelSet, false, 3, null, 'body');\n}\nskipToStatementStart(lexerFlags);\nAST_close($tp_curly_start, $tp_curly_line, $tp_curly_column);\nif (tok_getType() === 49264) {\nreturn THROW_RANGE('A statement can not start with object destructuring assignment (because block)', tok_getStart(), tok_getStop());\n}\n}\nfunction parseBreakStatement(lexerFlags, labelSet, astProp) {\nlet $tp_break_line = tok_getLine();\nlet $tp_break_column = tok_getColumn();\nlet $tp_break_start = tok_getStart();\nlet $tp_break_stop = tok_getStop();\nskipToStatementStart(lexerFlags);\nlet $tp_afterBreak_type = tok_getType();\nif ((isIdentToken($tp_afterBreak_type) && (tok_getNlwas() === false))) {\nlet $tp_label_line = tok_getLine();\nlet $tp_label_column = tok_getColumn();\nlet $tp_label_start = tok_getStart();\nlet $tp_label_stop = tok_getStop();\nlet $tp_label_canon = tok_getCanoN();\nfindLabelForBreak(labelSet, $tp_label_start, $tp_label_stop, $tp_label_canon);\nskipToStatementStart(lexerFlags);\nif (((tok_getNlwas() === true) && isRegexToken(tok_getType()))) {\ntok_asi();\n} else {\nparseSemiOrAsi(lexerFlags);\n}\nAST_setNode(astProp, {type:'BreakStatement', loc:AST_getClosedLoc($tp_break_start, $tp_break_line, $tp_break_column), label:AST_getIdentNode($tp_label_start, $tp_label_stop, $tp_label_line, $tp_label_column, $tp_label_canon)});\n} else if ((lexerFlags & 1536) === 0) {\nreturn THROW_RANGE('Can only `break` without label inside a `switch` or loop', $tp_break_start, $tp_break_stop);\n} else {\nif (((tok_getNlwas() === true) && isRegexToken($tp_afterBreak_type))) {\ntok_asi();\n} else {\nparseSemiOrAsi(lexerFlags);\n}\nAST_setNode(astProp, {type:'BreakStatement', loc:AST_getClosedLoc($tp_break_start, $tp_break_line, $tp_break_column), label:null});\n}\n}\nfunction findLabelForBreak(inputLabelSet, $tp_label_start, $tp_label_stop, $tp_labelName_canon) {\nif (inputLabelSet === null) {\nreturn THROW_RANGE(`The label (\\`${tok_sliceInput($tp_label_start, $tp_label_stop)}\\`) for this \\`break\\` was not defined in the current label set, which is illegal`, $tp_label_start, $tp_label_stop);\n}\nlet labelSet = inputLabelSet;\nlet id = $tp_labelName_canon;\ndo {\nif (labelSet.statementLabels.has(id)) {\nreturn;\n}\n} while (labelSet = labelSet.parentLabels);\nTHROW_RANGE(('The label (`' + $tp_labelName_canon) + '`) for this `break` was not defined in the current label set, which is illegal', $tp_label_start, $tp_label_stop);\n}\nfunction validateLabelForContinue(labelSet, $tp_label_canon, $tp_label_start, $tp_label_stop) {\nif (labelSet === null) {\nreturn THROW_RANGE(('This `continue` had a label (`' + $tp_label_canon) + '`) that was not defined in the current label set as the direct parent of a loop, which would be required', $tp_label_start, $tp_label_stop);\n}\nlet set = labelSet;\ndo {\nif ((set.iterationLabels && set.iterationLabels.has($tp_label_canon))) {\nreturn;\n}\n} while (set = set.parentLabels);\nreturn THROW_RANGE(('This `continue` had a label (`' + $tp_label_canon) + '`) that was not defined in the current label set as the direct parent of a loop, which would be required', $tp_label_start, $tp_label_stop);\n}\nfunction parseConstStatement(lexerFlags, scoop, isLabelled, fdState, astProp) {\nlet $tp_const_line = tok_getLine();\nlet $tp_const_column = tok_getColumn();\nlet $tp_const_start = tok_getStart();\nlet $tp_const_stop = tok_getStop();\nskipToBindingStart(lexerFlags);\nif (((((isLabelled === true) || (fdState === 1))) || (fdState === 2))) {\nreturn THROW_RANGE('Cannot parse a labelled const declaration, only expecting statements here', $tp_const_start, $tp_const_stop);\n}\nparseAnyVarDeclaration(lexerFlags, $tp_const_start, $tp_const_line, $tp_const_column, scoop, 7, 1, undefined, undefined, astProp);\n}\nfunction parseContinueStatement(lexerFlags, labelSet, astProp) {\nlet $tp_continue_line = tok_getLine();\nlet $tp_continue_column = tok_getColumn();\nlet $tp_continue_start = tok_getStart();\nif ((lexerFlags & 512) === 0) {\nreturn THROW_RANGE('Can only `continue` inside a loop', $tp_continue_start, $tp_continue_start + 1);\n}\nskipToStatementStart(lexerFlags);\nif ((isIdentToken(tok_getType()) && (tok_getNlwas() === false))) {\nlet $tp_label_line = tok_getLine();\nlet $tp_label_column = tok_getColumn();\nlet $tp_label_start = tok_getStart();\nlet $tp_label_stop = tok_getStop();\nlet $tp_label_canon = tok_getCanoN();\nvalidateLabelForContinue(labelSet, $tp_label_canon, $tp_label_start, $tp_label_stop);\nskipToStatementStart(lexerFlags);\nif (((tok_getNlwas() === true) && isRegexToken(tok_getType()))) {\ntok_asi();\n} else {\nparseSemiOrAsi(lexerFlags);\n}\nAST_setNode(astProp, {type:'ContinueStatement', loc:AST_getClosedLoc($tp_continue_start, $tp_continue_line, $tp_continue_column), label:AST_getIdentNode($tp_label_start, $tp_label_stop, $tp_label_line, $tp_label_column, $tp_label_canon)});\n} else {\nif (((tok_getNlwas() === true) && isRegexToken(tok_getType()))) {\ntok_asi();\n} else {\nparseSemiOrAsi(lexerFlags);\n}\nAST_setNode(astProp, {type:'ContinueStatement', loc:AST_getClosedLoc($tp_continue_start, $tp_continue_line, $tp_continue_column), label:null});\n}\n}\nfunction parseDebuggerStatement(lexerFlags, astProp) {\nlet $tp_debugger_line = tok_getLine();\nlet $tp_debugger_column = tok_getColumn();\nlet $tp_debugger_start = tok_getStart();\nlet $tp_debugger_stop = tok_getStop();\nskipToStatementStart(lexerFlags);\nif (isRegexToken(tok_getType())) {\nif (tok_getNlwas() === false) {\nreturn THROW_RANGE('Missing semi-colon after debugger keyword', $tp_debugger_stop, $tp_debugger_stop);\n}\ntok_asi();\n} else {\nparseSemiOrAsi(lexerFlags);\n}\nAST_setNode(astProp, {type:'DebuggerStatement', loc:AST_getClosedLoc($tp_debugger_start, $tp_debugger_line, $tp_debugger_column)});\n}\nfunction parseDoStatement(lexerFlags, scoop, labelSet, astProp) {\nlet $tp_do_line = tok_getLine();\nlet $tp_do_column = tok_getColumn();\nlet $tp_do_start = tok_getStart();\nskipToStatementStart(lexerFlags);\nAST_open(astProp, {type:'DoWhileStatement', loc:undefined, body:undefined, test:undefined});\nparseNestedBodyPart(lexerFlags | 512, scoop, labelSet, false, 1, null, 'body');\nif (tok_getType() !== 2124) {\nreturn THROW_RANGE(('A `do` must be followed by a `while`, but found `' + tok_sliceInput(tok_getStart(), tok_getStop())) + '` instead', tok_getStart(), tok_getStop());\n}\nskipToParenOpenOrDie(lexerFlags);\nparseStatementHeader(lexerFlags, 'test');\nif (tok_getType() !== 16490) {\ntok_asi();\n} else {\nparseSemiOrAsi(lexerFlags);\n}\nAST_close($tp_do_start, $tp_do_line, $tp_do_column);\n}\nfunction parseExportDefaultAsync(lexerFlags, scoop, exportedBindings) {\nlet $tp_async_line = tok_getLine();\nlet $tp_async_column = tok_getColumn();\nlet $tp_async_start = tok_getStart();\nlet $tp_async_stop = tok_getStop();\nlet $tp_async_canon = tok_getCanoN();\nskipRex(lexerFlags);\nif (tok_getType() === 2095) {\nreturn parseAsyncStatement(lexerFlags, scoop, $tp_async_start, $tp_async_stop, $tp_async_line, $tp_async_column, $tp_async_canon, true, exportedBindings, false, 4, 'declaration');\n}\nparseAsyncExpression(lexerFlags, $tp_async_start, $tp_async_stop, $tp_async_line, $tp_async_column, $tp_async_canon, 4, true, true, false, 'declaration');\nparseSemiOrAsi(lexerFlags);\n}\nfunction parseExportDefault(lexerFlags, scoop, $tp_export_start, $tp_export_line, $tp_export_column, $tp_default_start, $tp_default_stop, exportedNames, exportedBindings, astProp) {\nAST_open(astProp, {type:'ExportDefaultDeclaration', loc:undefined, declaration:undefined});\nskipToExpressionStart(lexerFlags);\nSCOPE_addLexBinding(scoop, $tp_default_start, $tp_default_stop, '*default*', 6, 4);\naddNameToExports(exportedNames, $tp_default_start, $tp_default_stop, 'default');\naddBindingToExports(exportedBindings, '*default*');\nif (tok_getType() === 2079) {\nlet $tp_exportedName_canon = parseClassDeclaration(lexerFlags, scoop, true, false, 3, 'declaration');\naddBindingToExports(exportedBindings, $tp_exportedName_canon);\n} else if (tok_getType() === 2095) {\nlet $tp_function_line = tok_getLine();\nlet $tp_function_column = tok_getColumn();\nlet $tp_function_start = tok_getStart();\nlet $tp_function_stop = tok_getStop();\nlet $tp_exportedName_canon = parseFunctionDeclaration(lexerFlags, scoop, true, false, 0, $tp_function_start, $tp_function_line, $tp_function_column, $tp_export_start, $tp_function_stop, true, false, 4, 'declaration');\naddBindingToExports(exportedBindings, $tp_exportedName_canon);\n} else if (tok_getType() === 2074) {\nparseExportDefaultAsync(lexerFlags, scoop, exportedBindings);\n} else {\nparseExpression(lexerFlags, 'declaration');\nparseSemiOrAsi(lexerFlags);\n}\nAST_close($tp_export_start, $tp_export_line, $tp_export_column);\n}\nfunction parseExportStar(lexerFlags, $tp_export_start, $tp_export_line, $tp_export_column, exportedNames, astProp) {\nlet $tp_star_line = tok_getLine();\nlet $tp_star_column = tok_getColumn();\nlet $tp_star_start = tok_getStart();\nskipAny(lexerFlags);\nif (tok_getType() === 2073) {\nif (!allowExportStarAs) {\nreturn THROW_RANGE('The `export * as x from src`, syntax was introduced in ES2020 but currently targeted version is lower', $tp_export_start, tok_getStop());\n}\nskipToIdentOrDie(lexerFlags);\nlet $tp_exportedName_line = tok_getLine();\nlet $tp_exportedName_column = tok_getColumn();\nlet $tp_exportedName_start = tok_getStart();\nlet $tp_exportedName_stop = tok_getStop();\nlet $tp_exportedName_canon = tok_getCanoN();\naddNameToExports(exportedNames, $tp_exportedName_start, $tp_exportedName_stop, $tp_exportedName_canon);\nskipAny(lexerFlags);\nlet specifiers = [{type:'ExportNamespaceSpecifier', loc:AST_getClosedLoc($tp_star_start, $tp_star_line, $tp_star_column), exported:AST_getIdentNode($tp_exportedName_start, $tp_exportedName_stop, $tp_exportedName_line, $tp_exportedName_column, $tp_exportedName_canon)}];\nif (tok_getType() !== 2094) {\nreturn THROW_RANGE(('Expected to find `as` or `from`, found `' + tok_sliceInput(tok_getStart(), tok_getStop())) + '` instead', tok_getStart(), tok_getStop());\n}\nskipToStringOrDie(lexerFlags);\nlet $tp_source_line = tok_getLine();\nlet $tp_source_column = tok_getColumn();\nlet $tp_source_start = tok_getStart();\nlet $tp_source_stop = tok_getStop();\nlet $tp_source_canon = tok_getCanoN();\nskipToStatementStart(lexerFlags);\nlet source = AST_getStringNode($tp_source_start, $tp_source_stop, $tp_source_line, $tp_source_column, $tp_source_canon, false);\nparseSemiOrAsi(lexerFlags);\nif (babelCompat) {\nAST_setNode(astProp, {type:'ExportNamedDeclaration', loc:AST_getClosedLoc($tp_export_start, $tp_export_line, $tp_export_column), specifiers, source});\n} else {\nAST_setNode(astProp, {type:'ExportNamedDeclaration', loc:AST_getClosedLoc($tp_export_start, $tp_export_line, $tp_export_column), specifiers, declaration:null, source});\n}\nreturn;\n}\nif (tok_getType() !== 2094) {\nreturn THROW_RANGE(('Expected to find `as` or `from`, found `' + tok_sliceInput(tok_getStart(), tok_getStop())) + '` instead', tok_getStart(), tok_getStop());\n}\nskipToStringOrDie(lexerFlags);\nlet $tp_source_line = tok_getLine();\nlet $tp_source_column = tok_getColumn();\nlet $tp_source_start = tok_getStart();\nlet $tp_source_stop = tok_getStop();\nlet $tp_source_canon = tok_getCanoN();\nskipToStatementStart(lexerFlags);\nlet source = AST_getStringNode($tp_source_start, $tp_source_stop, $tp_source_line, $tp_source_column, $tp_source_canon, false);\nparseSemiOrAsi(lexerFlags);\nAST_setNode(astProp, {type:'ExportAllDeclaration', loc:AST_getClosedLoc($tp_export_start, $tp_export_line, $tp_export_column), source});\n}\nfunction parseExportNamed(lexerFlags, scoop, $tp_export_start, $tp_export_stop, $tp_export_line, $tp_export_column, exportedNames, exportedBindings, astProp) {\nAST_open(astProp, {type:'ExportNamedDeclaration', loc:undefined, specifiers:[], declaration:undefined, source:undefined});\nlet needsSemi = true;\nlet $tp_exportValueStart_line = tok_getLine();\nlet $tp_exportValueStart_column = tok_getColumn();\nlet $tp_exportValueStart_start = tok_getStart();\nlet $tp_exportValueStart_stop = tok_getStop();\nif (tok_getType() === 16513) {\nAST_set('declaration', null);\nlet tmpExportedNames = new Set();\nlet tmpExportedBindings = new Set();\nparseExportObject(lexerFlags, tmpExportedNames, tmpExportedBindings);\nif (tok_getType() === 2094) {\nskipToStringOrDie(lexerFlags);\nlet $tp_from_line = tok_getLine();\nlet $tp_from_column = tok_getColumn();\nlet $tp_from_start = tok_getStart();\nlet $tp_from_stop = tok_getStop();\nlet $tp_from_canon = tok_getCanoN();\nskipToStatementStart(lexerFlags);\nAST_setStringLiteral('source', $tp_from_start, $tp_from_stop, $tp_from_line, $tp_from_column, $tp_from_canon, false);\n} else {\nAST_set('source', null);\ntmpExportedNames.forEach(name => (addNameToExports(exportedNames, $tp_export_start, $tp_export_stop, name)));\ntmpExportedBindings.forEach(name => (addBindingToExports(exportedBindings, name)));\n}\n} else if (tok_getType() === 2122) {\nlet $tp_var_line = tok_getLine();\nlet $tp_var_column = tok_getColumn();\nlet $tp_var_start = tok_getStart();\nskipToBindingStart(lexerFlags);\nparseAnyVarDeclaration(lexerFlags, $tp_var_start, $tp_var_line, $tp_var_column, scoop, 2, 3, exportedNames, exportedBindings, 'declaration');\nAST_set('source', null);\nneedsSemi = false;\n} else if (tok_getType() === 2103) {\nlet $tp_let_line = tok_getLine();\nlet $tp_let_column = tok_getColumn();\nlet $tp_let_start = tok_getStart();\nskipToBindingStart(lexerFlags);\nparseAnyVarDeclaration(lexerFlags, $tp_let_start, $tp_let_line, $tp_let_column, scoop, 6, 3, exportedNames, exportedBindings, 'declaration');\nAST_set('source', null);\nneedsSemi = false;\n} else if (tok_getType() === 2080) {\nlet $tp_const_line = tok_getLine();\nlet $tp_const_column = tok_getColumn();\nlet $tp_const_start = tok_getStart();\nskipToBindingStart(lexerFlags);\nparseAnyVarDeclaration(lexerFlags, $tp_const_start, $tp_const_line, $tp_const_column, scoop, 7, 3, exportedNames, exportedBindings, 'declaration');\nAST_set('source', null);\nneedsSemi = false;\n} else if (tok_getType() === 2079) {\nlet $tp_exportedName_canon = parseClassDeclaration(lexerFlags, scoop, false, false, 3, 'declaration');\naddNameToExports(exportedNames, $tp_exportValueStart_start, $tp_exportValueStart_stop, $tp_exportedName_canon);\naddBindingToExports(exportedBindings, $tp_exportedName_canon);\nneedsSemi = false;\nAST_set('source', null);\n} else if (tok_getType() === 2095) {\nlet $tp_function_stop = tok_getStop();\nlet $tp_exportedName_canon = parseFunctionDeclaration(lexerFlags, scoop, true, false, 0, $tp_exportValueStart_start, $tp_exportValueStart_line, $tp_exportValueStart_column, $tp_export_start, $tp_function_stop, false, false, 3, 'declaration');\naddNameToExports(exportedNames, $tp_exportValueStart_start, $tp_exportValueStart_stop, $tp_exportedName_canon);\naddBindingToExports(exportedBindings, $tp_exportedName_canon);\nAST_set('source', null);\nneedsSemi = false;\n} else if (tok_getType() === 2074) {\nlet $tp_async_line = tok_getLine();\nlet $tp_async_column = tok_getColumn();\nlet $tp_async_start = tok_getStart();\nlet $tp_async_stop = tok_getStop();\nskipDiv(lexerFlags);\nif (tok_getType() !== 2095) {\nreturn THROW_RANGE('Can only export async functions (not arrows), did not find a function', $tp_export_start, tok_getStop());\n}\nif (tok_getNlwas() === true) {\nreturn THROW_RANGE('Async can not be followed by a newline as it results in `export async;`, which is not valid (and probably not what you wanted)', $tp_export_start, $tp_async_stop);\n}\nlet $tp_function_start = tok_getStart();\nlet $tp_function_stop = tok_getStop();\nlet $tp_exportedName_canon = parseFunctionDeclaration(lexerFlags, scoop, true, false, 2074, $tp_async_start, $tp_async_line, $tp_async_column, $tp_export_start, $tp_function_stop, false, false, 3, 'declaration');\naddNameToExports(exportedNames, $tp_function_start, $tp_function_stop, $tp_exportedName_canon);\naddBindingToExports(exportedBindings, $tp_exportedName_canon);\nAST_set('source', null);\nneedsSemi = false;\n} else {\nreturn THROW_RANGE(('Unknown export type `' + tok_sliceInput(tok_getStart(), tok_getStop())) + '` (note: you can only export individual vars through `export {foo};`)', tok_getStart(), tok_getStop());\n}\nif (needsSemi) {\nif (((tok_getNlwas() === true) && isRegexToken(tok_getType()))) {\ntok_asi();\n} else {\nparseSemiOrAsi(lexerFlags);\n}\n}\nAST_close($tp_export_start, $tp_export_line, $tp_export_column);\n}\nfunction parseExportStatement(lexerFlags, scoop, exportedNames, exportedBindings, isGlobalToplevel, astProp) {\nlet $tp_export_line = tok_getLine();\nlet $tp_export_column = tok_getColumn();\nlet $tp_export_start = tok_getStart();\nlet $tp_export_stop = tok_getStop();\nif (goalMode !== true) {\nreturn THROW_RANGE('The `export` keyword can only be used with the module goal', $tp_export_start, $tp_export_stop);\n}\nif (isGlobalToplevel === false) {\nreturn THROW_RANGE('The `export` keyword is only supported at the top level', $tp_export_start, $tp_export_stop);\n}\nskipToIdentStarCurlyOpen(lexerFlags);\nif (tok_getType() === 2083) {\nlet $tp_default_start = tok_getStart();\nlet $tp_default_stop = tok_getStop();\nreturn parseExportDefault(lexerFlags, scoop, $tp_export_start, $tp_export_line, $tp_export_column, $tp_default_start, $tp_default_stop, exportedNames, exportedBindings, astProp);\n}\nif (tok_getType() === 82009) {\nreturn parseExportStar(lexerFlags, $tp_export_start, $tp_export_line, $tp_export_column, exportedNames, astProp);\n}\nreturn parseExportNamed(lexerFlags, scoop, $tp_export_start, $tp_export_stop, $tp_export_line, $tp_export_column, exportedNames, exportedBindings, astProp);\n}\nfunction addNameToExports(exportedNames, $tp_exportedName_start, $tp_exportedName_stop, exportedName) {\nif (((exportedNames !== undefined) && (exportedName !== ''))) {\nif (exportedNames.has(exportedName)) {\nreturn THROW_RANGE(('Tried to export the name `' + exportedName) + '` twice', $tp_exportedName_start, $tp_exportedName_stop);\n}\nexportedNames.add(exportedName);\n}\n}\nfunction addBindingToExports(exportedBindings, exportedTokenCanonName) {\nif (((exportedBindings !== undefined) && (exportedTokenCanonName !== ''))) {\nexportedBindings.add(exportedTokenCanonName);\n}\n}\nfunction parseExportObject(lexerFlags, tmpExportedNames, tmpExportedBindings) {\nskipToIdentCurlyClose(lexerFlags);\nwhile (isIdentToken(tok_getType())) {\nparseExportSpecifier(lexerFlags, tmpExportedNames, tmpExportedBindings);\nif (tok_getType() !== 16480) break;\nskipAny(lexerFlags);\n}\nif (tok_getType() !== 16517) {\nif (tok_getType() === 16486) {\nreturn THROW_RANGE('Export object cannot have spread', tok_getStart(), tok_getStop());\n}\nif (tok_getType() === 16489) {\nreturn THROW_RANGE('Export object uses `as` to alias (`{a as y}`), not colon (`{a: y}`)', tok_getStart(), tok_getStop());\n}\nreturn THROW_RANGE('Export object can only have \"shorthand\" `{x}` or \"as\" `{x as y}', tok_getStart(), tok_getStop());\n}\nskipToStatementStart(lexerFlags);\n}\nfunction parseExportSpecifier(lexerFlags, tmpExportedNames, tmpExportedBindings) {\nlet $tp_name_line = tok_getLine();\nlet $tp_name_column = tok_getColumn();\nlet $tp_name_start = tok_getStart();\nlet $tp_name_stop = tok_getStop();\nlet $tp_name_canon = tok_getCanoN();\nlet $tp_exportedName_line = tok_getLine();\nlet $tp_exportedName_column = tok_getColumn();\nlet $tp_exportedName_start = tok_getStart();\nlet $tp_exportedName_stop = tok_getStop();\nlet $tp_exportedName_canon = tok_getCanoN();\nskipAny(lexerFlags);\nif (tok_getType() === 2073) {\nskipToIdentOrDie(lexerFlags);\n$tp_exportedName_line = tok_getLine();\n$tp_exportedName_column = tok_getColumn();\n$tp_exportedName_start = tok_getStart();\n$tp_exportedName_stop = tok_getStop();\n$tp_exportedName_canon = tok_getCanoN();\nskipAny(lexerFlags);\n}\naddNameToExports(tmpExportedNames, $tp_exportedName_start, $tp_exportedName_stop, $tp_exportedName_canon);\naddBindingToExports(tmpExportedBindings, $tp_name_canon);\nAST_setNode('specifiers', {type:'ExportSpecifier', loc:AST_getClosedLoc($tp_name_start, $tp_name_line, $tp_name_column), local:AST_getIdentNode($tp_name_start, $tp_name_stop, $tp_name_line, $tp_name_column, $tp_name_canon), exported:AST_getIdentNode($tp_exportedName_start, $tp_exportedName_stop, $tp_exportedName_line, $tp_exportedName_column, $tp_exportedName_canon)});\n}\nfunction parseForStatement(lexerFlags, scoop, labelSet, astProp) {\nscoop = SCOPE_addLayer(scoop, 1, 'parseForStatement(header)');\nlet $tp_for_line = tok_getLine();\nlet $tp_for_column = tok_getColumn();\nlet $tp_for_start = tok_getStart();\nlet $tp_for_stop = tok_getStop();\nskipToAwaitParenOpen(lexerFlags);\nlet awaitable = tok_getType() === 2075;\nif (awaitable) {\nlet $tp_await_stop = tok_getStop();\nif (!allowAsyncGenerators) {\nreturn THROW_RANGE('`for await` is not supported by the current targeted language version, they were introduced in ES9/ES2018', $tp_for_start, $tp_await_stop);\n}\nif ((lexerFlags & 8) === 0) {\nreturn THROW_RANGE('Can only use `for-await` inside an async function', $tp_for_start, $tp_await_stop);\n}\nskipToParenOpenOrDie(lexerFlags);\n} else if (tok_getType() !== 16471) {\nreturn THROW_RANGE(('Missing opening paren of the `for` header, found `' + tok_sliceInput(tok_getStart(), tok_getStop())) + '` instead', $tp_for_start, $tp_for_stop);\n}\nskipToExpressionStartSemi(lexerFlags);\nparseForHeader(((lexerFlags | 4096) | 1792) ^ 1792, $tp_for_start, scoop, awaitable, astProp);\nif (tok_getType() !== 16472) {\nreturn THROW_RANGE(('Missing closing paren of the `for` header, found `' + tok_sliceInput(tok_getStart(), tok_getStop())) + '` instead', tok_getStart(), tok_getStop());\n}\nskipToStatementStart(lexerFlags);\nparseNestedBodyPart(lexerFlags | 512, scoop, labelSet, false, 1, null, 'body');\nAST_close($tp_for_start, $tp_for_line, $tp_for_column);\n}\nfunction parseForHeaderVar(lexerFlags, scoop, astProp) {\nlet $tp_var_line = tok_getLine();\nlet $tp_var_column = tok_getColumn();\nlet $tp_var_start = tok_getStart();\nlet $tp_var_stop = tok_getStop();\nskipToBindingStart(lexerFlags);\nparseAnyVarDeclaration(lexerFlags | 32, $tp_var_start, $tp_var_line, $tp_var_column, scoop, 2, 2, undefined, undefined, astProp);\nreturn 32;\n}\nfunction parseForHeaderLet(lexerFlags, $tp_for_start, $tp_startOfForHeader_start, $tp_startOfForHeader_stop, $tp_startOfForHeader_line, $tp_startOfForHeader_column, scoop, astProp) {\nlet $tp_letIdent_type = tok_getType();\nlet $tp_letIdent_line = tok_getLine();\nlet $tp_letIdent_column = tok_getColumn();\nlet $tp_letIdent_start = tok_getStart();\nlet $tp_letIdent_stop = tok_getStop();\nlet $tp_letIdent_canon = tok_getCanoN();\nskipDiv(lexerFlags);\nlet $tp_letArg_type = tok_getType();\nlet $tp_letArg_stop = tok_getStop();\nif (isIdentToken($tp_letArg_type)) {\nif ($tp_letArg_type === 67636) {\nif ((lexerFlags & 8192) === 8192) {\nreturn THROW_RANGE('Let binding missing binding names as `let` cannot be a var name in strict mode', $tp_letIdent_start, $tp_letArg_stop);\n}\nAST_setIdent(astProp, $tp_letIdent_start, $tp_letIdent_stop, $tp_letIdent_line, $tp_letIdent_column, $tp_letIdent_canon);\nreturn 32;\n}\nif ($tp_letArg_type === 2106) {\nreturn THROW_RANGE('A `for (let of ...)` is always illegal', $tp_for_start, $tp_letArg_stop);\n}\nparseAnyVarDeclaration(lexerFlags | 32, $tp_letIdent_start, $tp_letIdent_line, $tp_letIdent_column, scoop, 6, 2, undefined, undefined, astProp);\nreturn 32;\n}\nif ((($tp_letArg_type === 16509) || ($tp_letArg_type === 16513))) {\nparseAnyVarDeclaration(lexerFlags | 32, $tp_letIdent_start, $tp_letIdent_line, $tp_letIdent_column, scoop, 6, 2, undefined, undefined, astProp);\nreturn 32;\n}\nif ((lexerFlags & 8192) === 8192) {\nreturn THROW_RANGE('Let binding missing binding names in strict mode', $tp_letIdent_start, $tp_letIdent_stop);\n}\nif ($tp_letArg_type === 16490) {\nAST_setIdent(astProp, $tp_letIdent_start, $tp_letIdent_stop, $tp_letIdent_line, $tp_letIdent_column, $tp_letIdent_canon);\nreturn 16;\n}\nlet assignable = parseValueAfterIdent(lexerFlags, $tp_letIdent_type, $tp_letIdent_start, $tp_letIdent_stop, $tp_letIdent_line, $tp_letIdent_column, $tp_letIdent_canon, 0, true, astProp);\nassignable = parseExpressionFromOp(lexerFlags | 32, $tp_startOfForHeader_start, $tp_startOfForHeader_stop, $tp_startOfForHeader_line, $tp_startOfForHeader_column, assignable, astProp);\nif (tok_getType() === 2106) {\nreturn THROW_RANGE('Cannot use `let` as a var name on the left side in a `for-of` header', $tp_for_start, tok_getStop());\n}\nreturn assignable;\n}\nfunction parseForHeaderConst(lexerFlags, scoop, astProp) {\nlet $tp_const_line = tok_getLine();\nlet $tp_const_column = tok_getColumn();\nlet $tp_const_start = tok_getStart();\nskipToBindingStart(lexerFlags);\nparseAnyVarDeclaration(lexerFlags | 32, $tp_const_start, $tp_const_line, $tp_const_column, scoop, 7, 2, undefined, undefined, astProp);\nreturn 32;\n}\nfunction parseForHeaderCurly(lexerFlags, astProp) {\nlet $tp_curly_line = tok_getLine();\nlet $tp_curly_column = tok_getColumn();\nlet $tp_curly_start = tok_getStart();\nlet $tp_curly_stop = tok_getStop();\nlet destructible = parseObjectOuter(lexerFlags | 32, null, 0, false, undefined, undefined, astProp);\nlet $tp_curlyClose_type = tok_getType();\nlet $tp_curlyClose_stop = tok_getStart();\nif ((destructible & 4) === 4) {\nif ((((($tp_curlyClose_type !== 49264) && ($tp_curlyClose_type !== 2106))) && ($tp_curlyClose_type !== 67636))) {\nreturn THROW_RANGE('Cannot use lhs as regular for-loop because it must destruct', $tp_curly_start, $tp_curlyClose_stop);\n}\ndestructible = (destructible | 4) ^ 4;\n}\nreturn parsePatternTailInForHeader(lexerFlags, $tp_curly_start, $tp_curly_stop, $tp_curly_line, $tp_curly_column, 16517, destructible, astProp);\n}\nfunction parseForHeaderBracket(lexerFlags, astProp) {\nlet $tp_square_line = tok_getLine();\nlet $tp_square_column = tok_getColumn();\nlet $tp_square_start = tok_getStart();\nlet $tp_square_stop = tok_getStop();\nlet destructible = parseArrayOuter(lexerFlags | 32, null, 0, false, undefined, undefined, astProp);\nlet $tp_bracketClose_type = tok_getType();\nlet $tp_bracketClose_stop = tok_getStart();\nif ((destructible & 4) === 4) {\nif ((((($tp_bracketClose_type !== 49264) && ($tp_bracketClose_type !== 2106))) && ($tp_bracketClose_type !== 67636))) {\nreturn THROW_RANGE('Cannot use lhs as regular for-loop because it must destruct', $tp_square_start, $tp_bracketClose_stop);\n}\ndestructible = (destructible | 4) ^ 4;\n}\nlet assignable = parsePatternTailInForHeader(lexerFlags, $tp_square_start, $tp_square_stop, $tp_square_line, $tp_square_column, 16510, destructible, astProp);\nreturn assignable;\n}\nfunction parseForHeaderOther(lexerFlags, astProp) {\nreturn parseValue(lexerFlags | 32, true, 4, false, astProp);\n}\nfunction parseForHeader(lexerFlags, $tp_for_start, scoop, awaitable, astProp) {\nlet $tp_startOfForHeader_line = tok_getLine();\nlet $tp_startOfForHeader_column = tok_getColumn();\nlet $tp_startOfForHeader_start = tok_getStart();\nlet $tp_startOfForHeader_stop = tok_getStop();\nlet assignable = parseForHeaderLhs(lexerFlags, $tp_for_start, $tp_startOfForHeader_start, $tp_startOfForHeader_stop, $tp_startOfForHeader_line, $tp_startOfForHeader_column, scoop, astProp);\nreturn parseForHeaderRest(lexerFlags, $tp_for_start, $tp_startOfForHeader_start, $tp_startOfForHeader_stop, $tp_startOfForHeader_line, $tp_startOfForHeader_column, awaitable, assignable, astProp);\n}\nfunction parseForHeaderLhs(lexerFlags, $tp_for_start, $tp_startOfForHeader_start, $tp_startOfForHeader_stop, $tp_startOfForHeader_line, $tp_startOfForHeader_column, scoop, astProp) {\nswitch (tok_getType()) {\ncase 2122:\nreturn parseForHeaderVar(lexerFlags, scoop, astProp);\ncase 2103:\nreturn parseForHeaderLet(lexerFlags, $tp_for_start, $tp_startOfForHeader_start, $tp_startOfForHeader_stop, $tp_startOfForHeader_line, $tp_startOfForHeader_column, scoop, astProp);\ncase 2080:\nreturn parseForHeaderConst(lexerFlags, scoop, astProp);\ncase 16490:\nAST_setNodeDangerously(astProp, null);\nreturn 16;\ncase 16513:\nreturn parseForHeaderCurly(lexerFlags, astProp);\ncase 16509:\nreturn parseForHeaderBracket(lexerFlags, astProp);\n}\nlet assignable = parseForHeaderOther(lexerFlags, astProp);\nreturn parseExpressionFromOp(lexerFlags | 32, $tp_startOfForHeader_start, $tp_startOfForHeader_stop, $tp_startOfForHeader_line, $tp_startOfForHeader_column, assignable, astProp);\n}\nfunction parseForHeaderRest(lexerFlags, $tp_for_start, $tp_startOfForHeader_start, $tp_startOfForHeader_stop, $tp_startOfForHeader_line, $tp_startOfForHeader_column, awaitable, assignable, astProp) {\nif (tok_getType() === 2106) {\nreturn parseForFromOf(lexerFlags, $tp_for_start, awaitable, assignable, astProp);\n}\nif (awaitable) {\nreturn THROW_RANGE('`for await` only accepts the `for-of` type', $tp_for_start, tok_getStop());\n}\nif (tok_getType() === 67636) {\nreturn parseForFromIn(lexerFlags, $tp_for_start, assignable, astProp);\n}\nAST_wrapClosedCustom(astProp, {type:'ForStatement', loc:undefined, init:undefined, test:undefined, update:undefined, body:undefined}, 'init');\nreturn parseForFromSemi(lexerFlags, $tp_startOfForHeader_start, $tp_startOfForHeader_line, $tp_startOfForHeader_column);\n}\nfunction parseForFromOf(lexerFlags, $tp_for_start, awaitable, assignable, astProp) {\nif (notAssignable(assignable)) {\nreturn THROW_RANGE('Left part of for-of must be assignable', $tp_for_start, tok_getStop());\n}\nAST_wrapClosedCustom(astProp, {type:'ForOfStatement', loc:undefined, left:undefined, right:undefined, await:awaitable, body:undefined}, 'left');\nskipToExpressionStart(lexerFlags);\nparseExpression(lexerFlags, 'right');\n}\nfunction parseForFromIn(lexerFlags, $tp_for_start, assignable, astProp) {\nif (notAssignable(assignable)) {\nreturn THROW_RANGE('Left part of for-in must be assignable', $tp_for_start, tok_getStop());\n}\nAST_wrapClosedCustom(astProp, {type:'ForInStatement', loc:undefined, left:undefined, right:undefined, body:undefined}, 'left');\nskipToExpressionStart(lexerFlags);\nparseExpressions(lexerFlags, 'right');\n}\nfunction parseForFromSemi(lexerFlags, $tp_startOfForHeader_start, $tp_startOfForHeader_line, $tp_startOfForHeader_column) {\nlet hadComma = tok_getType() === 16480;\nlet potentialCommaStart = tok_getStart();\nif (hadComma) {\n_parseExpressions(lexerFlags | 32, $tp_startOfForHeader_start, $tp_startOfForHeader_line, $tp_startOfForHeader_column, 16, 'init');\n}\nif (tok_getType() !== 16490) {\nif ((hadComma && (((tok_getType() === 2106) || (tok_getType() === 67636))))) {\nreturn THROW_RANGE('Comma not allowed in left side of `for-in`/`for-of` header', potentialCommaStart, potentialCommaStart + 1);\n}\nreturn THROW_RANGE(('Missing first semi in `for` header, found `' + tok_sliceInput(tok_getStart(), tok_getStop())) + '` instead', tok_getStart(), tok_getStop());\n}\nreturn _parseForFromSemi(lexerFlags);\n}\nfunction _parseForFromSemi(lexerFlags) {\nskipToExpressionStartSemi(lexerFlags);\nif (tok_getType() === 16490) {\nAST_set('test', null);\n} else {\nparseExpressions(lexerFlags, 'test');\nif (tok_getType() !== 16490) {\nreturn THROW_RANGE(('Missing second semi in `for` header, found `' + tok_sliceInput(tok_getStart(), tok_getStop())) + '` instead', tok_getStart(), tok_getStop());\n}\n}\nskipToExpressionStartGrouped(lexerFlags);\nif (tok_getType() === 16472) {\nAST_set('update', null);\n} else {\nparseExpressions(lexerFlags, 'update');\n}\n}\nfunction parsePatternTailInForHeader(lexerFlags, $tp_patternStart_start, $tp_patternStart_stop, $tp_patternStart_line, $tp_patternStart_column, closingPuncType, destructible, astProp) {\nlet assignable = (((destructible & 1) !== 0)? 16 : 32);\nlet $tp_patternTailStart_type = tok_getType();\nif ((($tp_patternTailStart_type !== 49264) && isAnyAssignmentOp())) {\nreturn THROW_RANGE('Cannot compound assign to an object or array pattern', tok_getStart(), tok_getStop());\n}\nassignable = parseValueTail(lexerFlags | 32, $tp_patternStart_start, $tp_patternStart_line, $tp_patternStart_column, assignable, 4, false, astProp);\nlet $tp_afteLhs_type = tok_getType();\nif ((($tp_afteLhs_type === 2106) || ($tp_afteLhs_type === 67636))) {\nif (notAssignable(assignable)) {\nreturn THROW_RANGE('The for-header lhs binding pattern is not destructible', tok_getStart(), tok_getStop());\n}\nAST_destruct(astProp);\nreturn assignable;\n}\nif ($tp_afteLhs_type === 16490) {\nreturn assignable;\n}\nif ($tp_afteLhs_type === 49264) {\nlet $tp_eq_start = tok_getStart();\nlet $tp_eq_stop = tok_getStop();\nparseExpressionFromOp(lexerFlags | 32, $tp_patternStart_start, $tp_patternStart_stop, $tp_patternStart_line, $tp_patternStart_column, assignable, astProp);\nif (tok_getType() === 16490) {\nreturn 16;\n}\nif (((tok_getType() === 67636) || (tok_getType() === 2106))) {\nreturn THROW_RANGE('The left side of a `for-of` and `for-in` can not be an assignment, even if it is a BindingPattern', $tp_eq_start, $tp_eq_stop);\n}\nreturn THROW_RANGE('Unknown input followed the left side of a for loop header after assignment', tok_getStart(), tok_getStop());\n}\nparseOptionalDestructibleRestOfExpression(lexerFlags, $tp_patternStart_start, $tp_patternStart_stop, $tp_patternStart_line, $tp_patternStart_column, assignable, destructible, closingPuncType, astProp);\nif (tok_getType() === 16480) {\n_parseExpressions(lexerFlags, $tp_patternStart_start, $tp_patternStart_line, $tp_patternStart_column, 16, astProp);\n}\nif (tok_getType() === 16490) {\nreturn assignable;\n}\nreturn THROW_RANGE('Unknown input followed the left side of a for loop header', tok_getStart(), tok_getStop());\n}\nfunction parseIfStatement(lexerFlags, scoop, labelSet, astProp) {\nlet $tp_if_line = tok_getLine();\nlet $tp_if_column = tok_getColumn();\nlet $tp_if_start = tok_getStart();\nskipToParenOpenOrDie(lexerFlags);\nAST_open(astProp, {type:'IfStatement', loc:undefined, test:undefined, consequent:undefined, alternate:undefined});\nparseStatementHeader(lexerFlags, 'test');\nparseNestedBodyPart(lexerFlags, scoop, labelSet, false, 2, null, 'consequent');\nif (tok_getType() === 2086) {\nskipToStatementStart(lexerFlags);\nparseNestedBodyPart(lexerFlags, scoop, labelSet, false, 2, null, 'alternate');\n} else {\nAST_set('alternate', null);\n}\nAST_close($tp_if_start, $tp_if_line, $tp_if_column);\n}\nfunction parseImportDeclaration(lexerFlags, scoop, isGlobalToplevel, astProp) {\nlet $tp_import_line = tok_getLine();\nlet $tp_import_column = tok_getColumn();\nlet $tp_import_start = tok_getStart();\nlet $tp_import_stop = tok_getStop();\nskipToIdentStarCurlyOpenParenOpenString(lexerFlags);\nif (tok_getType() === 16471) {\nreturn parseDynamicImportStatement(lexerFlags, $tp_import_start, $tp_import_stop, $tp_import_line, $tp_import_column, astProp);\n}\nif (goalMode !== true) {\nreturn THROW_RANGE('The `import` keyword can only be used with the module goal', $tp_import_start, $tp_import_stop);\n}\nif (isGlobalToplevel === false) {\nreturn THROW_RANGE('The `import` keyword is only supported at the top level', $tp_import_start, $tp_import_stop);\n}\nAST_open(astProp, {type:'ImportDeclaration', loc:undefined, specifiers:[], source:undefined});\nif (isIdentToken(tok_getType())) {\nparseImportDefault(lexerFlags, scoop);\nif (tok_getType() === 16480) {\nskipToIdentStarCurlyOpen(lexerFlags);\nif (tok_getType() === 82009) {\nparseImportNamespace(lexerFlags, scoop);\n} else if (tok_getType() === 16513) {\nparseImportObject(lexerFlags, scoop);\n} else {\nreturn THROW_RANGE('A default import can only be followed by a star or object specifier', tok_getStart(), tok_getStop());\n}\n} else if (tok_getType() === 2094) {\nskipToStringOrDie(lexerFlags);\n} else {\nreturn THROW_RANGE('The default `import` should be followed by another specifier or `from`', $tp_import_start, tok_getStop());\n}\n} else if (tok_getType() === 82009) {\nparseImportNamespace(lexerFlags, scoop);\n} else if (tok_getType() === 16513) {\nparseImportObject(lexerFlags, scoop);\n} else {\nif (!isStringToken(tok_getType())) {\nreturn THROW_RANGE(('Expected a valid token after the `import` keyword, found `' + tok_sliceInput(tok_getStart(), tok_getStop())) + '` instead', tok_getStart(), tok_getStop());\n}\n}\nlet $tp_source_line = tok_getLine();\nlet $tp_source_column = tok_getColumn();\nlet $tp_source_start = tok_getStart();\nlet $tp_source_stop = tok_getStop();\nlet $tp_source_canon = tok_getCanoN();\nskipToStatementStart(lexerFlags);\nAST_setStringLiteral('source', $tp_source_start, $tp_source_stop, $tp_source_line, $tp_source_column, $tp_source_canon, false);\nparseSemiOrAsi(lexerFlags);\nAST_close($tp_import_start, $tp_import_line, $tp_import_column);\n}\nfunction parseImportDefault(lexerFlags, scoop) {\nlet $tp_ident_type = tok_getType();\nlet $tp_ident_line = tok_getLine();\nlet $tp_ident_column = tok_getColumn();\nlet $tp_ident_start = tok_getStart();\nlet $tp_ident_stop = tok_getStop();\nlet $tp_ident_canon = tok_getCanoN();\nfatalBindingIdentCheck($tp_ident_type, $tp_ident_start, $tp_ident_stop, $tp_ident_canon, 7, lexerFlags);\nSCOPE_addLexBinding(scoop, $tp_ident_start, $tp_ident_stop, $tp_ident_canon, 6, 3);\nskipToAsCommaFrom(lexerFlags);\nAST_setNode('specifiers', {type:'ImportDefaultSpecifier', loc:AST_getClosedLoc($tp_ident_start, $tp_ident_line, $tp_ident_column), local:AST_getIdentNode($tp_ident_start, $tp_ident_stop, $tp_ident_line, $tp_ident_column, $tp_ident_canon)});\n}\nfunction parseImportObject(lexerFlags, scoop) {\nskipToIdentCurlyClose(lexerFlags);\nwhile (isIdentToken(tok_getType())) {\nparseImportSpecifier(lexerFlags, scoop);\nif (tok_getType() !== 16480) break;\nskipAny(lexerFlags);\n}\nif (tok_getType() !== 16517) {\nif (tok_getType() === 16486) {\nreturn THROW_RANGE('Import object cannot have spread', tok_getStart(), tok_getStop());\n}\nif (tok_getType() === 16489) {\nreturn THROW_RANGE('Import object uses `as` to alias (`{a as y}`), not colon (`{a: y}`)', tok_getStart(), tok_getStop());\n}\nreturn THROW_RANGE(('Missing import definition closing curly, found `' + tok_sliceInput(tok_getStart(), tok_getStop())) + '` instead', tok_getStart(), tok_getStop());\n}\nskipToFromOrDie(lexerFlags);\nskipToStringOrDie(lexerFlags);\n}\nfunction parseImportSpecifier(lexerFlags, scoop) {\nlet $tp_name_line = tok_getLine();\nlet $tp_name_column = tok_getColumn();\nlet $tp_name_start = tok_getStart();\nlet $tp_name_stop = tok_getStop();\nlet $tp_name_canon = tok_getCanoN();\nlet $tp_local_type = tok_getType();\nlet $tp_local_line = tok_getLine();\nlet $tp_local_column = tok_getColumn();\nlet $tp_local_start = tok_getStart();\nlet $tp_local_stop = tok_getStop();\nlet $tp_local_canon = tok_getCanoN();\nskipToAsCommaCurlyClose(lexerFlags);\nif (tok_getType() === 2073) {\nskipToIdentOrDie(lexerFlags);\n$tp_local_type = tok_getType();\n$tp_local_line = tok_getLine();\n$tp_local_column = tok_getColumn();\n$tp_local_start = tok_getStart();\n$tp_local_stop = tok_getStop();\n$tp_local_canon = tok_getCanoN();\nskipAny(lexerFlags);\n}\nfatalBindingIdentCheck($tp_local_type, $tp_local_start, $tp_local_stop, $tp_local_canon, 7, lexerFlags);\nSCOPE_addLexBinding(scoop, $tp_local_start, $tp_local_stop, $tp_local_canon, 6, 1);\nAST_setNode('specifiers', {type:'ImportSpecifier', loc:AST_getClosedLoc($tp_name_start, $tp_name_line, $tp_name_column), imported:AST_getIdentNode($tp_name_start, $tp_name_stop, $tp_name_line, $tp_name_column, $tp_name_canon), local:AST_getIdentNode($tp_local_start, $tp_local_stop, $tp_local_line, $tp_local_column, $tp_local_canon)});\n}\nfunction parseImportNamespace(lexerFlags, scoop) {\nlet $tp_star_line = tok_getLine();\nlet $tp_star_column = tok_getColumn();\nlet $tp_star_start = tok_getStart();\nskipAny(lexerFlags);\nif (tok_getType() !== 2073) {\nreturn THROW_RANGE(('Next token should be `as` but was `' + tok_sliceInput(tok_getStart(), tok_getStop())) + '`', tok_getStart(), tok_getStop());\n}\nskipToIdentOrDie(lexerFlags);\nlet $tp_local_type = tok_getType();\nlet $tp_local_line = tok_getLine();\nlet $tp_local_column = tok_getColumn();\nlet $tp_local_start = tok_getStart();\nlet $tp_local_stop = tok_getStop();\nlet $tp_local_canon = tok_getCanoN();\nskipToFromOrDie(lexerFlags);\nfatalBindingIdentCheck($tp_local_type, $tp_local_start, $tp_local_stop, $tp_local_canon, 7, lexerFlags);\nSCOPE_addLexBinding(scoop, $tp_local_start, $tp_local_stop, $tp_local_canon, 6, 1);\nAST_setNode('specifiers', {type:'ImportNamespaceSpecifier', loc:AST_getClosedLoc($tp_star_start, $tp_star_line, $tp_star_column), local:AST_getIdentNode($tp_local_start, $tp_local_stop, $tp_local_line, $tp_local_column, $tp_local_canon)});\nskipToStringOrDie(lexerFlags);\n}\nfunction parseLetDeclaration(lexerFlags, $tp_let_start, $tp_let_line, $tp_let_column, scoop, labelSet, fdState, nestedLabels, astProp) {\nlet $tp_ident_type = tok_getType();\nlet $tp_ident_line = tok_getLine();\nlet $tp_ident_column = tok_getColumn();\nlet $tp_ident_start = tok_getStart();\nlet $tp_ident_stop = tok_getStop();\nlet $tp_ident_canon = tok_getCanoN();\nskipDiv(lexerFlags);\nif (isIdentToken(tok_getType())) {\nlet $tp_binding_type = tok_getType();\nlet $tp_binding_start = tok_getStart();\nlet $tp_binding_stop = tok_getStop();\nlet $tp_binding_canon = tok_getCanoN();\nlet identBindingErrorMsg = ((tok_getNlwas() === true)? nonFatalBindingIdentCheck($tp_binding_type, $tp_binding_start, $tp_binding_stop, $tp_binding_canon, 6, lexerFlags) : '');\nif (identBindingErrorMsg !== '') {\nif ([2075, 2126, 2072, 2088, 2098, 2102, 2103, 2107, 2108, 2109, 2110, 2113].includes(tok_getType())) {\nreturn THROW_RANGE((('Attempted to create a `let` binding on special reserved keyword `' + tok_sliceInput($tp_binding_start, $tp_binding_stop)) + '` but: ') + identBindingErrorMsg, $tp_binding_start, $tp_binding_stop);\n}\nreturn THROW_RANGE(('`let` must be a declaration in strict mode but the next ident is a reserved keyword (`' + tok_sliceInput($tp_binding_start, $tp_binding_stop)) + '`)', $tp_binding_start, $tp_binding_stop);\n}\nparseAnyVarDeclaration(lexerFlags, $tp_let_start, $tp_let_line, $tp_let_column, scoop, 6, 1, undefined, undefined, astProp);\n} else if (((tok_getType() === 16509) || (tok_getType() === 16513))) {\nparseAnyVarDeclaration(lexerFlags, $tp_let_start, $tp_let_line, $tp_let_column, scoop, 6, 1, undefined, undefined, astProp);\n} else if ((lexerFlags & 8192) === 8192) {\nreturn THROW_RANGE('Let declaration missing binding names and `let` cannot be a regular var or label name in strict mode', $tp_ident_start, $tp_ident_stop);\n} else {\n_parseLetAsPlainVarNameExpressionStatement(lexerFlags, scoop, labelSet, $tp_ident_type, $tp_ident_start, $tp_ident_stop, $tp_ident_line, $tp_ident_column, $tp_ident_canon, fdState, nestedLabels, astProp);\n}\n}\nfunction parseLetExpressionStatement(lexerFlags, scoop, labelSet, fdState, nestedLabels, astProp) {\nlet $tp_ident_type = tok_getType();\nlet $tp_ident_line = tok_getLine();\nlet $tp_ident_column = tok_getColumn();\nlet $tp_ident_start = tok_getStart();\nlet $tp_ident_stop = tok_getStop();\nlet $tp_ident_canon = tok_getCanoN();\nskipDiv(lexerFlags);\nif ((lexerFlags & 8192) === 8192) {\nreturn THROW_RANGE('`let` declaration not allowed here and `let` cannot be a regular var or label name in strict mode', $tp_ident_start, $tp_ident_stop);\n}\nif (tok_getType() === 16509) {\nreturn THROW_RANGE('It is never valid for an expression statement to begin with `let[`, and a `let` declaration would not be valid here', $tp_ident_start, tok_getStop());\n}\n_parseLetAsPlainVarNameExpressionStatement(lexerFlags, scoop, labelSet, $tp_ident_type, $tp_ident_start, $tp_ident_stop, $tp_ident_line, $tp_ident_column, $tp_ident_canon, fdState, nestedLabels, astProp);\n}\nfunction _parseLetAsPlainVarNameExpressionStatement(lexerFlags, scoop, labelSet, $tp_ident_type, $tp_ident_start, $tp_ident_stop, $tp_ident_line, $tp_ident_column, $tp_ident_canon, fdState, nestedLabels, astProp) {\nif (tok_getType() === 16489) {\nreturn parseLabeledStatementInstead(lexerFlags, scoop, labelSet, $tp_ident_type, $tp_ident_start, $tp_ident_stop, $tp_ident_line, $tp_ident_column, $tp_ident_canon, fdState, nestedLabels, astProp);\n}\nlet $tp_next_type = tok_getType();\nif ((($tp_next_type === 67636) || ($tp_next_type === 67636))) {\nreturn THROW_RANGE('Cannot use `let` as a regular var name as the lhs of `in` or `instanceof` in a toplevel expression statement', tok_getStart(), tok_getStop());\n}\nAST_open(astProp, {type:'ExpressionStatement', loc:undefined, expression:undefined});\nlet assignable = parseIdentOrParenlessArrow(lexerFlags, $tp_ident_type, $tp_ident_start, $tp_ident_stop, $tp_ident_line, $tp_ident_column, $tp_ident_canon, 32, true, 'expression');\nassignable = parseValueTail(lexerFlags, $tp_ident_start, $tp_ident_line, $tp_ident_column, assignable, 4, false, 'expression');\nparseExpressionFromOp(lexerFlags, $tp_ident_start, $tp_ident_stop, $tp_ident_line, $tp_ident_column, assignable, 'expression');\nif (tok_getType() === 16480) {\n_parseExpressions(lexerFlags, $tp_ident_start, $tp_ident_line, $tp_ident_column, 16, 'expression');\n}\nparseSemiOrAsi(lexerFlags);\nAST_close($tp_ident_start, $tp_ident_line, $tp_ident_column);\n}\nfunction parseReturnStatement(lexerFlags, astProp) {\nlet $tp_return_line = tok_getLine();\nlet $tp_return_column = tok_getColumn();\nlet $tp_return_start = tok_getStart();\nif (((!allowGlobalReturn) && ((lexerFlags & 256) === 256))) {\nreturn THROW_RANGE('Not configured to parse `return` statement in global, bailing', $tp_return_start, $tp_return_start + 1);\n}\nskipToStatementStart(lexerFlags);\nAST_open(astProp, {type:'ReturnStatement', loc:undefined, argument:undefined});\nif (((tok_getNlwas() === true) && isRegexToken(tok_getType()))) {\ntok_asi();\nAST_set('argument', null);\n} else {\nif (((((((tok_getNlwas() === false) && (tok_getType() !== 2097173))) && (tok_getType() !== 16490))) && (tok_getType() !== 16517))) {\nparseExpressions(lexerFlags, 'argument');\n} else {\nAST_set('argument', null);\n}\nparseSemiOrAsi(lexerFlags);\n}\nAST_close($tp_return_start, $tp_return_line, $tp_return_column);\n}\nfunction parseSwitchStatement(lexerFlags, scoop, labelSet, astProp) {\nlet $tp_switch_line = tok_getLine();\nlet $tp_switch_column = tok_getColumn();\nlet $tp_switch_start = tok_getStart();\nskipToParenOpenOrDie(lexerFlags);\nAST_open(astProp, {type:'SwitchStatement', loc:undefined, discriminant:undefined, cases:[]});\nlet lexerFlagsForSwitch = (lexerFlags | 6400) ^ 6400;\nparseStatementHeader(lexerFlagsForSwitch, 'discriminant');\nif (tok_getType() !== 16513) {\nreturn THROW_RANGE(('Missing opening curly of `switch` body, found `' + tok_sliceInput(tok_getStart(), tok_getStop())) + '` instead', tok_getStart(), tok_getStop());\n}\nskipToSwitchBody(lexerFlagsForSwitch);\nlet casesScoop = SCOPE_addLayer(scoop, 8, 'parseSwitchStatement');\nparseSwitchCases(lexerFlagsForSwitch | 1024, casesScoop, labelSet, 'cases');\nif (tok_getType() !== 16517) {\nreturn THROW_RANGE(('Missing the closing curly of the switch body, found `' + tok_sliceInput(tok_getStart(), tok_getStop())) + '` instead', tok_getStart(), tok_getStop());\n}\nskipToStatementStart(lexerFlags);\nAST_close($tp_switch_start, $tp_switch_line, $tp_switch_column);\n}\nfunction parseSwitchCases(lexerFlags, scoop, labelSet, astProp) {\nlet hadDefault = false;\nwhile (true) {\nlet $tp_caseDefault_line = tok_getLine();\nlet $tp_caseDefault_column = tok_getColumn();\nlet $tp_caseDefault_start = tok_getStart();\nif (tok_getType() === 2077) {\nskipToExpressionStart(lexerFlags);\nAST_open(astProp, {type:'SwitchCase', loc:undefined, test:undefined, consequent:[]});\nparseExpressions(lexerFlags, 'test');\nif (tok_getType() !== 16489) {\nreturn THROW_RANGE('Missing colon after case expr', tok_getStart(), tok_getStop());\n}\n} else if (tok_getType() === 2083) {\nif (hadDefault) {\nreturn THROW_RANGE('Found second `default` in same switch', tok_getStart(), tok_getStop());\n}\nhadDefault = true;\nskipToColonOrDie(lexerFlags);\nAST_open(astProp, {type:'SwitchCase', loc:undefined, test:null, consequent:[]});\n} else {\nbreak;\n}\nskipToStatementStart(lexerFlags);\nwhile (((((tok_getType() !== 16517) && (tok_getType() !== 2077))) && (tok_getType() !== 2083))) {\nparseNestedBodyPart(lexerFlags, scoop, labelSet, false, 3, null, 'consequent');\n}\nAST_close($tp_caseDefault_start, $tp_caseDefault_line, $tp_caseDefault_column);\n}\n}\nfunction parseThrowStatement(lexerFlags, astProp) {\nlet $tp_throw_line = tok_getLine();\nlet $tp_throw_column = tok_getColumn();\nlet $tp_throw_start = tok_getStart();\nskipToExpressionStart(lexerFlags);\nAST_open(astProp, {type:'ThrowStatement', loc:undefined, argument:undefined});\nif (tok_getNlwas() === true) {\nreturn THROW_RANGE('Found a newline between `throw` and its argument but that is not allowed', $tp_throw_start, tok_getStart());\n}\nlet tmpLexerFlags = (lexerFlags | 1824) ^ 1824;\nparseExpressions(tmpLexerFlags, 'argument');\nparseSemiOrAsi(lexerFlags);\nAST_close($tp_throw_start, $tp_throw_line, $tp_throw_column);\n}\nfunction parseTryStatement(lexerFlags, scoop, labelSet, astProp) {\nlet $tp_try_line = tok_getLine();\nlet $tp_try_column = tok_getColumn();\nlet $tp_try_start = tok_getStart();\nlet $tp_try_stop = tok_getStop();\nskipToCurlyOpenOrDie(lexerFlags);\nAST_open(astProp, {type:'TryStatement', loc:undefined, block:undefined, handler:undefined, finalizer:undefined});\nlet tryScoop = SCOPE_addLayer(scoop, 4, 'parseTryStatement(try)');\nparseBlockStatement(lexerFlags, tryScoop, labelSet, 'block');\nlet hasEither = false;\nif (tok_getType() === 2078) {\nhasEither = true;\nlet $tp_catch_line = tok_getLine();\nlet $tp_catch_column = tok_getColumn();\nlet $tp_catch_start = tok_getStart();\nskipAny(lexerFlags);\nAST_open('handler', {type:'CatchClause', loc:undefined, param:undefined, body:undefined});\nlet catchHeadScoop = SCOPE_addLayer(scoop, 5, 'parseTryStatement(catch-var)');\nlet catchBodyScoop = SCOPE_addLayer(catchHeadScoop, 6, 'parseTryStatement(catch-body)');\nif (tok_getType() === 16513) {\nif (!allowOptionalCatchBinding) {\nreturn THROW_RANGE('Missing the `catch` clause. Optional catch clause is only supported since ES10  ES2019', tok_getStart(), tok_getStop());\n}\nAST_set('param', null);\n} else if (tok_getType() === 16471) {\nskipToBindingStart(lexerFlags);\nif (tok_getType() === 16472) {\nreturn THROW_RANGE('The catch clause must have a binding', tok_getStart(), tok_getStop());\n}\nlet $tp_binding_line = tok_getLine();\nlet $tp_binding_column = tok_getColumn();\nlet $tp_binding_start = tok_getStart();\nparseBinding(lexerFlags | 4096, $tp_binding_start, $tp_binding_line, $tp_binding_column, catchHeadScoop, 10, 4, false, undefined, undefined, 'param');\nif (tok_getType() === 16480) {\nreturn THROW_RANGE('Catch clause requires exactly one parameter, not more (and no trailing comma)', tok_getStart(), tok_getStop());\n}\nif (tok_getType() !== 16472) {\nreturn THROW_RANGE(('Missing right paren for the catch clause, found `' + tok_sliceInput(tok_getStart(), tok_getStop())) + '` instead', tok_getStart(), tok_getStop());\n}\nskipToCurlyOpenOrDie(lexerFlags);\n} else {\nreturn THROW_RANGE(('Missing start of catch clause (`(`) or start of catch body (`{`), found `' + tok_sliceInput(tok_getStart(), tok_getStop())) + '` instead', tok_getStart(), tok_getStop());\n}\nparseBlockStatement(lexerFlags, catchBodyScoop, labelSet, 'body');\nAST_close($tp_catch_start, $tp_catch_line, $tp_catch_column);\n} else {\nAST_set('handler', null);\n}\nif (tok_getType() === 2092) {\nhasEither = true;\nskipToCurlyOpenOrDie(lexerFlags);\nlet finallyScoop = SCOPE_addLayer(scoop, 7, 'parseTryStatement(finally)');\nparseBlockStatement(lexerFlags, finallyScoop, labelSet, 'finalizer');\n} else {\nAST_set('finalizer', null);\n}\nAST_close($tp_try_start, $tp_try_line, $tp_try_column);\nif (!hasEither) {\nreturn THROW_RANGE('Try must have catch or finally', $tp_try_start, $tp_try_stop);\n}\n}\nfunction parseVarStatement(lexerFlags, scoop, astProp) {\nlet $tp_var_line = tok_getLine();\nlet $tp_var_column = tok_getColumn();\nlet $tp_var_start = tok_getStart();\nskipToBindingStart(lexerFlags);\nparseAnyVarDeclaration(lexerFlags, $tp_var_start, $tp_var_line, $tp_var_column, scoop, 2, 1, undefined, undefined, astProp);\n}\nfunction parseWhileStatement(lexerFlags, scoop, labelSet, astProp) {\nlet $tp_while_line = tok_getLine();\nlet $tp_while_column = tok_getColumn();\nlet $tp_while_start = tok_getStart();\nskipToParenOpenOrDie(lexerFlags);\nAST_open(astProp, {type:'WhileStatement', loc:undefined, test:undefined, body:undefined});\nparseStatementHeader(lexerFlags, 'test');\nparseNestedBodyPart(lexerFlags | 512, scoop, labelSet, false, 1, null, 'body');\nAST_close($tp_while_start, $tp_while_line, $tp_while_column);\n}\nfunction parseIdentLabelOrExpressionStatement(lexerFlags, scoop, labelSet, fdState, nestedLabels, astProp) {\nlet $tp_ident_type = tok_getType();\nlet $tp_ident_line = tok_getLine();\nlet $tp_ident_column = tok_getColumn();\nlet $tp_ident_start = tok_getStart();\nlet $tp_ident_stop = tok_getStop();\nlet $tp_ident_canon = tok_getCanoN();\nskipIdentSafeSlowAndExpensive(lexerFlags, false);\nif (tok_getType() === 16489) {\nreturn parseLabeledStatementInstead(lexerFlags, scoop, labelSet, $tp_ident_type, $tp_ident_start, $tp_ident_stop, $tp_ident_line, $tp_ident_column, $tp_ident_canon, fdState, nestedLabels, astProp);\n}\nAST_open(astProp, {type:'ExpressionStatement', loc:undefined, expression:undefined});\nparseExpressionsAfterIdent(lexerFlags, $tp_ident_type, $tp_ident_start, $tp_ident_stop, $tp_ident_line, $tp_ident_column, $tp_ident_canon, 'expression');\nparseSemiOrAsi(lexerFlags);\nAST_close($tp_ident_start, $tp_ident_line, $tp_ident_column);\n}\nfunction parseLabeledStatementInstead(lexerFlags, scoop, labelSet, $tp_ident_type, $tp_ident_start, $tp_ident_stop, $tp_ident_line, $tp_ident_column, $tp_ident_canon, fdState, nestedLabels, astProp) {\nif ((($tp_ident_type !== 2088) && ($tp_ident_type !== 2072))) {\nfatalBindingIdentCheck($tp_ident_type, $tp_ident_start, $tp_ident_stop, $tp_ident_canon, 0, lexerFlags);\n}\nlet set = labelSet;\nwhile (set) {\nif (set.statementLabels.has($tp_ident_canon)) {\nreturn THROW_RANGE('Saw the same label twice which is not allowed', $tp_ident_start, $tp_ident_stop);\n}\nset = set.parentLabels;\n}\nlabelSet = wrapLabelSet(labelSet, 'labelled statement');\nlabelSet.statementLabels.add($tp_ident_canon);\nskipToStatementStart(lexerFlags);\nif (fdState === 2) {\nfdState = 1;\n}\nif (nestedLabels === null) {\nnestedLabels = new Set();\n}\nnestedLabels.add($tp_ident_canon);\nif ((isIdentToken(tok_getType()) && (((((tok_getType() === 2093) || (tok_getType() === 2124))) || (tok_getType() === 2085))))) {\nlabelSet.iterationLabels = nestedLabels;\n}\nAST_open(astProp, {type:'LabeledStatement', loc:undefined, label:AST_getIdentNode($tp_ident_start, $tp_ident_stop, $tp_ident_line, $tp_ident_column, $tp_ident_canon), body:undefined});\nparseNestedBodyPart(lexerFlags, scoop, labelSet, true, fdState, nestedLabels, 'body');\nAST_close($tp_ident_start, $tp_ident_line, $tp_ident_column);\n}\nfunction parsePunctuatorStatement(lexerFlags, scoop, labelSet, astProp) {\nif (tok_getType() === 16513) {\nlet blockScoop = SCOPE_addLayer(scoop, 2, 'parsePunctuatorStatement.block');\nparseBlockStatement(lexerFlags, blockScoop, labelSet, astProp);\nreturn;\n}\nif (tok_getType() === 16490) {\nparseEmptyStatement(lexerFlags, astProp);\nreturn;\n}\nlet $tp_ident_line = tok_getLine();\nlet $tp_ident_column = tok_getColumn();\nlet $tp_ident_start = tok_getStart();\nAST_open(astProp, {type:'ExpressionStatement', loc:undefined, expression:undefined});\nparseExpressions(lexerFlags, 'expression');\nparseSemiOrAsi(lexerFlags);\nAST_close($tp_ident_start, $tp_ident_line, $tp_ident_column);\n}\nfunction parseEmptyStatement(lexerFlags, astProp) {\nlet $tp_semi_line = tok_getLine();\nlet $tp_semi_column = tok_getColumn();\nlet $tp_semi_start = tok_getStart();\nskipToStatementStart(lexerFlags);\nAST_setNode(astProp, {type:'EmptyStatement', loc:AST_getClosedLoc($tp_semi_start, $tp_semi_line, $tp_semi_column)});\n}\nfunction parseWithStatement(lexerFlags, scoop, labelSet, astProp) {\nlet $tp_with_line = tok_getLine();\nlet $tp_with_column = tok_getColumn();\nlet $tp_with_start = tok_getStart();\nlet $tp_with_stop = tok_getStop();\nif ((lexerFlags & 8192) === 8192) {\nreturn THROW_RANGE('The `with` statement is not allowed in strict mode', $tp_with_start, $tp_with_stop);\n}\nskipToParenOpenOrDie(lexerFlags);\nAST_open(astProp, {type:'WithStatement', loc:undefined, object:undefined, body:undefined});\nparseStatementHeader(lexerFlags, 'object');\nparseNestedBodyPart(lexerFlags, scoop, labelSet, false, 1, null, 'body');\nAST_close($tp_with_start, $tp_with_line, $tp_with_column);\n}\nfunction parseAnyVarDeclaration(lexerFlags, $tp_binding_start, $tp_binding_line, $tp_binding_column, scoop, bindingType, bindingOrigin, exportedNames, exportedBindings, astProp) {\nif (((((!isIdentToken(tok_getType())) && (tok_getType() !== 16509))) && (tok_getType() !== 16513))) {\nreturn THROW_RANGE('Expected identifier, or array/object destructuring', tok_getStart(), tok_getStop());\n}\nlet keyword = ((bindingType === 2)? 'var' : (((bindingType === 6)? 'let' : 'const')));\nAST_open(astProp, {type:'VariableDeclaration', loc:undefined, kind:keyword, declarations:[]});\nparseBindings(lexerFlags, scoop, bindingType, bindingOrigin, true, 0, exportedNames, exportedBindings, 'declarations');\nif (((bindingOrigin === 1) || (bindingOrigin === 3))) {\nparseSemiOrAsi(lexerFlags);\n}\nAST_close($tp_binding_start, $tp_binding_line, $tp_binding_column);\n}\nfunction parseBindings(lexerFlags, scoop, bindingType, bindingOrigin, defaultOptions, $tp_set_type, exportedNames, exportedBindings, astProp) {\nlet many = 0;\nlet inited = false;\nlet startWasObjectOrArray = ((tok_getType() === 16509) || (tok_getType() === 16513));\nlet paramsSimple = 1;\ndo {\n++many;\nlet $tp_bindingStart_type = tok_getType();\nlet $tp_bindingStart_line = tok_getLine();\nlet $tp_bindingStart_column = tok_getColumn();\nlet $tp_bindingStart_start = tok_getStart();\nlet wasRest = $tp_bindingStart_type === 16486;\nlet paramSimple = parseBinding(lexerFlags, $tp_bindingStart_start, $tp_bindingStart_line, $tp_bindingStart_column, scoop, bindingType, bindingOrigin, defaultOptions, exportedNames, exportedBindings, astProp);\nif ((wasRest && ($tp_set_type === 2112))) {\nreturn THROW_RANGE('A setter can not have a rest arg (unless inside a pattern)', $tp_bindingStart_start, tok_getStart());\n}\nif (paramSimple === 4) {\ninited = true;\nparamsSimple = 3;\n} else if (paramSimple === 3) {\nparamsSimple = 3;\n} else if (paramSimple === 2) {\nif (paramsSimple === 1) {\nparamsSimple = 2;\n}\n}\nif (wasRest) {\nbreak;\n}\nif (tok_getType() !== 16480) break;\nskipToBindingStartGrouped(lexerFlags);\nif (tok_getType() === 16472) {\nif (bindingType === 1) {\nif (allowTrailingFunctionComma) {\nreturn paramsSimple;\n}\nreturn THROW_RANGE('Targeted language version does not support trailing function arg comma', tok_getStart(), tok_getStop());\n}\n}\n} while (true);\nif (((many !== 1) && ($tp_set_type === 2112))) {\nreturn THROW_RANGE('Setters require exactly one parameter', tok_getStart(), tok_getStop());\n}\nif (((bindingOrigin === 2) && (((tok_getType() === 67636) || (tok_getType() === 2106))))) {\nif (many !== 1) {\nreturn THROW_RANGE('For-in and for-of can only have one binding, found ' + many, tok_getStart(), tok_getStop());\n}\nif ((inited && ((((((((startWasObjectOrArray || (options_webCompat === false))) || (bindingType !== 2))) || (tok_getType() === 2106))) || ((lexerFlags & 8192) === 8192))))) {\nreturn THROW_RANGE('For-in and for-of binding can not have an init', tok_getStart(), tok_getStop());\n}\n}\nreturn paramsSimple;\n}\nfunction parseBinding(lexerFlags, $tp_bindingStart_start, $tp_bindingStart_line, $tp_bindingStart_column, scoop, bindingType, bindingOrigin, defaultsOption, exportedNames, exportedBindings, astProp) {\nlet mustHaveInit = false;\nlet paramSimple = 0;\nif (isIdentToken(tok_getType())) {\nlet $tp_binding_type = tok_getType();\nlet $tp_binding_start = tok_getStart();\nlet $tp_binding_stop = tok_getStop();\nlet $tp_binding_canon = tok_getCanoN();\nfatalBindingIdentCheck($tp_binding_type, $tp_binding_start, $tp_binding_stop, $tp_binding_canon, bindingType, lexerFlags);\nif (bindingType === 10) {\nbindingType = 9;\n}\nSCOPE_actuallyAddBinding(lexerFlags, scoop, $tp_binding_start, $tp_binding_stop, $tp_binding_canon, bindingType);\naddNameToExports(exportedNames, $tp_binding_start, $tp_binding_stop, $tp_binding_canon);\naddBindingToExports(exportedBindings, $tp_binding_canon);\nlet $tp_ident_line = tok_getLine();\nlet $tp_ident_column = tok_getColumn();\nlet $tp_ident_start = tok_getStart();\nlet $tp_ident_stop = tok_getStop();\nlet $tp_ident_canon = tok_getCanoN();\nskipRex(lexerFlags);\nAST_setIdent(astProp, $tp_ident_start, $tp_ident_stop, $tp_ident_line, $tp_ident_column, $tp_ident_canon);\nif ((((lexerFlags & 8192) === 0) && (nonFatalBindingIdentCheck($tp_binding_type, $tp_binding_start, $tp_binding_stop, $tp_binding_canon, bindingType, lexerFlags | 8192) !== ''))) {\nparamSimple = 2;\n} else {\nparamSimple = 1;\n}\n} else if (tok_getType() === 16513) {\nlet destructible = parseObjectOuter(lexerFlags, scoop, bindingType, false, exportedNames, exportedBindings, astProp);\nverifyDestructibleForBinding(destructible, bindingType);\nAST_destruct(astProp);\nparamSimple = 3;\nif (((((bindingOrigin !== 4) && (((bindingOrigin !== 2) || (((tok_getType() !== 67636) && (tok_getType() !== 2106))))))) && (((((bindingType === 7) || (bindingType === 6))) || (bindingType === 2))))) {\nmustHaveInit = true;\n}\n} else if (tok_getType() === 16509) {\nlet destructible = parseArrayOuter(lexerFlags, scoop, bindingType, false, exportedNames, exportedBindings, astProp);\nverifyDestructibleForBinding(destructible, bindingType);\nAST_destruct(astProp);\nparamSimple = 3;\nif (((((bindingOrigin !== 4) && (((bindingOrigin !== 2) || (((tok_getType() !== 67636) && (tok_getType() !== 2106))))))) && (((((bindingType === 7) || (bindingType === 6))) || (bindingType === 2))))) {\nmustHaveInit = true;\n}\n} else if (tok_getType() === 16486) {\nif (bindingType !== 1) {\nreturn THROW_RANGE('Rest is not allowed as toplevel for var/let/const declaration binding', tok_getStart(), tok_getStop());\n}\nlet subDestruct = parseArrowableSpreadOrRest(lexerFlags, scoop, 16472, bindingType, 0, exportedNames, exportedBindings, astProp);\nverifyDestructibleForBinding(subDestruct, bindingType);\nparamSimple = 3;\n} else if (tok_getType() !== 16472) {\nreturn THROW_RANGE('Expected to parse a(nother) binding but none was found', tok_getStart(), tok_getStop());\n}\nif (tok_getType() === 49264) {\nif (bindingOrigin === 4) {\nreturn THROW_RANGE('Catch clause can not have init / default', tok_getStart(), tok_getStop());\n}\nskipToExpressionStart(lexerFlags);\nparamSimple = 4;\nif (defaultsOption === false) {\nAST_wrapClosedCustom(astProp, {type:'AssignmentPattern', loc:undefined, left:undefined, right:undefined}, 'left');\nparseExpression(lexerFlags, 'right');\nAST_close($tp_bindingStart_start, $tp_bindingStart_line, $tp_bindingStart_column);\n} else {\nAST_wrapClosedCustom('declarations', {type:'VariableDeclarator', loc:undefined, id:undefined, init:undefined}, 'id');\nparseExpression(lexerFlags, 'init');\nAST_close($tp_bindingStart_start, $tp_bindingStart_line, $tp_bindingStart_column);\n}\n} else if (mustHaveInit) {\nreturn THROW_RANGE('Declaration destructuring must have init', tok_getStart(), tok_getStop());\n} else if (((bindingType === 7) && (((bindingOrigin !== 2) || (((tok_getType() === 16490) || (tok_getType() === 16480))))))) {\nreturn THROW_RANGE('Constants must be initialized', tok_getStart(), tok_getStop());\n} else if (defaultsOption === true) {\nif (((tok_getNlwas() === true) && isRegexToken(tok_getType()))) {\nif (bindingOrigin === 2) {\nreturn THROW_RANGE('Illegal regex after binding declaration in `for` header', tok_getStart(), tok_getStop());\n}\nASSERT_ASI_REGEX_NEXT = true;\n}\nAST_setNodeDangerously('declarations', {type:'VariableDeclarator', loc:AST_getClosedLoc($tp_bindingStart_start, $tp_bindingStart_line, $tp_bindingStart_column), id:AST_popNode('declarations'), init:null});\n} else {\n\n}\nreturn paramSimple;\n}\nfunction fatalBindingIdentCheck($tp_ident_type, $tp_ident_start, $tp_ident_stop, $tp_ident_canon, bindingType, lexerFlags) {\nlet str = nonFatalBindingIdentCheck($tp_ident_type, $tp_ident_start, $tp_ident_stop, $tp_ident_canon, bindingType, lexerFlags);\nif (str !== '') THROW_RANGE(`Cannot use this name (\\`${tok_sliceInput($tp_ident_start, $tp_ident_stop)}\\`) as a variable name because: ${str}`, $tp_ident_start, $tp_ident_stop);\n}\nfunction nonFatalBindingIdentCheck($tp_ident_type, $tp_ident_start, $tp_ident_stop, $tp_ident_canon, bindingType, lexerFlags) {\nif (($tp_ident_stop - $tp_ident_start) === $tp_ident_canon.length) {\nif ($tp_ident_type === 2048) return '';\nreturn nonFatalBindingIdentCheckByEnum(lexerFlags, $tp_ident_type, $tp_ident_canon, bindingType);\n}\nreturn nonFatalBindingIdentCheckByString(lexerFlags, $tp_ident_canon, bindingType);\n}\nfunction nonFatalBindingIdentCheckByEnum(lexerFlags, $tp_ident_type, $tp_ident_canon, bindingType) {\nswitch ($tp_ident_type) {\ncase 2076:\n\ncase 2077:\n\ncase 2078:\n\ncase 2079:\n\ncase 2080:\n\ncase 2081:\n\ncase 2082:\n\ncase 2083:\n\ncase 2084:\n\ncase 2085:\n\ncase 2086:\n\ncase 2089:\n\ncase 2090:\n\ncase 2092:\n\ncase 2093:\n\ncase 2095:\n\ncase 2097:\n\ncase 2099:\n\ncase 67636:\n\ncase 67637:\n\ncase 2104:\n\ncase 2111:\n\ncase 2114:\n\ncase 2115:\n\ncase 2117:\n\ncase 2118:\n\ncase 2120:\n\ncase 2121:\n\ncase 2122:\n\ncase 2123:\n\ncase 2124:\n\ncase 2125:\n\ncase 2105:\n\ncase 2119:\n\ncase 2091:\n\ncase 2087:\nreturn 'Cannot never use this reserved word as a variable name';\ncase 2103:\nif (bindingType === 8) return 'Can not use `let` as a class name';\nif (((bindingType === 6) || (bindingType === 7))) return 'Can not use `let` when binding through `let` or `const`';\nif ((lexerFlags & 8192) === 8192) return 'Can not use `let` as variable name in strict mode';\nreturn '';\ncase 2113:\nif ((lexerFlags & 8192) === 8192) return '`static` is a reserved word in strict mode';\nreturn '';\ncase 2088:\n\ncase 2072:\nif ((lexerFlags & 8192) === 8192) return ('Cannot create a binding named `' + $tp_ident_canon) + '` in strict mode';\nreturn '';\ncase 2098:\n\ncase 2107:\n\ncase 2109:\n\ncase 2102:\n\ncase 2108:\n\ncase 2110:\nif ((lexerFlags & 8192) === 8192) return 'Cannot use this reserved word as a variable name in strict mode';\nreturn '';\ncase 2075:\nif (allowAsyncFunctions) {\nif (goalMode === true) return 'Await is illegal as var name with module goal';\nif ((lexerFlags & 8) !== 0) return 'Await not allowed here';\n}\nreturn '';\ncase 2126:\nif ((lexerFlags & 8192) === 8192) return 'Cannot use this reserved word as a variable name in strict mode';\nif ((lexerFlags & 128) !== 0) return 'Cannot use this reserved word as a variable name inside a generator';\nreturn '';\n}\nreturn '';\n}\nfunction nonFatalBindingIdentCheckByString(lexerFlags, $tp_ident_canon, bindingType) {\nswitch ($tp_ident_canon) {\ncase 'break':\n\ncase 'case':\n\ncase 'catch':\n\ncase 'class':\n\ncase 'const':\n\ncase 'continue':\n\ncase 'debugger':\n\ncase 'default':\n\ncase 'delete':\n\ncase 'do':\n\ncase 'else':\n\ncase 'export':\n\ncase 'extends':\n\ncase 'finally':\n\ncase 'for':\n\ncase 'function':\n\ncase 'if':\n\ncase 'import':\n\ncase 'in':\n\ncase 'instanceof':\n\ncase 'new':\n\ncase 'return':\n\ncase 'super':\n\ncase 'switch':\n\ncase 'this':\n\ncase 'throw':\n\ncase 'try':\n\ncase 'typeof':\n\ncase 'var':\n\ncase 'void':\n\ncase 'while':\n\ncase 'with':\n\ncase 'null':\n\ncase 'true':\n\ncase 'false':\n\ncase 'enum':\nreturn ('Keywords may not have escapes in their name and this resolves to `' + $tp_ident_canon) + '`';\ncase 'let':\nif (bindingType === 8) return 'Can not use `let` as a class name';\nif (((bindingType === 6) || (bindingType === 7))) return 'Can not use `let` when binding through `let` or `const`';\nif ((lexerFlags & 8192) === 8192) return 'Can not use `let` as variable name in strict mode';\nreturn '';\ncase 'static':\nif ((lexerFlags & 8192) === 8192) return ('Keywords may not have escapes in their name and this resolves to `' + $tp_ident_canon) + '`';\nreturn '';\ncase 'eval':\n\ncase 'arguments':\nif ((lexerFlags & 8192) === 8192) return ('Cannot create a binding named `' + $tp_ident_canon) + '` in strict mode';\nreturn '';\ncase 'implements':\n\ncase 'package':\n\ncase 'protected':\n\ncase 'interface':\n\ncase 'private':\n\ncase 'public':\nif ((lexerFlags & 8192) === 8192) return ('Keywords may not have escapes in their name and this resolves to `' + $tp_ident_canon) + '`';\nreturn '';\ncase 'await':\nif (allowAsyncFunctions) {\nif (goalMode === true) return 'Await is illegal as var name with module goal';\nif ((lexerFlags & 8) !== 0) return 'Await not allowed here';\n}\nreturn '';\ncase 'yield':\nif ((lexerFlags & 8192) === 8192) return 'Cannot use this reserved word as a variable name in strict mode';\nif ((lexerFlags & 128) !== 0) return 'Cannot use this reserved word as a variable name inside a generator';\nreturn '';\n}\nreturn '';\n}\nfunction parseExpression(lexerFlags, astProp) {\nlet $tp_start_line = tok_getLine();\nlet $tp_start_column = tok_getColumn();\nlet $tp_start_start = tok_getStart();\nlet $tp_start_stop = tok_getStop();\nlet assignable = parseValue(lexerFlags, true, 4, false, astProp);\nreturn parseExpressionFromOp(lexerFlags, $tp_start_start, $tp_start_stop, $tp_start_line, $tp_start_column, assignable, astProp);\n}\nfunction parseExpressionAfterLiteral(lexerFlags, $tp_literal_start, $tp_literal_stop, $tp_literal_line, $tp_literal_column, astProp) {\nlet assignable = parseValueTail(lexerFlags, $tp_literal_start, $tp_literal_line, $tp_literal_column, 16, 4, false, astProp);\nparseExpressionFromOp(lexerFlags, $tp_literal_start, $tp_literal_stop, $tp_literal_line, $tp_literal_column, assignable, astProp);\n}\nfunction parseExpressionAfterIdent(lexerFlags, $tp_ident_type, $tp_ident_start, $tp_ident_stop, $tp_ident_line, $tp_ident_column, $tp_ident_canon, bindingType, astProp) {\nlet assignable = parseValueAfterIdent(lexerFlags, $tp_ident_type, $tp_ident_start, $tp_ident_stop, $tp_ident_line, $tp_ident_column, $tp_ident_canon, bindingType, true, astProp);\nassignable = parseExpressionFromOp(lexerFlags, $tp_ident_start, $tp_ident_stop, $tp_ident_line, $tp_ident_column, assignable, astProp);\nreturn assignable;\n}\nfunction parseExpressionAfterAsyncAsVarName(lexerFlags, stmtOrExpr, $tp_async_start, $tp_async_stop, $tp_async_line, $tp_async_column, $tp_async_canon, isNewArg, allowAssignment, astProp) {\nif (stmtOrExpr === 2) {\nAST_open(astProp, {type:'ExpressionStatement', loc:undefined, expression:undefined});\nastProp = 'expression';\n}\nlet assignable = 16;\nif (tok_getType() === 16499) {\nassignable = parseArrowParenlessFromPunc(lexerFlags, $tp_async_start, $tp_async_line, $tp_async_column, 2074, $tp_async_start, $tp_async_stop, $tp_async_line, $tp_async_column, $tp_async_canon, allowAssignment, 1, 0, astProp);\n} else {\nassignable = parseIdentOrParenlessArrow(lexerFlags, 2074, $tp_async_start, $tp_async_stop, $tp_async_line, $tp_async_column, $tp_async_canon, 32, allowAssignment, astProp);\nassignable = parseValueTail(lexerFlags, $tp_async_start, $tp_async_line, $tp_async_column, assignable, isNewArg, false, astProp);\nif (stmtOrExpr === 2) {\nassignable = parseExpressionFromOp(lexerFlags, $tp_async_start, $tp_async_stop, $tp_async_line, $tp_async_column, assignable, astProp);\n}\n}\nif (stmtOrExpr === 2) {\nif (tok_getType() === 16480) {\n_parseExpressions(lexerFlags, $tp_async_start, $tp_async_line, $tp_async_column, 16, astProp);\n}\nparseSemiOrAsi(lexerFlags);\nAST_close($tp_async_start, $tp_async_line, $tp_async_column);\n}\nreturn assignable;\n}\nfunction parseParenlessArrowAfterAsync(lexerFlags, fromStmtOrExpr, allowAssignment, $tp_async_start, $tp_async_line, $tp_async_column, astProp) {\nif (fromStmtOrExpr === 2) {\nAST_open(astProp, {type:'ExpressionStatement', loc:undefined, expression:undefined});\nastProp = 'expression';\n}\nif (tok_getType() === 2075) {\nreturn THROW_RANGE('Cannot use `await` as an arg name with async arrows', tok_getStart(), tok_getStop());\n}\nlet $tp_ident_type = tok_getType();\nlet $tp_ident_line = tok_getLine();\nlet $tp_ident_column = tok_getColumn();\nlet $tp_ident_start = tok_getStart();\nlet $tp_ident_stop = tok_getStop();\nlet $tp_ident_canon = tok_getCanoN();\nlet isSimple = 1;\nif (isStrictOnlyKeyword($tp_ident_type, $tp_ident_start, $tp_ident_stop, $tp_ident_canon)) {\nisSimple = 2;\n}\nskipToArrowOrDie(lexerFlags);\nparseArrowParenlessFromPunc(lexerFlags, $tp_async_start, $tp_async_line, $tp_async_column, $tp_ident_type, $tp_ident_start, $tp_ident_stop, $tp_ident_line, $tp_ident_column, $tp_ident_canon, allowAssignment, isSimple, 2074, astProp);\nif (fromStmtOrExpr === 2) {\nif (tok_getType() === 16480) {\n_parseExpressions(lexerFlags, $tp_async_start, $tp_async_line, $tp_async_column, 16, astProp);\n}\nparseSemiOrAsi(lexerFlags);\nAST_close($tp_async_start, $tp_async_line, $tp_async_column);\n}\n}\nfunction isStrictOnlyKeyword($tp_ident_type, $tp_ident_start, $tp_ident_stop, $tp_ident_canon) {\nif ($tp_ident_canon.length === ($tp_ident_stop - $tp_ident_start)) {\nreturn isStrictOnlyKeywordByEnum($tp_ident_type);\n}\nreturn isStrictOnlyKeywordByString($tp_ident_canon);\n}\nfunction isStrictOnlyKeywordByEnum($tp_ident_type) {\nswitch ($tp_ident_type) {\ncase 2088:\n\ncase 2072:\n\ncase 2098:\n\ncase 2102:\n\ncase 2103:\n\ncase 2107:\n\ncase 2108:\n\ncase 2109:\n\ncase 2110:\n\ncase 2113:\n\ncase 2126:\nreturn true;\n}\nreturn false;\n}\nfunction isStrictOnlyKeywordByString($tp_ident_canon) {\nswitch ($tp_ident_canon) {\ncase 'eval':\n\ncase 'arguments':\n\ncase 'implements':\n\ncase 'interface':\n\ncase 'let':\n\ncase 'package':\n\ncase 'private':\n\ncase 'protected':\n\ncase 'public':\n\ncase 'static':\n\ncase 'yield':\nreturn true;\n}\nreturn false;\n}\nfunction parseExpressionFromOp(lexerFlags, $tp_firstExpr_start, $tp_firstExpr_stop, $tp_firstExpr_line, $tp_firstExpr_column, assignable, astProp) {\nif (isAnyAssignmentOp()) {\nif (notAssignable(assignable)) {\nreturn THROW_RANGE(('Cannot assign to lhs (starting with `' + tok_sliceInput($tp_firstExpr_start, $tp_firstExpr_stop)) + '`) because it is not a valid assignment target', tok_getStart(), tok_getStop());\n}\nreturn parseExpressionFromAssignmentOp(lexerFlags, $tp_firstExpr_start, $tp_firstExpr_line, $tp_firstExpr_column, assignable, astProp);\n}\nreturn parseExpressionFromBinaryOp(lexerFlags, $tp_firstExpr_start, $tp_firstExpr_line, $tp_firstExpr_column, assignable, astProp);\n}\nfunction parseExpressionFromAssignmentOp(lexerFlags, $tp_firstAssignment_start, $tp_firstAssignment_line, $tp_firstAssignment_column, lhsAssignable, astProp) {\nlet $tp_eq_type = tok_getType();\nAST_convertArrayToPattern($tp_eq_type, astProp);\nAST_wrapClosedCustom(astProp, {type:'AssignmentExpression', loc:undefined, left:undefined, operator:tok_sliceInput(tok_getStart(), tok_getStop()), right:undefined}, 'left');\nskipToExpressionStart(lexerFlags);\nlet rhsAssignable = parseExpression(lexerFlags, 'right');\nAST_close($tp_firstAssignment_start, $tp_firstAssignment_line, $tp_firstAssignment_column);\nreturn setNotAssignable(mergeAssignable(rhsAssignable, lhsAssignable));\n}\nfunction parseExpressionFromBinaryOp(lexerFlags, $tp_firstExpr_start, $tp_firstExpr_line, $tp_firstExpr_column, assignable, astProp) {\nif ((assignable & 1024) === 1024) return assignable;\nlet $tp_next_type = tok_getType();\nlet repeat = false;\ndo {\nrepeat = false;\nif ($tp_next_type === 16506) {\nlet nowAssignable = parseExpressionFromTernaryOp(lexerFlags, $tp_firstExpr_start, $tp_firstExpr_line, $tp_firstExpr_column, astProp);\nassignable = setNotAssignable(nowAssignable | assignable);\nrepeat = true;\n} else if (isNonAssignBinOp($tp_next_type, lexerFlags)) {\nlet nowAssignable = parseExpressionFromBinaryOpOnlyStronger(lexerFlags, $tp_firstExpr_start, $tp_firstExpr_line, $tp_firstExpr_column, 0, astProp);\nassignable = setNotAssignable(nowAssignable | assignable);\nrepeat = true;\n}\n$tp_next_type = tok_getType();\n} while (repeat);\nif (isAnyAssignmentOp()) {\nreturn THROW_RANGE('Can not have an assignment after a non-assignment operator', tok_getStart(), tok_getStop());\n}\nreturn assignable;\n}\nfunction preventNullishWithLogic($tp_op_type, $tp_op_start, $tp_op_stop, coalSeen) {\nif ((($tp_op_type === 82005) || ($tp_op_type === 82051))) {\nif (coalSeen === 1) {\nreturn THROW_RANGE('Cannot use `??` and `&&`/`||` in the same expression without some grouping', $tp_op_start, $tp_op_stop);\n}\nreturn 2;\n}\nif ($tp_op_type === 82044) {\nif (coalSeen === 2) {\nreturn THROW_RANGE('Cannot use `??` and `&&`/`||` in the same expression without some grouping', $tp_op_start, $tp_op_stop);\n}\nreturn 1;\n}\nreturn coalSeen;\n}\nfunction parseExpressionFromBinaryOpOnlyStronger(lexerFlags, $tp_firstExpr_start, $tp_firstExpr_line, $tp_firstExpr_column, coalSeen, astProp) {\nlet $tp_op_type = tok_getType();\nlet $tp_op_start = tok_getStart();\nlet $tp_op_stop = tok_getStop();\ncoalSeen = preventNullishWithLogic($tp_op_type, $tp_op_start, $tp_op_stop, coalSeen);\nlet AST_nodeName = (((((($tp_op_type === 82005) || ($tp_op_type === 82051))) || ($tp_op_type === 82044)))? 'LogicalExpression' : 'BinaryExpression');\nAST_wrapClosedCustom(astProp, {type:AST_nodeName, loc:undefined, left:undefined, operator:tok_sliceInput($tp_op_start, $tp_op_stop), right:undefined}, 'left');\nskipToExpressionStart(lexerFlags);\nlet $tp_rightExprStart_line = tok_getLine();\nlet $tp_rightExprStart_column = tok_getColumn();\nlet $tp_rightExprStart_start = tok_getStart();\nlet assignable = parseValue(lexerFlags, false, 4, false, 'right');\nlet otherStrength = getStrength($tp_op_type, $tp_op_start, $tp_op_stop);\nwhile (continueParsingBinOp(lexerFlags, otherStrength)) {\nassignable |= parseExpressionFromBinaryOpOnlyStronger(lexerFlags, $tp_rightExprStart_start, $tp_rightExprStart_line, $tp_rightExprStart_column, coalSeen, 'right');\n}\npreventNullishWithLogic(tok_getType(), tok_getStart(), tok_getStop(), coalSeen);\nAST_close($tp_firstExpr_start, $tp_firstExpr_line, $tp_firstExpr_column);\nreturn setNotAssignable(assignable);\n}\nfunction parseExpressionFromTernaryOp(lexerFlags, $tp_firstExpr_start, $tp_firstExpr_line, $tp_firstExpr_column, astProp) {\nAST_wrapClosedCustom(astProp, {type:'ConditionalExpression', loc:undefined, test:undefined, consequent:undefined, alternate:undefined}, 'test');\nskipToExpressionStart(lexerFlags);\nlet midAssignable = parseExpression(((lexerFlags | 32) ^ 32) | 4096, 'consequent');\nif (tok_getType() !== 16489) {\nif (tok_getType() === 16480) {\nreturn THROW_RANGE('Can not use comma inside ternary expressions', tok_getStart(), tok_getStop());\n}\nreturn THROW_RANGE('Unexpected character inside ternary', tok_getStart(), tok_getStop());\n}\nskipToExpressionStart(lexerFlags);\nlet rhsAssignable = parseExpression(lexerFlags, 'alternate');\nAST_close($tp_firstExpr_start, $tp_firstExpr_line, $tp_firstExpr_column);\nreturn setNotAssignable(midAssignable | rhsAssignable);\n}\nfunction parseExpressionsAfterIdent(lexerFlags, $tp_ident_type, $tp_ident_start, $tp_ident_stop, $tp_ident_line, $tp_ident_column, $tp_ident_canon, astProp) {\nlet assignableForPiggies = parseExpressionAfterIdent(lexerFlags, $tp_ident_type, $tp_ident_start, $tp_ident_stop, $tp_ident_line, $tp_ident_column, $tp_ident_canon, 0, astProp);\nif (tok_getType() === 16480) {\nassignableForPiggies = _parseExpressions(lexerFlags, $tp_ident_start, $tp_ident_line, $tp_ident_column, assignableForPiggies, astProp);\n}\nreturn assignableForPiggies;\n}\nfunction parseExpressions(lexerFlags, astProp) {\nlet $tp_startOfFirstExpr_line = tok_getLine();\nlet $tp_startOfFirstExpr_column = tok_getColumn();\nlet $tp_startOfFirstExpr_start = tok_getStart();\nlet assignableForPiggies = parseExpression(lexerFlags, astProp);\nif (tok_getType() === 16480) {\nassignableForPiggies = _parseExpressions(lexerFlags, $tp_startOfFirstExpr_start, $tp_startOfFirstExpr_line, $tp_startOfFirstExpr_column, assignableForPiggies, astProp);\n}\nreturn assignableForPiggies;\n}\nfunction _parseExpressions(lexerFlags, $tp_startOfFirstExpr_start, $tp_startOfFirstExpr_line, $tp_startOfFirstExpr_colun, assignableForPiggies, astProp) {\nAST_wrapClosedIntoArrayCustom(astProp, {type:'SequenceExpression', loc:undefined, expressions:undefined}, 'expressions');\nassignableForPiggies = __parseExpressions(lexerFlags, assignableForPiggies, 'expressions');\nAST_close($tp_startOfFirstExpr_start, $tp_startOfFirstExpr_line, $tp_startOfFirstExpr_colun);\nreturn assignableForPiggies;\n}\nfunction __parseExpressions(lexerFlags, assignableForPiggies, astProp) {\ndo {\nskipToExpressionStart(lexerFlags);\nlet nowAssignable = parseExpression(lexerFlags, astProp);\nassignableForPiggies |= nowAssignable;\n} while (tok_getType() === 16480);\nreturn setNotAssignable(assignableForPiggies);\n}\nfunction isAnyAssignmentOp() {\nif (!((tok_getType() & 32768) === 32768)) return false;\nif (tok_getType() !== 49244) return true;\nif (!allowExponentiation) {\nreturn THROW_RANGE('`**` was introduced in ES7', tok_getStart(), tok_getStop());\n}\nreturn true;\n}\nfunction isNonAssignBinOp(type, lexerFlags) {\nif (!((type & 65536) === 65536)) return false;\nif (type === 82010) {\nif (!allowExponentiation) {\nreturn THROW_RANGE('`**` was introduced in ES7', tok_getStart(), tok_getStop());\n}\nreturn true;\n}\nif (type === 67636) {\nreturn (lexerFlags & 32) === 0;\n}\nreturn true;\n}\nfunction getStrength(type, $tp_tokenStart, $tp_tokenStop) {\nswitch (type) {\ncase 82010:\nreturn 16;\ncase 82009:\nreturn 15;\ncase 82023:\nreturn 15;\ncase 82002:\nreturn 15;\ncase 82013:\nreturn 14;\ncase 82017:\nreturn 14;\ncase 82028:\nreturn 13;\ncase 82037:\nreturn 13;\ncase 82038:\nreturn 13;\ncase 82027:\nreturn 12;\ncase 82029:\nreturn 12;\ncase 82036:\nreturn 12;\ncase 82039:\nreturn 12;\ncase 67636:\nreturn 12;\ncase 67637:\nreturn 12;\ncase 82033:\nreturn 11;\ncase 82000:\nreturn 11;\ncase 82034:\nreturn 11;\ncase 82001:\nreturn 11;\ncase 82004:\nreturn 10;\ncase 82047:\nreturn 9;\ncase 82050:\nreturn 8;\ncase 82044:\nreturn 7;\ncase 82005:\nreturn 6;\ncase 82051:\nreturn 5;\n}\nTHROW_RANGE('Unknown operator', $tp_tokenStart, $tp_tokenStop);\n}\nfunction continueParsingBinOp(lexerFlags, otherStrength) {\nswitch (tok_getType()) {\ncase 82033:\nreturn 11 > otherStrength;\ncase 82000:\nreturn 11 > otherStrength;\ncase 82034:\nreturn 11 > otherStrength;\ncase 82001:\nreturn 11 > otherStrength;\ncase 82005:\nreturn 6 > otherStrength;\ncase 82051:\nreturn 5 > otherStrength;\ncase 82013:\nreturn 14 > otherStrength;\ncase 82017:\nreturn 14 > otherStrength;\ncase 82027:\nreturn 12 > otherStrength;\ncase 82036:\nreturn 12 > otherStrength;\ncase 82029:\nreturn 12 > otherStrength;\ncase 82039:\nreturn 12 > otherStrength;\ncase 82009:\nreturn 15 > otherStrength;\ncase 82023:\nreturn 15 > otherStrength;\ncase 82002:\nreturn 15 > otherStrength;\ncase 82028:\nreturn 13 > otherStrength;\ncase 82037:\nreturn 13 > otherStrength;\ncase 82038:\nreturn 13 > otherStrength;\ncase 67636:\nif ((lexerFlags & 32) === 32) {\nreturn false;\n}\nreturn 12 > otherStrength;\ncase 67637:\nreturn 12 > otherStrength;\ncase 82004:\nreturn 10 > otherStrength;\ncase 82047:\nreturn 9 > otherStrength;\ncase 82050:\nreturn 8 > otherStrength;\ncase 82044:\nreturn 7 > otherStrength;\ncase 82010:\nif (!allowExponentiation) {\nreturn THROW_RANGE('`**` was introduced in ES7', tok_getStart(), tok_getStop());\n}\nreturn true;\n}\nreturn false;\n}\nfunction parseValue(lexerFlags, allowAssignment, isNewArg, leftHandSideExpression, astProp) {\nlet $tp_start_line = tok_getLine();\nlet $tp_start_column = tok_getColumn();\nlet $tp_start_start = tok_getStart();\nlet assignable = parseValueHeadBody(lexerFlags, false, isNewArg, allowAssignment, leftHandSideExpression, astProp);\nreturn parseValueTail(lexerFlags, $tp_start_start, $tp_start_line, $tp_start_column, assignable, isNewArg, leftHandSideExpression, astProp);\n}\nfunction parseValueAfterIdent(lexerFlags, $tp_ident_type, $tp_ident_start, $tp_ident_stop, $tp_ident_line, $tp_ident_column, $tp_ident_canon, bindingType, allowAssignment, astProp) {\nlet assignable = parseValueHeadBodyAfterIdent(lexerFlags, $tp_ident_type, $tp_ident_start, $tp_ident_stop, $tp_ident_line, $tp_ident_column, $tp_ident_canon, bindingType, 4, allowAssignment, false, astProp);\nreturn parseValueTail(lexerFlags, $tp_ident_start, $tp_ident_line, $tp_ident_column, assignable, 4, false, astProp);\n}\nfunction parseValueHeadBody(lexerFlags, maybe, isNewArg, allowAssignment, leftHandSideExpression, astProp) {\nlet start_for_assert;\nif (isIdentToken(tok_getType())) {\nreturn parseValueHeadBodyIdent(lexerFlags, isNewArg, 0, allowAssignment, leftHandSideExpression, astProp);\n}\nif (isNumberStringRegex(tok_getType())) {\nlet $tp_lit_type = tok_getType();\nlet $tp_lit_line = tok_getLine();\nlet $tp_lit_column = tok_getColumn();\nlet $tp_lit_start = tok_getStart();\nlet $tp_lit_stop = tok_getStop();\nlet $tp_lit_canon = tok_getCanoN();\nskipDiv(lexerFlags);\nAST_setLiteral(astProp, $tp_lit_type, $tp_lit_start, $tp_lit_stop, $tp_lit_line, $tp_lit_column, $tp_lit_canon);\nreturn 16;\n}\nif (isTemplateStart(tok_getType())) {\nlet $tp_tick_line = tok_getLine();\nlet $tp_tick_column = tok_getColumn();\nlet $tp_tick_start = tok_getStart();\nlet $tp_tick_stop = tok_getStop();\nparseTickExpression(lexerFlags, $tp_tick_start, $tp_tick_stop, $tp_tick_line, $tp_tick_column, astProp);\nreturn 16;\n}\nif (isPunctuatorToken(tok_getType())) {\nif (tok_getType() === 16513) {\nlet skipInit = ((((((allowAssignment === true) && (leftHandSideExpression === false))) && (isNewArg === 4)))? true : false);\nlet wasDestruct = parseObjectOuter(lexerFlags, null, 0, skipInit, undefined, undefined, astProp);\nreturn _parseValueHeadBodyAfterObjArr(wasDestruct);\n}\nif (tok_getType() === 16509) {\nlet skipInit = ((((((allowAssignment === true) && (leftHandSideExpression === false))) && (isNewArg === 4)))? true : false);\nlet wasDestruct = parseArrayOuter(lexerFlags, null, 0, skipInit, undefined, undefined, astProp);\nreturn _parseValueHeadBodyAfterObjArr(wasDestruct);\n}\nif (tok_getType() === 16471) {\nreturn parseGroupToplevels(lexerFlags, 2, allowAssignment, 0, 0, 0, 0, 0, '', false, leftHandSideExpression, astProp);\n}\nif (tok_getType() === 16478) {\nreturn parseUpdatePrefix(lexerFlags, isNewArg, leftHandSideExpression, '++', astProp);\n}\nif (tok_getType() === 16482) {\nreturn parseUpdatePrefix(lexerFlags, isNewArg, leftHandSideExpression, '--', astProp);\n}\nif (tok_getType() === 82013) {\nreturn parseUnary(lexerFlags, isNewArg, leftHandSideExpression, '+', astProp);\n}\nif (tok_getType() === 82017) {\nreturn parseUnary(lexerFlags, isNewArg, leftHandSideExpression, '-', astProp);\n}\nif (tok_getType() === 16463) {\nreturn parseUnary(lexerFlags, isNewArg, leftHandSideExpression, '!', astProp);\n}\nif (tok_getType() === 16518) {\nreturn parseUnary(lexerFlags, isNewArg, leftHandSideExpression, '~', astProp);\n}\n}\nif (maybe === false) {\nif (tok_getType() === 16486) {\nreturn THROW_RANGE('Unexpected spread/rest dots', tok_getStart(), tok_getStart() + 1);\n}\nif (tok_getType() === 16485) {\nreturn THROW_RANGE('Unexpected dot', tok_getStart(), tok_getStop());\n}\nreturn THROW_RANGE('Expected to parse a value', tok_getStart(), tok_getStop());\n}\nreturn 16;\n}\nfunction _parseValueHeadBodyAfterObjArr(wasDestruct) {\nif ((wasDestruct & 4) === 4) {\nreturn THROW_RANGE('Found a struct that must be destructured but was not', tok_getStart(), tok_getStop());\n}\nlet assignable = copyPiggies(0, wasDestruct);\nif ((wasDestruct & 1) === 0) {\nreturn setAssignable(assignable);\n}\nreturn setNotAssignable(assignable);\n}\nfunction parseValueHeadBodyIdent(lexerFlags, isNewArg, bindingType, allowAssignment, leftHandSideExpression, astProp) {\nlet $tp_ident_type = tok_getType();\nlet $tp_ident_line = tok_getLine();\nlet $tp_ident_column = tok_getColumn();\nlet $tp_ident_start = tok_getStart();\nlet $tp_ident_stop = tok_getStop();\nlet $tp_ident_canon = tok_getCanoN();\nskipIdentSafeSlowAndExpensive(lexerFlags, leftHandSideExpression);\nreturn parseValueHeadBodyAfterIdent(lexerFlags, $tp_ident_type, $tp_ident_start, $tp_ident_stop, $tp_ident_line, $tp_ident_column, $tp_ident_canon, bindingType, isNewArg, allowAssignment, leftHandSideExpression, astProp);\n}\nfunction parseValueHeadBodyAfterIdent(lexerFlags, $tp_ident_type, $tp_ident_start, $tp_ident_stop, $tp_ident_line, $tp_ident_column, $tp_ident_canon, bindingType, isNewArg, allowAssignment, leftHandSideExpression, astProp) {\nswitch ($tp_ident_type) {\ncase 2072:\n{\nif (tok_getType() === 16499) {\nif ((lexerFlags & 8192) === 8192) {\nreturn THROW_RANGE('Can not use `arguments` as arg name in strict mode', $tp_ident_start, $tp_ident_stop);\n}\nreturn parseArrowParenlessFromPunc(lexerFlags, $tp_ident_start, $tp_ident_line, $tp_ident_column, $tp_ident_type, $tp_ident_start, $tp_ident_stop, $tp_ident_line, $tp_ident_column, $tp_ident_canon, true, 3, 0, astProp);\n}\nAST_setIdent(astProp, $tp_ident_start, $tp_ident_stop, $tp_ident_line, $tp_ident_column, $tp_ident_canon);\nreturn verifyEvalArgumentsVar(lexerFlags);\n}\ncase 2074:\nreturn parseAsyncExpression(lexerFlags, $tp_ident_start, $tp_ident_stop, $tp_ident_line, $tp_ident_column, $tp_ident_canon, isNewArg, false, allowAssignment, leftHandSideExpression, astProp);\ncase 2075:\nreturn parseAwait(lexerFlags, $tp_ident_type, $tp_ident_start, $tp_ident_stop, $tp_ident_line, $tp_ident_column, $tp_ident_canon, isNewArg, allowAssignment, astProp);\ncase 2079:\nreturn parseClassExpression(lexerFlags, $tp_ident_start, $tp_ident_line, $tp_ident_column, astProp);\ncase 2084:\n;\nreturn _parseUnary(lexerFlags, $tp_ident_start, $tp_ident_stop, $tp_ident_line, $tp_ident_column, 'delete', isNewArg, astProp);\ncase 2088:\n{\nif (tok_getType() === 16499) {\nif ((lexerFlags & 8192) === 8192) {\nreturn THROW_RANGE('Can not use `eval` as arg name in strict mode', $tp_ident_start, $tp_ident_stop);\n}\nreturn parseArrowParenlessFromPunc(lexerFlags, $tp_ident_start, $tp_ident_line, $tp_ident_column, $tp_ident_type, $tp_ident_start, $tp_ident_stop, $tp_ident_line, $tp_ident_column, $tp_ident_canon, true, 3, 0, astProp);\n}\nAST_setIdent(astProp, $tp_ident_start, $tp_ident_stop, $tp_ident_line, $tp_ident_column, $tp_ident_canon);\nreturn verifyEvalArgumentsVar(lexerFlags);\n}\ncase 2091:\nreturn parseFalseKeyword($tp_ident_start, $tp_ident_line, $tp_ident_column, astProp);\ncase 2095:\nparseFunctionExpression(lexerFlags, $tp_ident_start, $tp_ident_line, $tp_ident_column, astProp);\nreturn 16;\ncase 2099:\nif (tok_getType() === 16471) {\nreturn parseDynamicImport(lexerFlags, $tp_ident_start, $tp_ident_stop, $tp_ident_line, $tp_ident_column, astProp);\n}\nreturn THROW_RANGE('Import keyword only allowed on toplevel or in a dynamic import', $tp_ident_start, $tp_ident_stop);\ncase 2103:\n;\nif (((bindingType === 6) || (bindingType === 7))) {\nreturn THROW_RANGE('Can not use `let` when binding through `let` or `const`', $tp_ident_start, $tp_ident_stop);\n}\nif ((lexerFlags & 8192) === 8192) {\nreturn THROW_RANGE('Can not use `let` as variable name in strict mode', $tp_ident_start, $tp_ident_stop);\n}\nreturn parseIdentOrParenlessArrow(lexerFlags, $tp_ident_type, $tp_ident_start, $tp_ident_stop, $tp_ident_line, $tp_ident_column, $tp_ident_canon, 32, allowAssignment, astProp);\ncase 2104:\nlet newAssignable = parseNewKeyword(lexerFlags, $tp_ident_start, $tp_ident_stop, $tp_ident_line, $tp_ident_column, $tp_ident_canon, astProp);\nreturn setNotAssignable(newAssignable);\ncase 2105:\nreturn parseNullKeyword($tp_ident_start, $tp_ident_line, $tp_ident_column, astProp);\ncase 2114:\nreturn parseSuperKeyword(lexerFlags, $tp_ident_start, $tp_ident_stop, $tp_ident_line, $tp_ident_column, astProp);\ncase 2119:\nreturn parseTrueKeyword($tp_ident_start, $tp_ident_line, $tp_ident_column, astProp);\ncase 2117:\nreturn parseThisKeyword($tp_ident_start, $tp_ident_line, $tp_ident_column, astProp);\ncase 2121:\n;\nreturn _parseUnary(lexerFlags, $tp_ident_start, $tp_ident_stop, $tp_ident_line, $tp_ident_column, 'typeof', isNewArg, astProp);\ncase 2123:\n;\nreturn _parseUnary(lexerFlags, $tp_ident_start, $tp_ident_stop, $tp_ident_line, $tp_ident_column, 'void', isNewArg, astProp);\ncase 2126:\nreturn parseYield(lexerFlags, $tp_ident_type, $tp_ident_start, $tp_ident_stop, $tp_ident_line, $tp_ident_column, $tp_ident_canon, allowAssignment, astProp);\n}\nfatalBindingIdentCheck($tp_ident_type, $tp_ident_start, $tp_ident_stop, $tp_ident_canon, bindingType, lexerFlags);\nreturn parseIdentOrParenlessArrow(lexerFlags, $tp_ident_type, $tp_ident_start, $tp_ident_stop, $tp_ident_line, $tp_ident_column, $tp_ident_canon, 32, allowAssignment, astProp);\n}\nfunction verifyEvalArgumentsVar(lexerFlags) {\nif ((lexerFlags & 8192) === 0) return 32;\nif (isAnyAssignmentOp()) {\nreturn THROW_RANGE('Cannot assign to `eval` and `arguments` in strict mode', tok_getStart(), tok_getStop());\n}\nif (((tok_getType() === 16478) || (tok_getType() === 16482))) {\nreturn THROW_RANGE('Cannot assign to `eval` and `arguments` in strict mode', tok_getStart(), tok_getStop());\n}\nreturn 16;\n}\nfunction parseTrueKeyword($tp_true_start, $tp_true_line, $tp_true_column, astProp) {\nif (babelCompat) {\nAST_setNode(astProp, {type:'BooleanLiteral', loc:AST_getClosedLoc($tp_true_start, $tp_true_line, $tp_true_column), value:true});\n} else {\nAST_setNode(astProp, {type:'Literal', loc:AST_getClosedLoc($tp_true_start, $tp_true_line, $tp_true_column), value:true, raw:'true'});\n}\nreturn 16;\n}\nfunction parseFalseKeyword($tp_false_start, $tp_false_line, $tp_false_column, astProp) {\nif (babelCompat) {\nAST_setNode(astProp, {type:'BooleanLiteral', loc:AST_getClosedLoc($tp_false_start, $tp_false_line, $tp_false_column), value:false});\n} else {\nAST_setNode(astProp, {type:'Literal', loc:AST_getClosedLoc($tp_false_start, $tp_false_line, $tp_false_column), value:false, raw:'false'});\n}\nreturn 16;\n}\nfunction parseNullKeyword($tp_null_start, $tp_null_line, $tp_null_column, astProp) {\nif (babelCompat) {\nAST_setNode(astProp, {type:'NullLiteral', loc:AST_getClosedLoc($tp_null_start, $tp_null_line, $tp_null_column)});\n} else {\nAST_setNode(astProp, {type:'Literal', loc:AST_getClosedLoc($tp_null_start, $tp_null_line, $tp_null_column), value:null, raw:'null'});\n}\nreturn 16;\n}\nfunction parseSuperKeyword(lexerFlags, $tp_super_start, $tp_super_stop, $tp_super_line, $tp_super_column, astProp) {\nAST_setNode(astProp, {type:'Super', loc:AST_getClosedLoc($tp_super_start, $tp_super_line, $tp_super_column)});\nif (tok_getType() === 16471) {\nif ((lexerFlags & 16384) === 0) {\nreturn THROW_RANGE('Can only use `super()` in constructors of classes that extend another class', $tp_super_start, tok_getStop());\n}\nreturn 16;\n}\nif (((tok_getType() === 16509) || (tok_getType() === 16485))) {\nif ((lexerFlags & 32768) === 0) {\nif (tok_getType() === 16509) {\nreturn THROW_RANGE('Can only use `super[foo]` in class or object methods or in arrows nested in those methods/arrows', $tp_super_start, tok_getStop());\n} else {\nreturn THROW_RANGE('Can only use `super.foo` in class or object methods or in arrows nested in those methods/arrows', $tp_super_start, tok_getStop());\n}\n}\nreturn 16;\n}\nreturn THROW_RANGE('The `super` keyword can only be used as call or member expression', $tp_super_start, $tp_super_stop);\n}\nfunction parseNewKeyword(lexerFlags, $tp_new_start, $tp_new_stop, $tp_new_line, $tp_new_column, $tp_new_canon, astProp) {\nif (tok_getType() === 16485) return parseNewDotTarget(lexerFlags, $tp_new_start, $tp_new_stop, $tp_new_line, $tp_new_column, $tp_new_canon, astProp);\nreturn parseNewExpression(lexerFlags, $tp_new_start, $tp_new_line, $tp_new_column, astProp);\n}\nfunction parseNewDotTarget(lexerFlags, $tp_new_start, $tp_new_stop, $tp_new_line, $tp_new_column, $tp_new_canon, astProp) {\nif ((lexerFlags & 2) === 0) {\nreturn THROW_RANGE('Must be inside/nested a regular function to use `new.target`', $tp_new_start, tok_getStop());\n}\nskipToTargetOrDie(lexerFlags);\nlet $tp_property_line = tok_getLine();\nlet $tp_property_column = tok_getColumn();\nlet $tp_property_start = tok_getStart();\nlet $tp_property_stop = tok_getStop();\nlet $tp_property_canon = tok_getCanoN();\nskipDiv(lexerFlags);\nAST_setNode(astProp, {type:'MetaProperty', loc:AST_getClosedLoc($tp_new_start, $tp_new_line, $tp_new_column), meta:AST_getIdentNode($tp_new_start, $tp_new_stop, $tp_new_line, $tp_new_column, $tp_new_canon), property:AST_getIdentNode($tp_property_start, $tp_property_stop, $tp_property_line, $tp_property_column, $tp_property_canon)});\nreturn 16;\n}\nfunction parseNewExpression(lexerFlags, $tp_new_start, $tp_new_line, $tp_new_column, astProp) {\nAST_open(astProp, {type:'NewExpression', loc:undefined, arguments:[], callee:undefined});\nif ((isIdentToken(tok_getType()) && (tok_getType() === 2099))) {\nreturn THROW_RANGE('Cannot use dynamic import as an argument to `new`, the spec simply does not allow it', $tp_new_start, tok_getStop());\n}\nlet assignableForPiggies = parseValue(lexerFlags, false, 3, false, 'callee');\nAST_close($tp_new_start, $tp_new_line, $tp_new_column);\nreturn setNotAssignable(assignableForPiggies);\n}\nfunction parseThisKeyword($tp_this_start, $tp_this_line, $tp_this_column, astProp) {\nAST_setNode(astProp, {type:'ThisExpression', loc:AST_getClosedLoc($tp_this_start, $tp_this_line, $tp_this_column)});\nreturn 16;\n}\nfunction parseUnary(lexerFlags, isNewArg, leftHandSideExpression, opName, astProp) {\nlet $tp_unary_line = tok_getLine();\nlet $tp_unary_column = tok_getColumn();\nlet $tp_unary_start = tok_getStart();\nlet $tp_unary_stop = tok_getStop();\nif (leftHandSideExpression === true) {\nreturn THROW_RANGE(('The unary expression `' + opName) + '` is not allowed here', $tp_unary_start, $tp_unary_stop);\n}\nskipToExpressionStart(lexerFlags);\nreturn _parseUnary(lexerFlags, $tp_unary_start, $tp_unary_stop, $tp_unary_line, $tp_unary_column, opName, isNewArg, astProp);\n}\nfunction _parseUnary(lexerFlags, $tp_unary_start, $tp_unary_stop, $tp_unary_line, $tp_unary_column, opName, isNewArg, astProp) {\nif (isNewArg === 3) {\nreturn THROW_RANGE(('Cannot `' + opName) + '` inside `new`', $tp_unary_start, $tp_unary_stop);\n}\nAST_open(astProp, {type:'UnaryExpression', loc:undefined, operator:opName, prefix:true, argument:undefined});\nlet assignable = parseValue(lexerFlags, false, 4, false, 'argument');\nif ((lexerFlags & 8192) === 8192) {\nif (((opName === 'delete') && (_path[_path.length - 1].argument.type === 'Identifier'))) {\nreturn THROW_RANGE('Cannot delete an identifier without tail, in strict mode', $tp_unary_start, $tp_unary_stop);\n}\n}\nAST_close($tp_unary_start, $tp_unary_line, $tp_unary_column);\nif (tok_getType() === 82010) {\nreturn THROW_RANGE('The lhs of ** can not be this kind of unary expression (syntactically not allowed, you have to wrap something)', tok_getStart(), tok_getStop());\n}\nreturn setNotAssignable(assignable);\n}\nfunction parseUpdatePrefix(lexerFlags, isNewArg, leftHandSideExpression, opName, astProp) {\nlet $tp_punc_line = tok_getLine();\nlet $tp_punc_column = tok_getColumn();\nlet $tp_punc_start = tok_getStart();\nlet $tp_punc_stop = tok_getStop();\nif (leftHandSideExpression === true) {\nreturn THROW_RANGE(('An update expression `' + opName) + '` is not allowed here', $tp_punc_start, $tp_punc_stop);\n}\nif (isNewArg === 3) {\nreturn THROW_RANGE(('Cannot `new` on a `' + opName) + '` expr', $tp_punc_start, $tp_punc_stop);\n}\nskipToExpressionStart(lexerFlags);\nAST_open(astProp, {type:'UpdateExpression', loc:undefined, argument:undefined, operator:opName, prefix:true});\nlet assignable = parseValue(lexerFlags, false, 4, false, 'argument');\nAST_throwIfIllegalUpdateArg('argument');\nAST_close($tp_punc_start, $tp_punc_line, $tp_punc_column);\nif (notAssignable(assignable)) {\nreturn THROW_RANGE('Cannot inc/dec a non-assignable value as prefix', $tp_punc_start, $tp_punc_stop);\n}\nreturn setNotAssignable(assignable);\n}\nfunction parseYield(lexerFlags, $tp_yieldIdent_type, $tp_yieldIdent_start, $tp_yieldIdent_stop, $tp_yieldIdent_line, $tp_yieldIdent_column, $tp_yieldIdent_canon, allowAssignment, astProp) {\nif ((lexerFlags & 128) !== 0) {\nreturn parseYieldKeyword(lexerFlags, $tp_yieldIdent_start, $tp_yieldIdent_stop, $tp_yieldIdent_line, $tp_yieldIdent_column, allowAssignment, astProp);\n}\nreturn parseYieldVarname(lexerFlags, $tp_yieldIdent_type, $tp_yieldIdent_start, $tp_yieldIdent_stop, $tp_yieldIdent_line, $tp_yieldIdent_column, $tp_yieldIdent_canon, allowAssignment, astProp);\n}\nfunction parseYieldKeyword(lexerFlags, $tp_yield_start, $tp_yield_stop, $tp_yield_line, $tp_yield_column, allowAssignment, astProp) {\nif ((lexerFlags & 64) === 64) {\nreturn THROW_RANGE('The `yield` keyword in arg default must be a var name but that is not allowed inside a generator', $tp_yield_start, $tp_yield_stop);\n}\nif (allowAssignment === false) {\nreturn THROW_RANGE('Did not expect to parse an AssignmentExpression but found `yield`', $tp_yield_start, $tp_yield_stop);\n}\nAST_open(astProp, {type:'YieldExpression', loc:undefined, delegate:undefined, argument:undefined});\nif (((tok_getNlwas() === true) && isRegexToken(tok_getType()))) {\nAST_set('delegate', false);\nAST_set('argument', null);\n} else if (tok_getType() === 82009) {\nAST_set('delegate', true);\nparseYieldStarArgument(lexerFlags, $tp_yield_start, 'argument');\n} else if (tok_getType() === 82010) {\nreturn THROW_RANGE('Cannot use `yield` to the left of the `**` operator', $tp_yield_start, $tp_yield_stop);\n} else {\nAST_set('delegate', false);\nparseYieldArgument(lexerFlags, 'argument');\n}\nAST_close($tp_yield_start, $tp_yield_line, $tp_yield_column);\nif (tok_getType() === 16506) {\nreturn THROW_RANGE('Can not have a `yield` expression on the left side of a ternary', $tp_yield_start, $tp_yield_stop);\n}\nreturn 144;\n}\nfunction parseYieldStarArgument(lexerFlags, $tp_yield_start, astProp) {\nif (tok_getNlwas() === true) {\nreturn THROW_RANGE('A newline after `yield` is illegal for `yield *`', $tp_yield_start, tok_getStart());\n}\nskipToExpressionStart(lexerFlags);\nlet $tp_valueStart_line = tok_getLine();\nlet $tp_valueStart_column = tok_getColumn();\nlet $tp_valueStart_start = tok_getStart();\nlet $tp_valueStart_stop = tok_getStop();\nlet assignable = parseValue(lexerFlags, true, 4, false, astProp);\nparseExpressionFromOp(lexerFlags, $tp_valueStart_start, $tp_valueStart_stop, $tp_valueStart_line, $tp_valueStart_column, assignable, astProp);\n}\nfunction parseYieldVarname(lexerFlags, $tp_ident_type, $tp_ident_start, $tp_ident_stop, $tp_ident_line, $tp_ident_column, $tp_ident_canon, allowAssignment, astProp) {\nif ((lexerFlags & 8192) === 8192) {\nreturn THROW_RANGE('Cannot use `yield` outside of generator functions when in strict mode', $tp_ident_start, $tp_ident_stop);\n}\nlet assignableFlags = parseIdentOrParenlessArrow(lexerFlags, $tp_ident_type, $tp_ident_start, $tp_ident_stop, $tp_ident_line, $tp_ident_column, $tp_ident_canon, 32, allowAssignment, astProp);\nreturn copyPiggies(32, assignableFlags);\n}\nfunction parseYieldArgument(lexerFlags, astProp) {\nlet $tp_yieldArgStart_line = tok_getLine();\nlet $tp_yieldArgStart_column = tok_getColumn();\nlet $tp_yieldArgStart_start = tok_getStart();\nlet $tp_yieldArgStart_stop = tok_getStop();\nif (tok_getNlwas() === true) {\nAST_set(astProp, null);\nreturn;\n}\nlet assignable = parseValueHeadBody(lexerFlags, true, 4, true, false, astProp);\nif (tok_getStart() === $tp_yieldArgStart_start) {\nAST_set(astProp, null);\nreturn;\n}\nassignable = parseValueTail(lexerFlags, $tp_yieldArgStart_start, $tp_yieldArgStart_line, $tp_yieldArgStart_column, assignable, 4, false, astProp);\nparseExpressionFromOp(lexerFlags, $tp_yieldArgStart_start, $tp_yieldArgStart_stop, $tp_yieldArgStart_line, $tp_yieldArgStart_column, assignable, astProp);\n}\nfunction parseIdentOrParenlessArrow(lexerFlags, $tp_ident_type, $tp_ident_start, $tp_ident_stop, $tp_ident_line, $tp_ident_column, $tp_ident_canon, assignable, allowAssignment, astProp) {\nif (tok_getType() === 16499) {\nreturn parseArrowParenlessFromPunc(lexerFlags, $tp_ident_start, $tp_ident_line, $tp_ident_column, $tp_ident_type, $tp_ident_start, $tp_ident_stop, $tp_ident_line, $tp_ident_column, $tp_ident_canon, allowAssignment, 1, 0, astProp);\n} else {\nAST_setIdent(astProp, $tp_ident_start, $tp_ident_stop, $tp_ident_line, $tp_ident_column, $tp_ident_canon);\nreturn assignable;\n}\n}\nfunction parseArrowParenlessFromPunc(lexerFlags, $tp_arrowStart_start, $tp_arrowStart_line, $tp_arrowStart_column, $tp_ident_type, $tp_ident_start, $tp_ident_stop, $tp_ident_line, $tp_ident_column, $tp_ident_canon, allowAssignment, wasSimple, $tp_async_type, astProp) {\nlet $tp_arrow_start = tok_getStart();\nlet $tp_arrow_stop = tok_getStop();\nif ((((lexerFlags & 128) === 128) && ($tp_ident_type === 2126))) {\nreturn THROW_RANGE('Arrows cannot be generators and parenless `yield` param in a generator would be parsing a yield expression and fail at the arrow', $tp_arrow_start, $tp_arrow_stop);\n}\nfatalBindingIdentCheck($tp_ident_type, $tp_ident_start, $tp_ident_stop, $tp_ident_canon, 1, lexerFlags);\nif (isStrictOnlyKeyword($tp_ident_type, $tp_ident_start, $tp_ident_stop, $tp_ident_canon)) {\nwasSimple = 3;\n}\nif (tok_getNlwas() === true) {\nreturn THROW_RANGE('The arrow is a restricted production and there can not be a newline before `=>` token', $tp_arrow_start, $tp_arrow_stop);\n}\nif (babelCompat) {\nAST_open(astProp, {type:'ArrowFunctionExpression', loc:undefined, params:[AST_getIdentNode($tp_ident_start, $tp_ident_stop, $tp_ident_line, $tp_ident_column, $tp_ident_canon)], id:null, generator:false, async:$tp_async_type === 2074, body:undefined});\n} else if ((acornCompat && (!allowAsyncFunctions))) {\nAST_open(astProp, {type:'ArrowFunctionExpression', loc:undefined, params:[AST_getIdentNode($tp_ident_start, $tp_ident_stop, $tp_ident_line, $tp_ident_column, $tp_ident_canon)], id:null, generator:false, expression:undefined, body:undefined});\n} else {\nAST_open(astProp, {type:'ArrowFunctionExpression', loc:undefined, params:[AST_getIdentNode($tp_ident_start, $tp_ident_stop, $tp_ident_line, $tp_ident_column, $tp_ident_canon)], id:null, generator:false, async:$tp_async_type === 2074, expression:undefined, body:undefined});\n}\nlet arrowScoop = SCOPE_createGlobal('parseArrowParenlessFromPunc');\nlet paramScoop = SCOPE_addLayer(arrowScoop, 11, 'parseArrowParenlessFromPunc(arg)');\nSCOPE_addLexBinding(paramScoop, $tp_ident_start, $tp_ident_stop, $tp_ident_canon, 1, 1);\nparseArrowFromPunc(lexerFlags, paramScoop, $tp_async_type, allowAssignment, wasSimple);\nAST_close($tp_arrowStart_start, $tp_arrowStart_line, $tp_arrowStart_column);\nreturn 1040;\n}\nfunction parseTickExpression(lexerFlags, $tp_tick_start, $tp_tick_stop, $tp_tick_line, $tp_tick_column, astProp) {\nAST_open(astProp, {type:'TemplateLiteral', loc:undefined, expressions:[], quasis:[]});\nlet awaitYieldFlagsFromAssignable = 8;\nif (tok_getType() === 524308) {\nparseQuasiPart(lexerFlags, true, false);\nAST_close($tp_tick_start, $tp_tick_line, $tp_tick_column);\nreturn awaitYieldFlagsFromAssignable;\n}\nif (tok_getType() === 524305) {\nparseQuasiPart(lexerFlags, false, false);\nlet tmpLexerFlags = (((lexerFlags | 2048) | 4096) | 1824) ^ 1824;\nlet wasTail = true;\ndo {\nawaitYieldFlagsFromAssignable |= parseExpressions(tmpLexerFlags, 'expressions');\nwasTail = ((((tok_getType() === 524307) || (tok_getType() === 1572883)))? true : false);\nparseQuasiPart(lexerFlags, wasTail, false);\n} while (wasTail === false);\nAST_close($tp_tick_start, $tp_tick_line, $tp_tick_column);\nreturn awaitYieldFlagsFromAssignable;\n}\nreturn THROW_RANGE('Template contained bad escape, which is only valid in _tagged_ templates (and only since ES9/ES2018)', $tp_tick_start, $tp_tick_stop);\n}\nfunction parseQuasiPart(lexerFlags, wasTail, allowBadEscapes) {\nlet $tp_tick_type = tok_getType();\nlet $tp_tick_line = tok_getLine();\nlet $tp_tick_column = tok_getColumn();\nlet $tp_tick_start = tok_getStart();\nlet $tp_tick_stop = tok_getStop();\nlet $tp_tick_canon = tok_getCanoN();\nlet hasDoubleStart = false;\nlet noCooked = false;\nif (isBadTickToken(tok_getType())) {\nif (!allowBadEscapes) {\nreturn THROW_RANGE('Template contained an illegal escape, these are only allowed in _tagged_ templates in >=ES2018', $tp_tick_start, $tp_tick_stop);\n}\nnoCooked = true;\n}\nif (((((((tok_getType() === 524308) || (tok_getType() === 524307))) || (tok_getType() === 1572884))) || (tok_getType() === 1572883))) {\nskipDiv(lexerFlags);\n} else if (((((((tok_getType() === 524305) || (tok_getType() === 524306))) || (tok_getType() === 1572881))) || (tok_getType() === 1572882))) {\nskipToExpressionStart(lexerFlags);\nhasDoubleStart = true;\n} else {\nreturn THROW_RANGE('The first token after the template expression should be a continuation of the template', $tp_tick_start, $tp_tick_stop);\n}\nlet closeWrapperLen = (((((((($tp_tick_type === 524305) || ($tp_tick_type === 524306))) || ($tp_tick_type === 1572881))) || ($tp_tick_type === 1572882)))? 2 : 1);\nlet quasiValue = tok_sliceInput($tp_tick_start + 1, $tp_tick_stop - closeWrapperLen);\nif ((((acornCompat || babelCompat)) || templateNewlineNormalization)) {\nquasiValue = quasiValue.replace(/\\r\\n?/g, '\\n');\n}\nlet cookedValue = (noCooked? null : $tp_tick_canon);\nAST_open('quasis', {type:'TemplateElement', loc:undefined, tail:wasTail === true, value:{raw:quasiValue, cooked:cookedValue}});\nAST_closeTemplateElement(hasDoubleStart, $tp_tick_start, $tp_tick_line, $tp_tick_column + 1);\n}\nfunction parseValueTail(lexerFlags, $tp_valueFirst_start, $tp_valueFirst_line, $tp_valueFirst_column, assignable, isNewArg, leftHandSideExpression, astProp) {\nif ((assignable & 1024) === 1024) return assignable;\nswitch (tok_getType()) {\ncase 16485:\nreturn _parseValueTailDotProperty(lexerFlags, $tp_valueFirst_start, $tp_valueFirst_line, $tp_valueFirst_column, assignable, isNewArg, astProp);\ncase 16509:\nreturn _parseValueTailDynamicProperty(lexerFlags, $tp_valueFirst_start, $tp_valueFirst_line, $tp_valueFirst_column, assignable, isNewArg, astProp);\ncase 16471:\nreturn _parseValueTailCall(lexerFlags, $tp_valueFirst_start, $tp_valueFirst_line, $tp_valueFirst_column, assignable, isNewArg, astProp);\ncase 82043:\nif (isNewArg === 3) {\nreturn THROW_RANGE('Cannot use `?.` in the arg of `new`', tok_getStart(), tok_getStop());\n}\nreturn parseOptionalValueTailOuter(lexerFlags, $tp_valueFirst_start, $tp_valueFirst_line, $tp_valueFirst_column, assignable, astProp);\ncase 524308:\n\ncase 524305:\n\ncase 1572884:\n\ncase 1572881:\nreturn _parseValueTailTemplate(lexerFlags, $tp_valueFirst_start, $tp_valueFirst_line, $tp_valueFirst_column, assignable, isNewArg, astProp);\ncase 16478:\nif (isNewArg === 3) return _parseValueTailNewArg(assignable);\nreturn parseValueTailUpdateExpression(lexerFlags, $tp_valueFirst_start, $tp_valueFirst_line, $tp_valueFirst_column, assignable, leftHandSideExpression, '++', astProp);\ncase 16482:\nif (isNewArg === 3) return _parseValueTailNewArg(assignable);\nreturn parseValueTailUpdateExpression(lexerFlags, $tp_valueFirst_start, $tp_valueFirst_line, $tp_valueFirst_column, assignable, leftHandSideExpression, '--', astProp);\n}\nif (isNewArg === 3) return _parseValueTailNewArg(assignable);\nreturn assignable;\n}\nfunction parseOptionalValueTailOuter(lexerFlags, $tp_valueFirst_start, $tp_valueFirst_line, $tp_valueFirst_column, assignable, astProp) {\ndo {\nlet $tp_next_type = tok_getType();\nswitch ($tp_next_type) {\ncase 82043:\nskipAny(lexerFlags);\nlet $tp_q_type = tok_getType();\nif (isIdentToken($tp_q_type)) {\nlet $tp_ident_type = tok_getType();\nlet $tp_ident_line = tok_getLine();\nlet $tp_ident_column = tok_getColumn();\nlet $tp_ident_start = tok_getStart();\nlet $tp_ident_stop = tok_getStop();\nlet $tp_ident_canon = tok_getCanoN();\nif (!isIdentToken($tp_ident_type)) THROW_RANGE('Expected ident after dot', $tp_ident_start, $tp_ident_stop);\nskipDiv(lexerFlags);\nAST_setNode(astProp, {type:'OptionalMemberExpression', loc:AST_getClosedLoc($tp_valueFirst_start, $tp_valueFirst_line, $tp_valueFirst_column), optional:true, computed:false, object:AST_popNode(astProp), property:AST_getIdentNode($tp_ident_start, $tp_ident_stop, $tp_ident_line, $tp_ident_column, $tp_ident_canon)});\n} else if ($tp_q_type === 16509) {\nskipAny(lexerFlags);\nAST_wrapClosedCustom(astProp, {type:'OptionalMemberExpression', loc:undefined, optional:true, computed:true, object:undefined, property:undefined}, 'object');\nparseExpression(lexerFlags, 'property');\nif (tok_getType() !== 16510) {\nreturn THROW_RANGE(('Expected the closing `]` char of a dynamic property, found `' + tok_sliceInput(tok_getStart(), tok_getStop())) + '` instead', tok_getStart(), tok_getStop());\n}\nskipDiv(lexerFlags);\nAST_close($tp_valueFirst_start, $tp_valueFirst_line, $tp_valueFirst_column);\n} else if ($tp_q_type === 16471) {\nAST_wrapClosedCustom(astProp, {type:'OptionalCallExpression', loc:undefined, optional:true, callee:undefined, arguments:[]}, 'callee');\nlet nowAssignable = parseCallArgs(lexerFlags, 'arguments');\nassignable = mergeAssignable(nowAssignable, assignable);\nAST_close($tp_valueFirst_start, $tp_valueFirst_line, $tp_valueFirst_column);\n} else if (isTemplateStart($tp_q_type)) {\nreturn THROW_RANGE('An value containing the optional chaining operator cannot be followed by a template', tok_getStart(), tok_getStop());\n} else if ($tp_q_type === 82043) {\nreturn THROW_RANGE('Cannot cannot `?.?.`, must have something in between', tok_getStart(), tok_getStop());\n}\nbreak;\ncase 16485:\nskipAny(lexerFlags);\nlet $tp_ident_type = tok_getType();\nlet $tp_ident_line = tok_getLine();\nlet $tp_ident_column = tok_getColumn();\nlet $tp_ident_start = tok_getStart();\nlet $tp_ident_stop = tok_getStop();\nlet $tp_ident_canon = tok_getCanoN();\nif (!isIdentToken($tp_ident_type)) THROW_RANGE('Expected ident after dot', $tp_ident_start, $tp_ident_stop);\nskipDiv(lexerFlags);\nAST_setNode(astProp, {type:'OptionalMemberExpression', loc:AST_getClosedLoc($tp_valueFirst_start, $tp_valueFirst_line, $tp_valueFirst_column), optional:false, computed:false, object:AST_popNode(astProp), property:AST_getIdentNode($tp_ident_start, $tp_ident_stop, $tp_ident_line, $tp_ident_column, $tp_ident_canon)});\nbreak;\ncase 16471:\nAST_wrapClosedCustom(astProp, {type:'OptionalCallExpression', loc:undefined, optional:false, callee:undefined, arguments:undefined}, 'callee');\nlet nowAssignable = parseCallArgs(lexerFlags, 'arguments');\nassignable = mergeAssignable(nowAssignable, assignable);\nAST_close($tp_valueFirst_start, $tp_valueFirst_line, $tp_valueFirst_column);\nbreak;\ncase 16509:\nskipAny(lexerFlags);\nAST_wrapClosedCustom(astProp, {type:'OptionalMemberExpression', loc:undefined, optional:false, computed:true, object:undefined, property:undefined}, 'object');\nparseExpression(lexerFlags, 'property');\nif (tok_getType() !== 16510) {\nreturn THROW_RANGE(('Expected the closing `]` char of a dynamic property, found`' + tok_sliceInput(tok_getStart(), tok_getStop())) + '` instead', tok_getStart(), tok_getStop());\n}\nskipDiv(lexerFlags);\nassignable = parseOptionalValueTailOuter(lexerFlags, $tp_valueFirst_start, $tp_valueFirst_line, $tp_valueFirst_column, assignable, 'property');\nAST_close($tp_valueFirst_start, $tp_valueFirst_line, $tp_valueFirst_column);\nbreak;\ndefault:\nif (isTemplateStart($tp_next_type)) {\nreturn THROW_RANGE('An value containing the optional chaining operator cannot be followed by a template', tok_getStart(), tok_getStop());\n}\nreturn setNotAssignable(assignable);\n}\n} while (true);\n}\nfunction _parseValueTailDotProperty(lexerFlags, $tp_valueFirst_start, $tp_valueFirst_line, $tp_valueFirst_column, assignable, isNewArg, astProp) {\nskipToIdentOrDie(lexerFlags | 65536);\nlet $tp_ident_line = tok_getLine();\nlet $tp_ident_column = tok_getColumn();\nlet $tp_ident_start = tok_getStart();\nlet $tp_ident_stop = tok_getStop();\nlet $tp_ident_canon = tok_getCanoN();\nskipDiv(lexerFlags);\nAST_setNode(astProp, {type:'MemberExpression', loc:AST_getClosedLoc($tp_valueFirst_start, $tp_valueFirst_line, $tp_valueFirst_column), object:AST_popNode(astProp), property:AST_getIdentNode($tp_ident_start, $tp_ident_stop, $tp_ident_line, $tp_ident_column, $tp_ident_canon), computed:false});\nreturn parseValueTail(lexerFlags, $tp_valueFirst_start, $tp_valueFirst_line, $tp_valueFirst_column, setAssignable(assignable), isNewArg, false, astProp);\n}\nfunction _parseValueTailDynamicProperty(lexerFlags, $tp_valueFirst_start, $tp_valueFirst_line, $tp_valueFirst_column, assignable, isNewArg, astProp) {\nAST_wrapClosedCustom(astProp, {type:'MemberExpression', loc:undefined, object:undefined, property:undefined, computed:true}, 'object');\nskipToExpressionStart(lexerFlags);\nlet nowAssignable = parseExpressions(((lexerFlags | 4096) | 1824) ^ 1824, 'property');\nassignable = mergeAssignable(nowAssignable, assignable);\nassignable = (assignable | 1024) ^ 1024;\nif (tok_getType() !== 16510) {\nreturn THROW_RANGE(('Expected the closing bracket `]` for a dynamic property, found `' + tok_sliceInput(tok_getStart(), tok_getStop())) + '` instead', tok_getStart(), tok_getStop());\n}\nskipDiv(lexerFlags);\nAST_close($tp_valueFirst_start, $tp_valueFirst_line, $tp_valueFirst_column);\nreturn parseValueTail(lexerFlags, $tp_valueFirst_start, $tp_valueFirst_line, $tp_valueFirst_column, setAssignable(assignable), isNewArg, false, astProp);\n}\nfunction _parseValueTailCall(lexerFlags, $tp_valueFirst_start, $tp_valueFirst_line, $tp_valueFirst_column, assignable, isNewArg, astProp) {\nif (isNewArg === 3) {\nlet nowAssignable = parseCallArgs(lexerFlags, 'arguments');\nif (tok_getType() === 16499) {\nreturn THROW_RANGE('The `new` keyword can not be applied to an arrow', tok_getStart(), tok_getStop());\n}\nassignable = mergeAssignable(nowAssignable, assignable);\nassignable = setNotAssignable(assignable);\nreturn assignable;\n}\nAST_wrapClosedCustom(astProp, {type:'CallExpression', loc:undefined, callee:undefined, arguments:[]}, 'callee');\nlet nowAssignable = parseCallArgs(lexerFlags, 'arguments');\nassignable = mergeAssignable(nowAssignable, assignable);\nAST_close($tp_valueFirst_start, $tp_valueFirst_line, $tp_valueFirst_column);\nreturn parseValueTail(lexerFlags, $tp_valueFirst_start, $tp_valueFirst_line, $tp_valueFirst_column, setNotAssignable(assignable), isNewArg, false, astProp);\n}\nfunction _parseValueTailTemplate(lexerFlags, $tp_valueFirst_start, $tp_valueFirst_line, $tp_valueFirst_column, assignable, isNewArg, astProp) {\nAST_wrapClosedCustom(astProp, {type:'TaggedTemplateExpression', loc:undefined, tag:undefined, quasi:undefined}, 'tag');\nlet $tp_Quasi_line = tok_getLine();\nlet $tp_Quasi_column = tok_getColumn();\nlet $tp_Quasi_start = tok_getStart();\nAST_open('quasi', {type:'TemplateLiteral', loc:undefined, expressions:[], quasis:[]});\n_parseValueTailTemplateRest(lexerFlags);\nAST_close($tp_Quasi_start, $tp_Quasi_line, $tp_Quasi_column);\nAST_close($tp_valueFirst_start, $tp_valueFirst_line, $tp_valueFirst_column);\nreturn parseValueTail(lexerFlags, $tp_valueFirst_start, $tp_valueFirst_line, $tp_valueFirst_column, setNotAssignable(assignable), isNewArg, false, astProp);\n}\nfunction _parseValueTailTemplateRest(lexerFlags) {\nlet awaitYieldFlagsFromAssignable = 8;\nif (((tok_getType() === 524308) || (tok_getType() === 1572884))) {\nparseQuasiPart(lexerFlags, true, allowBadEscapesInTaggedTemplates);\nreturn;\n}\nparseQuasiPart(lexerFlags, false, allowBadEscapesInTaggedTemplates);\nlet tmpLexerFlags = (((lexerFlags | 2048) | 4096) | 1824) ^ 1824;\nlet wasTail = true;\ndo {\nawaitYieldFlagsFromAssignable |= parseExpressions(tmpLexerFlags, 'expressions');\nwasTail = ((((tok_getType() === 524307) || (tok_getType() === 1572883)))? true : false);\nparseQuasiPart(lexerFlags, wasTail, allowBadEscapesInTaggedTemplates);\n} while (wasTail === false);\n}\nfunction _parseValueTailNewArg(assignable) {\nreturn setNotAssignable(assignable);\n}\nfunction parseValueTailUpdateExpression(lexerFlags, $tp_argStart_start, $tp_argStart_line, $tp_argStart_column, assignable, leftHandSideExpression, opName, astProp) {\nlet $tp_op_start = tok_getStart();\nlet $tp_op_stop = tok_getStop();\nif (leftHandSideExpression === true) {\nreturn THROW_RANGE(('A `' + opName) + '` update expression is not allowed here', $tp_op_start, $tp_op_stop);\n}\nif (tok_getNlwas() === true) {\nif ((lexerFlags & 4096) === 4096) {\nreturn THROW_RANGE(('The postfix `' + opName) + '` is a restricted production so ASI must apply but that is not valid in this context', $tp_op_start, $tp_op_stop);\n}\nreturn assignable;\n}\nif (notAssignable(assignable)) {\nreturn THROW_RANGE(('Cannot postfix `' + opName) + '` a non-assignable value', $tp_op_start, $tp_op_stop);\n}\nAST_throwIfIllegalUpdateArg(astProp);\nskipDiv(lexerFlags);\nAST_setNodeDangerously(astProp, {type:'UpdateExpression', loc:AST_getClosedLoc($tp_argStart_start, $tp_argStart_line, $tp_argStart_column), argument:AST_popNode(astProp), operator:opName, prefix:false});\nreturn 16;\n}\nfunction parseCallArgs(lexerFlags, astProp) {\nskipToExpressionStartGrouped(lexerFlags);\nlexerFlags = ((lexerFlags | 4096) | 32) ^ 32;\nlet assignable = 8;\nif (tok_getType() === 16472) {\nskipDiv(lexerFlags);\n} else {\ndo {\nif (tok_getType() === 16486) {\nlet $tp_spread_line = tok_getLine();\nlet $tp_spread_column = tok_getColumn();\nlet $tp_spread_start = tok_getStart();\nskipToExpressionStart(lexerFlags);\nAST_open(astProp, {type:'SpreadElement', loc:undefined, argument:undefined});\nlet nowAssignable = parseExpression(lexerFlags, 'argument');\nassignable = mergeAssignable(nowAssignable, assignable);\nAST_close($tp_spread_start, $tp_spread_line, $tp_spread_column);\n} else {\nlet nowAssignable = parseExpression(lexerFlags, astProp);\nassignable = mergeAssignable(nowAssignable, assignable);\n}\nif (tok_getType() !== 16480) break;\nlet $tp_comma_start = tok_getStart();\nlet $tp_comma_stop = tok_getStop();\nskipToExpressionStartGrouped(lexerFlags);\nif (tok_getType() === 16472) {\nif (allowTrailingFunctionComma) break;\nreturn THROW_RANGE('Targeted language version does not support trailing call arg comma', $tp_comma_start, $tp_comma_stop);\n}\n} while (true);\nif (tok_getType() !== 16472) {\nreturn THROW_RANGE(('Expecting closing paren `)` for the call, found `' + tok_sliceInput(tok_getStart(), tok_getStop())) + '` instead', tok_getStart(), tok_getStop());\n}\nskipDiv(lexerFlags);\n}\nreturn (assignable | 1024) ^ 1024;\n}\nfunction parseDynamicImportStatement(lexerFlags, $tp_import_start, $tp_import_stop, $tp_import_line, $tp_import_column, astProp) {\nAST_open(astProp, {type:'ExpressionStatement', loc:undefined, expression:undefined});\nparseDynamicImport(lexerFlags, $tp_import_start, $tp_import_stop, $tp_import_line, $tp_import_column, 'expression');\nlet assignable = parseValueTail(lexerFlags, $tp_import_start, $tp_import_line, $tp_import_column, 16, 4, false, 'expression');\nparseExpressionFromOp(lexerFlags, $tp_import_start, $tp_import_stop, $tp_import_line, $tp_import_column, assignable, 'expression');\nparseSemiOrAsi(lexerFlags);\nAST_close($tp_import_start, $tp_import_line, $tp_import_column);\n}\nfunction parseDynamicImport(lexerFlags, $tp_import_start, $tp_import_stop, $tp_import_line, $tp_import_column, astProp) {\nif (!allowDynamicImport) {\nreturn THROW_RANGE('Dynamic import syntax not supported. Requires version ES2020+ / ES11+.', $tp_import_start, $tp_import_stop);\n}\nif (acornCompat) {\nAST_open(astProp, {type:'ImportExpression', loc:undefined, source:undefined});\n} else {\nAST_open(astProp, {type:'CallExpression', loc:undefined, callee:undefined, arguments:[]});\nAST_setNode('callee', {type:'Import', loc:AST_getClosedLoc($tp_import_start, $tp_import_line, $tp_import_column)});\n}\nskipToExpressionStart(lexerFlags);\nlet assignable = parseExpression(lexerFlags, (acornCompat? 'source' : 'arguments'));\nif (tok_getType() !== 16472) {\nif (tok_getType() === 16480) {\nreturn THROW_RANGE('Dynamic `import` only expected exactly one argument and does not allow for a trailing comma', $tp_import_start, tok_getStop());\n}\nif (tok_getType() === 67636) {\nreturn THROW_RANGE('The dynamic import syntax explicitly forbids the `in` operator', tok_getStart(), tok_getStop());\n}\nreturn THROW_RANGE('The dynamic `import` argument was followed by unknown content', tok_getStart(), tok_getStop());\n}\nskipDiv(lexerFlags);\nAST_close($tp_import_start, $tp_import_line, $tp_import_column);\nreturn assignable;\n}\nfunction parseArrowFromPunc(lexerFlags, paramScoop, $tp_async_type, allowAssignment, paramsSimple) {\nskipToExpressionStart(lexerFlags);\nif (allowAssignment === false) {\nreturn THROW_RANGE('Was parsing a value that could not be AssignmentExpression but found an arrow', tok_getStart(), tok_getStop());\n}\nif (options_exposeScopes) AST_set('$scope', paramScoop);\nif (paramScoop.dupeParamErrorStart !== 0) {\nreturn THROW_RANGE('Arrow had duplicate params', paramScoop.dupeParamErrorStart - 1, paramScoop.dupeParamErrorStop);\n}\nlet insideForLhs = (lexerFlags & 32) === 32;\nlet arrowInheritedFlags = lexerFlags & 18;\nlexerFlags = resetLexerFlagsForFuncAndArrow(lexerFlags, 0, $tp_async_type, true);\nlexerFlags |= arrowInheritedFlags;\nif (tok_getType() === 16513) {\nif (!babelCompat) AST_set('expression', false);\nlet arrowScoop = SCOPE_addLayer(paramScoop, 10, 'parseArrowFromPunc');\nparseFunctionBody(lexerFlags, arrowScoop, 1, paramsSimple, 0, 0, 0, 0, 0, '', true);\nif ((isRegexToken(tok_getType()) && (!tok_getNlwas()))) {\nTHROW_RANGE('Found a regex or division after an arrow, that is illegal', tok_getStart(), tok_getStop());\n}\n} else {\nif (insideForLhs) lexerFlags |= 32;\nif (!babelCompat) AST_set('expression', true);\nparseExpression(lexerFlags, 'body');\n}\n{\nlet $tp_error_type = tok_getType();\nlet $tp_error_start = tok_getStart();\nlet $tp_error_stop = tok_getStop();\nlet $tp_error_nl = tok_getNlwas();\nif ((insideForLhs && ($tp_error_type === 67636))) {\nreturn THROW_RANGE('Arrows cannot be lhs to for-in', $tp_error_start, $tp_error_stop);\n}\nif ($tp_error_type === 16485) {\nreturn THROW_RANGE('Block body arrows can not be immediately accessed without a group', $tp_error_start, $tp_error_stop);\n}\nif ($tp_error_nl) {\nif ($tp_error_type === 82023) {\nreturn THROW_RANGE('An arrow function can not be part of an operator to the right', $tp_error_start, $tp_error_stop);\n}\nreturn 1040;\n}\nif ($tp_error_type === 16471) {\nreturn THROW_RANGE('Block body arrows can not be immediately invoked without a group', $tp_error_start, $tp_error_stop);\n}\nif ($tp_error_type === 16509) {\nreturn THROW_RANGE('Block body arrows can not be immediately accessed without a group', $tp_error_start, $tp_error_stop);\n}\nif (isTemplateStart($tp_error_type)) {\nreturn THROW_RANGE('Block body arrows can not be immediately tagged without a group', $tp_error_start, $tp_error_stop);\n}\nif ((isAnyAssignmentOp() || (($tp_error_type & 65536) === 65536))) {\nreturn THROW_RANGE('An arrow function can not be part of an operator to the right', $tp_error_start, $tp_error_stop);\n}\nif ((($tp_error_type === 16478) || ($tp_error_type === 16482))) {\nreturn THROW_RANGE('An arrow function can not have a postfix update operator', $tp_error_start, $tp_error_stop);\n}\n}\nreturn 1040;\n}\nfunction parseGroupToplevels(lexerFlagsBeforeParen, asyncStmtOrExpr, allowAssignmentForGroupToBeArrow, $tp_async_type, $tp_async_start, $tp_async_stop, $tp_async_line, $tp_async_column, $tp_async_canon, newlineAfterAsync, leftHandSideExpression, astProp) {\nlet $tp_paren_line = tok_getLine();\nlet $tp_paren_column = tok_getColumn();\nlet $tp_paren_start = tok_getStart();\nskipToExpressionStartGrouped(lexerFlagsBeforeParen);\nlet $tp_firstTokenAfterParen_line = tok_getLine();\nlet $tp_firstTokenAfterParen_column = tok_getColumn();\nlet $tp_firstTokenAfterParen_start = tok_getStart();\nlet lexerFlags = ((lexerFlagsBeforeParen | 4096) | 1824) ^ 1824;\nlet arrowScoop = SCOPE_createGlobal('_parseGroupToplevels');\nlet paramScoop = SCOPE_addLayer(arrowScoop, 11, '_parseGroupToplevels(arg)');\nif (tok_getType() === 16472) {\nif ($tp_async_type === 2074) {\nskipDiv(lexerFlags);\nreturn parseAfterAsyncGroup(lexerFlagsBeforeParen, paramScoop, asyncStmtOrExpr, allowAssignmentForGroupToBeArrow, 1, false, newlineAfterAsync, true, $tp_async_start, $tp_async_stop, $tp_async_line, $tp_async_column, $tp_async_canon, 8, astProp);\n}\nskipToArrowOrDie(lexerFlags);\nlet $tp_arrow_start = tok_getStart();\nlet $tp_arrow_stop = tok_getStop();\nif (leftHandSideExpression === true) {\nreturn THROW_RANGE('Arrow not allowed in this position', $tp_paren_start, $tp_arrow_stop);\n}\nlexerFlags = lexerFlagsBeforeParen;\nif (tok_getNlwas() === true) {\nreturn THROW_RANGE('The arrow token `=>` is a restricted production and cannot have a newline preceding it', $tp_arrow_start, $tp_arrow_stop);\n}\nif (babelCompat) {\nAST_open(astProp, {type:'ArrowFunctionExpression', loc:undefined, params:[], id:null, generator:false, async:false, body:undefined});\n} else if ((acornCompat && (!allowAsyncFunctions))) {\nAST_open(astProp, {type:'ArrowFunctionExpression', loc:undefined, params:[], id:null, generator:false, expression:undefined, body:undefined});\n} else {\nAST_open(astProp, {type:'ArrowFunctionExpression', loc:undefined, params:[], id:null, generator:false, async:false, expression:undefined, body:undefined});\n}\nlet assignable = parseArrowFromPunc(lexerFlags, paramScoop, 0, allowAssignmentForGroupToBeArrow, 1);\nAST_close($tp_paren_start, $tp_paren_line, $tp_paren_column);\nreturn assignable;\n}\nlet foundSingleIdentWrap = false;\nlet rootAstProp = astProp;\nlet destructible = 0;\nlet assignable = 8;\nlet toplevelComma = false;\nlet wasSimple = 1;\nlet mustBeArrow = false;\nwhile (tok_getType() !== 16472) {\nif (isIdentToken(tok_getType())) {\nlet $tp_ident_type = tok_getType();\nlet $tp_ident_line = tok_getLine();\nlet $tp_ident_column = tok_getColumn();\nlet $tp_ident_start = tok_getStart();\nlet $tp_ident_stop = tok_getStop();\nlet $tp_ident_canon = tok_getCanoN();\nskipIdentSafeSlowAndExpensive(lexerFlags, false);\nlet wasAssignment = tok_getType() === 49264;\nlet wasCommaOrEnd = ((tok_getType() === 16480) || (tok_getType() === 16472));\nlet exprAssignable = parseExpressionAfterIdent(lexerFlags, $tp_ident_type, $tp_ident_start, $tp_ident_stop, $tp_ident_line, $tp_ident_column, $tp_ident_canon, 1, astProp);\nassignable = mergeAssignable(exprAssignable, assignable);\nSCOPE_addLexBinding(paramScoop, $tp_ident_start, $tp_ident_stop, $tp_ident_canon, 1, 1);\nif (wasAssignment) {\nwasSimple = 3;\n} else if (wasCommaOrEnd) {\nif (((!toplevelComma) && (tok_getType() === 16472))) {\nfoundSingleIdentWrap = true;\n}\nif (notAssignable(assignable)) {\ndestructible |= 1;\n} else if (isStrictOnlyKeyword($tp_ident_type, $tp_ident_start, $tp_ident_stop, $tp_ident_canon)) {\nwasSimple = 3;\n} else {\n\n}\n} else {\ndestructible |= 1;\n}\n} else if (tok_getType() === 16513) {\nlet $tp_startOfPattern_line = tok_getLine();\nlet $tp_startOfPattern_column = tok_getColumn();\nlet $tp_startOfPattern_start = tok_getStart();\nlet $tp_startOfPattern_stop = tok_getStop();\ndestructible |= parseObjectOuter(lexerFlags, paramScoop, 1, true, undefined, undefined, astProp);\nif (((tok_getType() !== 16480) && (tok_getType() !== 16472))) {\ndestructible |= 1;\n}\nassignable = parseAfterPatternInGroup(lexerFlags, $tp_startOfPattern_start, $tp_startOfPattern_stop, $tp_startOfPattern_line, $tp_startOfPattern_column, assignable, destructible, astProp);\nwasSimple = 3;\n} else if (tok_getType() === 16509) {\nlet $tp_startOfPattern_line = tok_getLine();\nlet $tp_startOfPattern_column = tok_getColumn();\nlet $tp_startOfPattern_start = tok_getStart();\nlet $tp_startOfPattern_stop = tok_getStop();\ndestructible |= parseArrayOuter(lexerFlags, paramScoop, 1, true, undefined, undefined, astProp);\nif (((tok_getType() !== 16480) && (tok_getType() !== 16472))) {\ndestructible |= 1;\n}\nassignable = parseAfterPatternInGroup(lexerFlags, $tp_startOfPattern_start, $tp_startOfPattern_stop, $tp_startOfPattern_line, $tp_startOfPattern_column, assignable, destructible, astProp);\nwasSimple = 3;\n} else if (tok_getType() === 16486) {\nwasSimple = 3;\nlet subDestruct = parseArrowableSpreadOrRest(lexerFlags, paramScoop, 16472, 1, $tp_async_type, undefined, undefined, astProp);\ndestructible |= subDestruct;\nif ($tp_async_type === 2074) {\nif (tok_getType() !== 16472) {\ndestructible |= 1;\n} else {\n\n}\n} else {\nif ((((subDestruct & 1) === 1) || (tok_getType() === 16480))) {\nreturn THROW_RANGE('The ... argument must be destructible in an arrow header, found something that was not destructible', tok_getStart(), tok_getStop());\n}\nmustBeArrow = true;\nbreak;\n}\n} else {\ndestructible |= 1;\nlet exprAssignable = parseExpression(lexerFlags, astProp);\nassignable = mergeAssignable(exprAssignable, assignable);\nif (tok_getType() === 16480) {\nif (!toplevelComma) {\ntoplevelComma = true;\nAST_wrapClosedIntoArrayCustom(rootAstProp, {type:'SequenceExpression', loc:undefined, expressions:undefined}, 'expressions');\nastProp = 'expressions';\n}\nassignable = __parseExpressions(lexerFlags, assignable, astProp);\n}\nif (toplevelComma) {\nif (babelCompat) AST_set('extra', {parenthesized:true, parenStart:$tp_paren_start});\nAST_close($tp_firstTokenAfterParen_start, $tp_firstTokenAfterParen_line, $tp_firstTokenAfterParen_column);\nassignable = setNotAssignable(assignable);\n}\nif (tok_getType() !== 16472) {\nreturn THROW_RANGE(('Expected the closing paren `)` for the group, found `' + tok_sliceInput(tok_getStart(), tok_getStop())) + '` instead', tok_getStart(), tok_getStop());\n}\nskipDiv(lexerFlags);\nif ($tp_async_type === 2074) {\nif (tok_getType() === 16499) {\nreturn THROW_RANGE('The header of this async arrow contained something that is not valid a param', tok_getStart(), tok_getStop());\n}\nreturn parseAfterAsyncGroup(lexerFlagsBeforeParen, paramScoop, asyncStmtOrExpr, allowAssignmentForGroupToBeArrow, wasSimple, toplevelComma, newlineAfterAsync, false, $tp_async_start, $tp_async_stop, $tp_async_line, $tp_async_column, $tp_async_canon, assignable, rootAstProp);\n}\nif ((babelCompat && (!toplevelComma))) {\nAST_babelParenthesizesClosed($tp_paren_start, astProp);\n}\nreturn (assignable | 1024) ^ 1024;\n}\nif (tok_getType() !== 16480) break;\nskipToExpressionStartGrouped(lexerFlags);\nif (tok_getType() === 16472) {\nif ($tp_async_type === 0) {\nif (allowTrailingFunctionComma) {\nmustBeArrow = true;\nbreak;\n}\nreturn THROW_RANGE('Encountered trailing comma in the toplevel of a group, this could be valid in arrows but not with the currently targeted language version', tok_getStart(), tok_getStop());\n}\n}\nif (!toplevelComma) {\ntoplevelComma = true;\nAST_wrapClosedIntoArrayCustom(rootAstProp, {type:'SequenceExpression', loc:undefined, expressions:undefined}, 'expressions');\nastProp = 'expressions';\n}\n}\nif (toplevelComma) {\nassignable = setNotAssignable(assignable);\nif (babelCompat) AST_set('extra', {parenthesized:true, parenStart:$tp_paren_start});\nAST_close($tp_firstTokenAfterParen_start, $tp_firstTokenAfterParen_line, $tp_firstTokenAfterParen_column);\n}\ndestructible = copyPiggies(destructible, assignable);\nif (tok_getType() !== 16472) {\nreturn THROW_RANGE(('Missing closing paren `)` for group, found `' + tok_sliceInput(tok_getStart(), tok_getStop())) + '` instead', tok_getStart(), tok_getStop());\n}\nskipDiv(lexerFlags);\nlexerFlags = lexerFlagsBeforeParen;\nverifyDestructible(destructible);\nlet isArrow = tok_getType() === 16499;\nif (isArrow) {\ndestructible |= 1024;\nlet $tp_arrow_start = tok_getStart();\nlet $tp_arrow_stop = tok_getStop();\nif (leftHandSideExpression === true) {\nlet $tp_errorOffset_start = (($tp_async_type === 2074)? $tp_async_start : $tp_paren_start);\nreturn THROW_RANGE('Arrow not allowed in this position', $tp_errorOffset_start, $tp_arrow_stop);\n}\nif (tok_getNlwas() === true) {\nreturn THROW_RANGE('Arrow is restricted production; cannot have newline before the arrow token', $tp_arrow_start, $tp_arrow_stop);\n}\nif ((destructible & 1) === 1) {\nif ($tp_async_type === 2074) {\nreturn THROW_RANGE('The left hand side of the async arrow is not destructible so arrow is illegal', $tp_arrow_start, $tp_arrow_stop);\n}\nreturn THROW_RANGE('The left hand side of the arrow is not destructible so arrow is illegal', $tp_arrow_start, $tp_arrow_stop);\n}\nif ((destructible & 2) === 2) {\nreturn THROW_RANGE('The left hand side of the arrow can only be destructed through assignment so arrow is illegal', $tp_arrow_start, $tp_arrow_stop);\n}\nif ((destructible & 64) !== 0) {\nif ($tp_async_type === 2074) {\nreturn THROW_RANGE('The parameter header of an async arrow cannot contain `await` as varname nor as a keyword', $tp_async_start, $tp_async_stop);\n}\nif ((lexerFlags & 8) !== 0) {\nreturn THROW_RANGE('The parameter header of an arrow inside an async function cannot contain `await` as varname nor as a keyword', tok_getStart(), tok_getStop());\n}\n}\nif ((destructible & 128) === 128) {\nreturn THROW_RANGE('The arguments of an arrow cannot contain a yield expression in their defaults', $tp_arrow_start, $tp_arrow_stop);\n}\n} else if ((((destructible & 4) === 4) || mustBeArrow)) {\nreturn THROW_RANGE('Group contained a value that must destruct but this was not an arrow so it is invalid', $tp_paren_start, tok_getStop());\n}\nif ($tp_async_type === 2074) {\ndestructible = copyPiggies(destructible, assignable);\nreturn parseAfterAsyncGroup(lexerFlags, paramScoop, asyncStmtOrExpr, allowAssignmentForGroupToBeArrow, wasSimple, toplevelComma, newlineAfterAsync, false, $tp_async_start, $tp_async_stop, $tp_async_line, $tp_async_column, $tp_async_canon, assignable, rootAstProp);\n}\nif (isArrow) {\nparseArrowAfterGroup(lexerFlags, paramScoop, wasSimple, toplevelComma, 0, $tp_paren_start, $tp_paren_line, $tp_paren_column, allowAssignmentForGroupToBeArrow, rootAstProp);\nassignable = copyPiggies(assignable, destructible);\nreturn 1040 | (assignable & 64);\n}\nif ((babelCompat && (!toplevelComma))) {\nAST_babelParenthesizesClosed($tp_paren_start, astProp);\n}\nreturn (assignable | 1024) ^ 1024;\n}\nfunction parseAfterPatternInGroup(lexerFlags, $tp_startOfPattern_start, $tp_startOfPattern_stop, $tp_startOfPattern_line, $tp_startOfPattern_column, assignable, destructible, astProp) {\nif (((tok_getType() !== 16480) && (tok_getType() !== 16472))) {\nif ((destructible & 4) === 4) {\nreturn THROW_RANGE('Pattern can not have a tail but did not find a comma or closing paren of the arrow header', tok_getStart(), tok_getStop());\n}\nlet exprAssignable = parseValueTail(lexerFlags, $tp_startOfPattern_start, $tp_startOfPattern_line, $tp_startOfPattern_column, 16, 4, false, astProp);\nassignable = mergeAssignable(exprAssignable, assignable);\nif (((tok_getType() !== 16480) && (tok_getType() !== 16472))) {\nassignable = parseExpressionFromOp(lexerFlags, $tp_startOfPattern_start, $tp_startOfPattern_stop, $tp_startOfPattern_line, $tp_startOfPattern_column, assignable, astProp);\n}\n} else {\nassignable = setNotAssignable(assignable);\n}\nreturn assignable;\n}\nfunction parseAfterAsyncGroup(lexerFlags, paramScoop, fromStmtOrExpr, allowAssignment, wasSimple, toplevelComma, newlineAfterAsync, zeroArgs, $tp_async_start, $tp_async_stop, $tp_async_line, $tp_async_column, $tp_async_canon, assignable, astProp) {\nif (tok_getType() === 16499) {\nlet $tp_arrow_start = tok_getStart();\nlet $tp_arrow_stop = tok_getStop();\nif (tok_getNlwas() === true) {\nreturn THROW_RANGE('The arrow is a restricted production an there can not be a newline before `=>` token', $tp_arrow_start, $tp_arrow_stop);\n}\nif (newlineAfterAsync === true) {\nreturn THROW_RANGE('A newline after async is always a syntax error if the rhs turns to be an arrow function', $tp_arrow_start, $tp_arrow_stop);\n}\nif (zeroArgs) {\nparseArrowAfterAsyncNoArgGroup(lexerFlags, paramScoop, $tp_async_start, $tp_async_line, $tp_async_column, allowAssignment, astProp);\n} else {\nparseArrowAfterGroup(lexerFlags, paramScoop, wasSimple, toplevelComma, 2074, $tp_async_start, $tp_async_line, $tp_async_column, allowAssignment, astProp);\n}\n} else {\nif (zeroArgs) {\nAST_setNode(astProp, {type:'CallExpression', loc:AST_getClosedLoc($tp_async_start, $tp_async_line, $tp_async_column), callee:AST_getIdentNode($tp_async_start, $tp_async_stop, $tp_async_line, $tp_async_column, $tp_async_canon), arguments:[]});\n} else {\nAST_patchAsyncCall($tp_async_start, $tp_async_stop, $tp_async_line, $tp_async_column, $tp_async_canon, astProp);\n}\nlet assignable = parseValueTail(lexerFlags, $tp_async_start, $tp_async_line, $tp_async_column, 16, 4, false, astProp);\nif (fromStmtOrExpr === 2) {\nassignable = parseExpressionFromOp(lexerFlags, $tp_async_start, $tp_async_stop, $tp_async_line, $tp_async_column, assignable, astProp);\nif (tok_getType() === 16480) {\nassignable = _parseExpressions(lexerFlags, $tp_async_start, $tp_async_line, $tp_async_column, assignable, astProp);\n}\nparseSemiOrAsi(lexerFlags);\n}\nreturn assignable;\n}\nif (fromStmtOrExpr === 2) {\nif (tok_getType() === 16480) {\n_parseExpressions(lexerFlags, $tp_async_start, $tp_async_line, $tp_async_column, 16, astProp);\n}\nparseSemiOrAsi(lexerFlags);\n}\nreturn 1040 | (assignable & 64);\n}\nfunction parseArrowAfterAsyncNoArgGroup(lexerFlags, paramScoop, $tp_async_start, $tp_async_line, $tp_async_column, allowAssignment, astProp) {\nif (babelCompat) {\nAST_open(astProp, {type:'ArrowFunctionExpression', loc:undefined, params:[], id:null, generator:false, async:true, body:undefined});\n} else if ((acornCompat && (!allowAsyncFunctions))) {\nAST_open(astProp, {type:'ArrowFunctionExpression', loc:undefined, params:[], id:null, generator:false, expression:undefined, body:undefined});\n} else {\nAST_open(astProp, {type:'ArrowFunctionExpression', loc:undefined, params:[], id:null, generator:false, async:true, expression:undefined, body:undefined});\n}\nlet assignable = parseArrowFromPunc(lexerFlags, paramScoop, 2074, allowAssignment, 1);\nAST_close($tp_async_start, $tp_async_line, $tp_async_column);\nreturn assignable;\n}\nfunction parseArrowAfterGroup(lexerFlags, paramScoop, wasSimple, toplevelComma, $tp_async_type, $tp_arrowStart_start, $tp_arrowStart_line, $tp_arrowStart_column, allowAssignment, astProp) {\nif (babelCompat) {\nAST_wrapClosedIntoArrayCustom(astProp, {type:'ArrowFunctionExpression', loc:undefined, params:undefined, id:null, generator:false, async:$tp_async_type === 2074, body:undefined}, 'params');\n} else if ((acornCompat && (!allowAsyncFunctions))) {\nAST_wrapClosedIntoArrayCustom(astProp, {type:'ArrowFunctionExpression', loc:undefined, params:undefined, id:null, generator:false, expression:undefined, body:undefined}, 'params');\n} else {\nAST_wrapClosedIntoArrayCustom(astProp, {type:'ArrowFunctionExpression', loc:undefined, params:undefined, id:null, generator:false, async:$tp_async_type === 2074, expression:undefined, body:undefined}, 'params');\n}\nlet top = _path[_path.length - 1];\nif (toplevelComma) {\nlet params = top.params[top.params.length - 1];\ntop.params = params.expressions;\n}\nlet params = top.params;\nfor (let i = 0;i < params.length;++i) {\nAST__destruct(params[i], params, i);\n}\nparseArrowFromPunc(lexerFlags, paramScoop, $tp_async_type, allowAssignment, wasSimple);\nAST_close($tp_arrowStart_start, $tp_arrowStart_line, $tp_arrowStart_column);\n}\nfunction parseArrayOuter(lexerFlagsBeforeParen, scoop, bindingType, skipInit, exportedNames, exportedBindings, astProp) {\nlet destructible = parseArrayLiteralPattern(lexerFlagsBeforeParen, scoop, bindingType, skipInit, exportedNames, exportedBindings, astProp);\nreturn destructible;\n}\nfunction parseArrayLiteralPattern(lexerFlagsBeforeParen, scoop, bindingType, skipInit, exportedNames, exportedBindings, _astProp) {\nlet lexerFlags = (lexerFlagsBeforeParen | 32) ^ 32;\nlet $tp_arrayOpen_line = tok_getLine();\nlet $tp_arrayOpen_column = tok_getColumn();\nlet $tp_arrayOpen_start = tok_getStart();\nskipToExpressionStartSquareCloseComma(lexerFlags);\nAST_open(_astProp, {type:'ArrayExpression', loc:undefined, elements:[]});\nlet astProp = 'elements';\nlet destructible = 0;\nwhile (tok_getType() === 16480) {\nskipToExpressionStartSquareCloseComma(lexerFlags);\nAST_add(astProp, null);\n}\nlet spreadStage = 0;\nlet assignableYieldAwaitState = 8;\nwhile (tok_getType() !== 16510) {\nlet $tp_elementStart_line = tok_getLine();\nlet $tp_elementStart_column = tok_getColumn();\nlet $tp_elementStart_start = tok_getStart();\nlet $tp_elementStart_stop = tok_getStop();\nif (isIdentToken(tok_getType())) {\nlet $tp_ident_type = tok_getType();\nlet $tp_ident_line = tok_getLine();\nlet $tp_ident_column = tok_getColumn();\nlet $tp_ident_start = tok_getStart();\nlet $tp_ident_stop = tok_getStop();\nlet $tp_ident_canon = tok_getCanoN();\nskipIdentSafeSlowAndExpensive(lexerFlags, false);\nlet nextIsAssignment = tok_getType() === 49264;\nlet nextIsCommaOrEnd = ((tok_getType() === 16480) || (tok_getType() === 16510));\nlet leftAssignable = parseValueHeadBodyAfterIdent(lexerFlags, $tp_ident_type, $tp_ident_start, $tp_ident_stop, $tp_ident_line, $tp_ident_column, $tp_ident_canon, bindingType, 4, true, false, astProp);\nassignableYieldAwaitState |= leftAssignable;\nif (nextIsAssignment) {\nif (notAssignable(leftAssignable)) {\nreturn THROW_RANGE(('Cannot assign or destruct to keyword `' + tok_sliceInput($tp_ident_start, $tp_ident_stop)) + '`', $tp_ident_start, $tp_ident_stop);\n}\nSCOPE_actuallyAddBinding(lexerFlags, scoop, $tp_ident_start, $tp_ident_stop, $tp_ident_canon, bindingType);\naddNameToExports(exportedNames, $tp_ident_start, $tp_ident_stop, $tp_ident_canon);\naddBindingToExports(exportedBindings, $tp_ident_canon);\nAST_wrapClosedCustom(astProp, {type:'AssignmentExpression', loc:undefined, left:undefined, operator:'=', right:undefined}, 'left');\nskipToExpressionStart(lexerFlags);\nlet rightAssignable = parseExpression(lexerFlags, 'right');\nAST_close($tp_ident_start, $tp_ident_line, $tp_ident_column);\nassignableYieldAwaitState |= rightAssignable;\n} else if (nextIsCommaOrEnd) {\nif (notAssignable(leftAssignable)) {\ndestructible |= 1;\n} else {\nSCOPE_actuallyAddBinding(lexerFlags, scoop, $tp_ident_start, $tp_ident_stop, $tp_ident_canon, bindingType);\naddNameToExports(exportedNames, $tp_ident_start, $tp_ident_stop, $tp_ident_canon);\naddBindingToExports(exportedBindings, $tp_ident_canon);\n}\n} else {\nif (bindingType === 1) {\ndestructible |= 2;\n} else if (bindingType !== 0) {\ndestructible |= 1;\n}\nlet nowDestruct = parseOptionalDestructibleRestOfExpression(lexerFlags, $tp_ident_start, $tp_ident_stop, $tp_ident_line, $tp_ident_column, leftAssignable, 1, 16510, astProp);\ndestructible |= nowDestruct;\n}\n} else if (tok_getType() === 16513) {\nlet $tp_objOpen_line = tok_getLine();\nlet $tp_objOpen_column = tok_getColumn();\nlet $tp_objOpen_start = tok_getStart();\nlet $tp_objOpen_stop = tok_getStop();\nlet objDestructible = parseObjectAndAssign(lexerFlags, scoop, bindingType, true, exportedNames, exportedBindings, astProp);\ndestructible |= parseOptionalDestructibleRestOfExpression(lexerFlags, $tp_objOpen_start, $tp_objOpen_stop, $tp_objOpen_line, $tp_objOpen_column, (((objDestructible & 1) === 1)? 16 : 32), objDestructible, 16510, astProp);\n} else if (tok_getType() === 16509) {\nlet $tp_arrOpen_line = tok_getLine();\nlet $tp_arrOpen_column = tok_getColumn();\nlet $tp_arrOpen_start = tok_getStart();\nlet $tp_arrOpen_stop = tok_getStop();\nlet arrDestructible = parseArrayLiteralPattern(lexerFlags, scoop, bindingType, true, exportedNames, exportedBindings, astProp);\ndestructible |= parseOptionalDestructibleRestOfExpression(lexerFlags, $tp_arrOpen_start, $tp_arrOpen_stop, $tp_arrOpen_line, $tp_arrOpen_column, (((arrDestructible & 1) === 1)? 16 : 32), arrDestructible, 16510, astProp);\n} else if (tok_getType() === 16486) {\nlet subDestruct = parseArrowableSpreadOrRest(lexerFlags, scoop, 16510, bindingType, 0, exportedNames, exportedBindings, astProp);\ndestructible |= subDestruct;\nif (spreadStage === 0) spreadStage = 1;\n} else {\nlet $tp_exprStart_line = tok_getLine();\nlet $tp_exprStart_column = tok_getColumn();\nlet $tp_exprStart_start = tok_getStart();\nlet $tp_exprStart_stop = tok_getStop();\nlet wasParen = tok_getType() === 16471;\nlet assignable = parseValue(lexerFlags, true, 4, false, astProp);\nif (tok_getType() === 49264) {\nif (isAssignable(assignable)) {\nAST_wrapClosedCustom(astProp, {type:'AssignmentExpression', loc:undefined, left:undefined, operator:'=', right:undefined}, 'left');\nskipToExpressionStart(lexerFlags);\ndestructible |= parseExpression(lexerFlags, 'right');\nAST_close($tp_elementStart_start, $tp_elementStart_line, $tp_elementStart_column);\n} else {\nreturn THROW_RANGE(('Cannot assign to lhs (starting with `' + tok_sliceInput($tp_elementStart_start, $tp_elementStart_stop)) + '`)', $tp_elementStart_start, $tp_elementStart_stop);\n}\n}\nif (((tok_getType() !== 16480) && (tok_getType() !== 16510))) {\nassignable = parseExpressionFromOp(lexerFlags, $tp_exprStart_start, $tp_exprStart_stop, $tp_exprStart_line, $tp_exprStart_column, assignable, astProp);\nassignable = setNotAssignable(assignable);\ndestructible |= 1;\n} else if ((((wasParen && isAssignable(assignable))) && (((bindingType === 0) || (bindingType === 1))))) {\ndestructible |= 2;\n} else if ((wasParen || notAssignable(assignable))) {\ndestructible |= 1;\n} else {\n\n}\n}\nif (tok_getType() !== 16480) break;\nskipToExpressionStartSquareCloseComma(lexerFlags);\nwhile (tok_getType() === 16480) {\nskipToExpressionStartSquareCloseComma(lexerFlags);\nAST_add(astProp, null);\n}\nif (spreadStage === 1) {\nspreadStage = 2;\ndestructible |= 1;\n}\n}\nlexerFlags = lexerFlagsBeforeParen;\nif (tok_getType() !== 16510) {\nreturn THROW_RANGE(('Expected the closing bracket `]` for the array, found `' + tok_sliceInput(tok_getStart(), tok_getStop())) + '` instead', tok_getStart(), tok_getStop());\n}\nskipDiv(lexerFlags);\nAST_close($tp_arrayOpen_start, $tp_arrayOpen_line, $tp_arrayOpen_column);\nif (skipInit === true) {\ndestructible = parsePatternAssignMaybe(lexerFlags, $tp_arrayOpen_start, $tp_arrayOpen_line, $tp_arrayOpen_column, destructible, _astProp);\n}\nreturn (copyPiggies(destructible, assignableYieldAwaitState) | 1024) ^ 1024;\n}\nfunction parseObjectOuter(lexerFlags, scoop, bindingType, skipInit, exportedNames, exportedBindings, astProp) {\nreturn parseObjectAndAssign(lexerFlags, scoop, bindingType, skipInit, exportedNames, exportedBindings, astProp);\n}\nfunction parseObjectAndAssign(lexerFlags, scoop, bindingType, skipInit, exportedNames, exportedBindings, astProp) {\nlet $tp_curly_line = tok_getLine();\nlet $tp_curly_column = tok_getColumn();\nlet $tp_curly_start = tok_getStart();\nAST_open(astProp, {type:'ObjectExpression', loc:undefined, properties:[]});\nlet destructible = parseObjectSansAssign(lexerFlags | 4096, scoop, bindingType, exportedNames, exportedBindings, 'properties');\nAST_close($tp_curly_start, $tp_curly_line, $tp_curly_column);\nif (skipInit === true) {\ndestructible = parsePatternAssignMaybe(lexerFlags, $tp_curly_start, $tp_curly_line, $tp_curly_column, destructible, astProp);\n}\nreturn destructible;\n}\nfunction parseObjectSansAssign(outerLexerFlags, scoop, bindingType, exportedNames, exportedBindings, astProp) {\nlet lexerFlags = (outerLexerFlags | 2080) ^ 2080;\nskipAny(lexerFlags);\nlet destructible = 0;\nlet hasThunderProto = false;\ndo {\nif (tok_getType() === 16480) {\nreturn THROW_RANGE('Objects cant have comma without something preceding it', tok_getStart(), tok_getStop());\n}\nlet currentDestruct = parseObjectPart(lexerFlags, scoop, bindingType, exportedNames, exportedBindings, astProp);\nif ((currentDestruct & 512) !== 0) {\ncurrentDestruct ^= 512;\nif (hasThunderProto) {\ndestructible |= 4;\n}\nhasThunderProto = true;\n}\ndestructible |= currentDestruct;\nif (tok_getType() !== 16480) break;\nskipAny(lexerFlags);\n} while (tok_getType() !== 16517);\nlexerFlags = outerLexerFlags;\nif (tok_getType() !== 16517) {\nreturn THROW_RANGE(('Expected the closing curly `}` for an object, found `' + tok_sliceInput(tok_getStart(), tok_getStop())) + '` instead', tok_getStart(), tok_getStop());\n}\nskipDiv(lexerFlags);\nreturn destructible;\n}\nfunction parseObjectPart(lexerFlags, scoop, bindingType, exportedNames, exportedBindings, astProp) {\nlet $tp_startOfKey_type = tok_getType();\nlet $tp_startOfKey_line = tok_getLine();\nlet $tp_startOfKey_column = tok_getColumn();\nlet $tp_startOfKey_start = tok_getStart();\nif (isIdentToken($tp_startOfKey_type)) {\nreturn parseObjectPartFromIdent(lexerFlags, $tp_startOfKey_type, scoop, bindingType, exportedNames, exportedBindings, astProp);\n}\nif ($tp_startOfKey_type === 16517) {\nreturn 0;\n}\nif (isNumberStringToken($tp_startOfKey_type)) {\nreturn parseObjectPartFromLiteral(lexerFlags, scoop, exportedNames, exportedBindings, bindingType, astProp);\n}\nif ($tp_startOfKey_type === 16509) {\nreturn parseObjectPartFromComputed(lexerFlags, scoop, exportedNames, exportedBindings, bindingType, astProp);\n}\nif ($tp_startOfKey_type === 16486) {\nreturn parseObjectRestSpread(lexerFlags, scoop, bindingType, exportedNames, exportedBindings, astProp);\n}\nif ($tp_startOfKey_type === 82009) {\nskipAny(lexerFlags);\nreturn parseObjectMethodFromKey(lexerFlags, $tp_startOfKey_start, $tp_startOfKey_line, $tp_startOfKey_column, 'init', true, 0, 82009, 0, 0, astProp);\n}\nreturn THROW_RANGE(('Unexpected token, wanted to parse a start of a property in an object literal/pattern, got `' + tok_sliceInput(tok_getStart(), tok_getStop())) + '`', tok_getStart(), tok_getStop());\n}\nfunction parseObjectMethodFromKey(lexerFlags, $tp_startOfProp_start, $tp_startOfProp_line, $tp_startOfProp_column, kind, isRealMethod, $tp_async_type, $tp_star_type, $tf_getToken_type, $tf_setToken_type, astProp) {\nlet $tp_keyStart_type = tok_getType();\nlet $tp_keyStart_line = tok_getLine();\nlet $tp_keyStart_column = tok_getColumn();\nlet $tp_keyStart_start = tok_getStart();\nlet $tp_keyStart_stop = tok_getStop();\nlet $tp_keyStart_canon = tok_getCanoN();\nif (isIdentToken($tp_keyStart_type)) {\nskipAny(lexerFlags);\nAST_setIdent(astProp, $tp_keyStart_start, $tp_keyStart_stop, $tp_keyStart_line, $tp_keyStart_column, $tp_keyStart_canon);\nif (tok_getType() !== 16471) {\nreturn THROW_RANGE(('Expected to parse an opening paren, found `' + tok_sliceInput(tok_getStart(), tok_getStop())) + '`', tok_getStart(), tok_getStop());\n}\nreturn parseObjectMethod(lexerFlags, $tp_startOfProp_start, $tp_startOfProp_line, $tp_startOfProp_column, kind, false, isRealMethod, $tp_async_type, $tp_star_type, $tf_getToken_type, $tf_setToken_type, astProp);\n}\nif (isNumberStringToken($tp_keyStart_type)) {\nskipAny(lexerFlags);\nAST_setLiteral(astProp, $tp_keyStart_type, $tp_keyStart_start, $tp_keyStart_stop, $tp_keyStart_line, $tp_keyStart_column, $tp_keyStart_canon);\nif (tok_getType() !== 16471) {\nreturn THROW_RANGE(('Expected to parse an opening paren, found `' + tok_sliceInput(tok_getStart(), tok_getStop())) + '`', tok_getStart(), tok_getStop());\n}\nreturn parseObjectMethod(lexerFlags, $tp_startOfProp_start, $tp_startOfProp_line, $tp_startOfProp_column, kind, false, isRealMethod, $tp_async_type, $tp_star_type, $tf_getToken_type, $tf_setToken_type, astProp);\n}\nif ($tp_keyStart_type === 16509) {\nskipRex(lexerFlags);\nparseExpression(lexerFlags, astProp);\nif (tok_getType() !== 16510) {\nreturn THROW_RANGE(('Missing closing square bracket for computed property name, found `' + tok_sliceInput(tok_getStart(), tok_getStop())) + '` instead', tok_getStart(), tok_getStop());\n}\nskipAny(lexerFlags);\nif (tok_getType() !== 16471) {\nreturn THROW_RANGE(('Expected to parse an opening paren, found `' + tok_sliceInput(tok_getStart(), tok_getStop())) + '`', tok_getStart(), tok_getStop());\n}\nreturn parseObjectMethod(lexerFlags, $tp_startOfProp_start, $tp_startOfProp_line, $tp_startOfProp_column, kind, true, isRealMethod, $tp_async_type, $tp_star_type, $tf_getToken_type, $tf_setToken_type, astProp);\n}\nTHROW_RANGE(('Expected to parse an object method key, found `' + tok_sliceInput(tok_getStart(), tok_getStop())) + '` instead', tok_getStart(), tok_getStop());\n}\nfunction parseObjectPartFromIdent(lexerFlags, $tp_propLeadingIdent_type, scoop, bindingType, exportedNames, exportedBindings, astProp) {\nlet $tp_propLeadingIdent_line = tok_getLine();\nlet $tp_propLeadingIdent_column = tok_getColumn();\nlet $tp_propLeadingIdent_start = tok_getStart();\nlet $tp_propLeadingIdent_stop = tok_getStop();\nlet $tp_propLeadingIdent_canon = tok_getCanoN();\nskipAny(lexerFlags);\nlet $tp_afterIdent_type = tok_getType();\nif ($tp_afterIdent_type === 16489) {\nAST_setIdent(astProp, $tp_propLeadingIdent_start, $tp_propLeadingIdent_stop, $tp_propLeadingIdent_line, $tp_propLeadingIdent_column, $tp_propLeadingIdent_canon);\nlet destructible = 0;\nif (((options_webCompat === true) && ($tp_propLeadingIdent_canon === '__proto__'))) {\ndestructible = 512;\n}\nreturn destructible | parseObjectPropertyFromColon(lexerFlags, $tp_propLeadingIdent_start, $tp_propLeadingIdent_line, $tp_propLeadingIdent_column, scoop, exportedNames, exportedBindings, bindingType, false, astProp);\n}\nif ($tp_afterIdent_type === 16471) {\nAST_setIdent(astProp, $tp_propLeadingIdent_start, $tp_propLeadingIdent_stop, $tp_propLeadingIdent_line, $tp_propLeadingIdent_column, $tp_propLeadingIdent_canon);\nreturn parseObjectMethod(lexerFlags, $tp_propLeadingIdent_start, $tp_propLeadingIdent_line, $tp_propLeadingIdent_column, 'init', false, true, 0, 0, 0, 0, astProp);\n}\nif ((($tp_afterIdent_type === 16480) || ($tp_afterIdent_type === 16517))) {\nreturn parseObjectShorthand(lexerFlags, $tp_propLeadingIdent_type, $tp_propLeadingIdent_start, $tp_propLeadingIdent_stop, $tp_propLeadingIdent_line, $tp_propLeadingIdent_column, $tp_propLeadingIdent_canon, bindingType, scoop, exportedNames, exportedBindings, astProp);\n}\nif ($tp_afterIdent_type === 49264) {\nreturn parseObjectShorthandWithInit(lexerFlags, $tp_propLeadingIdent_type, $tp_propLeadingIdent_start, $tp_propLeadingIdent_stop, $tp_propLeadingIdent_line, $tp_propLeadingIdent_column, $tp_propLeadingIdent_canon, bindingType, scoop, exportedNames, exportedBindings, astProp);\n}\nif ($tp_propLeadingIdent_type === 2074) {\nif (!allowAsyncFunctions) {\nreturn THROW_RANGE('Async functions are not supported in the currently targeted language version', $tp_propLeadingIdent_start, tok_getStop());\n}\nif (tok_getNlwas() === true) {\nreturn THROW_RANGE('Async methods are a restricted production and cannot have a newline following it', $tp_propLeadingIdent_start, tok_getStart());\n}\nif (tok_getType() === 82009) {\nif (!allowAsyncGenerators) {\nreturn THROW_RANGE('Async generator methods are not supported in the currently targeted language version', $tp_propLeadingIdent_start, tok_getStop());\n}\nskipAny(lexerFlags);\nreturn parseObjectMethodFromKey(lexerFlags, $tp_propLeadingIdent_start, $tp_propLeadingIdent_line, $tp_propLeadingIdent_column, 'init', true, 2074, 82009, 0, 0, astProp);\n}\nreturn parseObjectMethodFromKey(lexerFlags, $tp_propLeadingIdent_start, $tp_propLeadingIdent_line, $tp_propLeadingIdent_column, 'init', true, 2074, 0, 0, 0, astProp);\n}\nif ($tp_propLeadingIdent_type === 2096) {\nreturn parseObjectMethodFromKey(lexerFlags, $tp_propLeadingIdent_start, $tp_propLeadingIdent_line, $tp_propLeadingIdent_column, 'get', false, 0, 0, 2096, 0, astProp);\n}\nif ($tp_propLeadingIdent_type === 2112) {\nreturn parseObjectMethodFromKey(lexerFlags, $tp_propLeadingIdent_start, $tp_propLeadingIdent_line, $tp_propLeadingIdent_column, 'set', false, 0, 0, 0, 2112, astProp);\n}\nif ($tp_propLeadingIdent_type === 2113) {\nreturn THROW_RANGE('Object members can not be \"static\"', $tp_propLeadingIdent_start, tok_getStop());\n}\nreturn THROW_RANGE(((('Unexpected token `' + tok_sliceInput(tok_getStart(), tok_getStop())) + '` after start of property `') + $tp_propLeadingIdent_canon) + '` while trying to parse an object property/method', $tp_propLeadingIdent_start, tok_getStop());\n}\nfunction parseObjectPropertyFromColon(lexerFlags, $tp_startOfKey_start, $tp_startOfKey_line, $tp_startOfKey_column, scoop, exportedNames, exportedBindings, bindingType, isComputed, astProp) {\nskipRex(lexerFlags);\nif (babelCompat) {\nAST_wrapClosedCustom(astProp, {type:NODE_NAME_PROPERTY, loc:undefined, key:undefined, method:false, computed:isComputed, value:undefined, shorthand:false}, 'key');\n} else {\nAST_wrapClosedCustom(astProp, {type:NODE_NAME_PROPERTY, loc:undefined, key:undefined, kind:'init', method:false, computed:isComputed, value:undefined, shorthand:false}, 'key');\n}\nlet destructible = _parseObjectPropertyFromColon(lexerFlags, scoop, exportedNames, exportedBindings, bindingType);\nAST_close($tp_startOfKey_start, $tp_startOfKey_line, $tp_startOfKey_column);\nreturn destructible;\n}\nfunction _parseObjectPropertyFromColon(lexerFlags, scoop, exportedNames, exportedBindings, bindingType) {\nif (isIdentToken(tok_getType())) {\nreturn parseObjectPropertyValueFromIdent(lexerFlags, scoop, exportedNames, exportedBindings, bindingType);\n}\nlet $tp_start_line = tok_getLine();\nlet $tp_start_column = tok_getColumn();\nlet $tp_start_start = tok_getStart();\nlet $tp_start_stop = tok_getStop();\nif (tok_getType() === 16513) {\nlet destructible = parseObjectOuter(lexerFlags, scoop, bindingType, true, exportedNames, exportedBindings, 'value');\nlet objAssignable = ((destructible & 1)? 16 : 32);\nif (((tok_getType() === 16480) || (tok_getType() === 16517))) {\nreturn destructible;\n}\nif (4 & destructible) {\nreturn THROW_RANGE(('Object pattern contained parts cause it not to be valid as a regular object literal so the next token `' + tok_sliceInput(tok_getStart(), tok_getStop())) + '` is illegal', tok_getStart(), tok_getStop());\n}\nlet exprAssignable = parseValueTail(lexerFlags, $tp_start_start, $tp_start_line, $tp_start_column, objAssignable, 4, false, 'value');\nlet wasAssignment = tok_getType() === 49264;\nexprAssignable = parseExpressionFromOp(lexerFlags, $tp_start_start, $tp_start_stop, $tp_start_line, $tp_start_column, exprAssignable, 'value');\nif ((wasAssignment || isAssignable(exprAssignable))) {\nreturn copyPiggies(2, exprAssignable);\n}\nreturn copyPiggies(1, exprAssignable);\n}\nif (tok_getType() === 16509) {\nlet destructible = parseArrayOuter(lexerFlags, scoop, bindingType, true, exportedNames, exportedBindings, 'value');\nlet objAssignable = ((destructible & 1)? 16 : 32);\nif (((tok_getType() === 16480) || (tok_getType() === 16517))) {\nreturn destructible;\n}\nif (4 & destructible) {\nreturn THROW_RANGE(('Object pattern contained parts cause it not to be valid as a regular object literal so the next token `' + tok_sliceInput(tok_getStart(), tok_getStop())) + '` is illegal', tok_getStart(), tok_getStop());\n}\nlet exprAssignable = parseValueTail(lexerFlags, $tp_start_start, $tp_start_line, $tp_start_column, objAssignable, 4, false, 'value');\nlet wasAssignment = tok_getType() === 49264;\nexprAssignable = parseExpressionFromOp(lexerFlags, $tp_start_start, $tp_start_stop, $tp_start_line, $tp_start_column, exprAssignable, 'value');\nif ((wasAssignment || isAssignable(exprAssignable))) {\nreturn copyPiggies(2, exprAssignable);\n}\nreturn copyPiggies(1, exprAssignable);\n}\nlet valueAssignable = parseValue(lexerFlags, true, 4, false, 'value');\nlet wasAssignment = tok_getType() === 49264;\nvalueAssignable = parseExpressionFromOp(lexerFlags, $tp_start_start, $tp_start_stop, $tp_start_line, $tp_start_column, valueAssignable, 'value');\nif ((wasAssignment || isAssignable(valueAssignable))) {\nreturn copyPiggies(2, valueAssignable);\n}\nreturn copyPiggies(1, valueAssignable);\n}\nfunction parseObjectPropertyValueFromIdent(lexerFlags, scoop, exportedNames, exportedBindings, bindingType) {\nlet $tp_ident_type = tok_getType();\nlet $tp_ident_line = tok_getLine();\nlet $tp_ident_column = tok_getColumn();\nlet $tp_ident_start = tok_getStart();\nlet $tp_ident_stop = tok_getStop();\nlet $tp_ident_canon = tok_getCanoN();\nskipIdentSafeSlowAndExpensive(lexerFlags, false);\nlet $tp_afterExpr_type = tok_getType();\nif ((($tp_afterExpr_type === 16480) || ($tp_afterExpr_type === 16517))) {\nlet assignableOrErrorMsg = nonFatalBindingIdentCheck($tp_ident_type, $tp_ident_start, $tp_ident_stop, $tp_ident_canon, bindingType, lexerFlags);\nif (assignableOrErrorMsg.length !== 0) {\nlet valueAssignable = parseValueAfterIdent(lexerFlags, $tp_ident_type, $tp_ident_start, $tp_ident_stop, $tp_ident_line, $tp_ident_column, $tp_ident_canon, bindingType, true, 'value');\nreturn copyPiggies(1, valueAssignable);\n}\nAST_setIdent('value', $tp_ident_start, $tp_ident_stop, $tp_ident_line, $tp_ident_column, $tp_ident_canon);\nSCOPE_actuallyAddBinding(lexerFlags, scoop, $tp_ident_start, $tp_ident_stop, $tp_ident_canon, bindingType);\naddNameToExports(exportedNames, $tp_ident_start, $tp_ident_stop, $tp_ident_canon);\naddBindingToExports(exportedBindings, $tp_ident_canon);\nreturn 0;\n}\nif ($tp_afterExpr_type === 49264) {\nlet assignableOrErrorMsg = nonFatalBindingIdentCheck($tp_ident_type, $tp_ident_start, $tp_ident_stop, $tp_ident_canon, bindingType, lexerFlags);\nif (assignableOrErrorMsg.length !== 0) {\nreturn THROW_RANGE('The lhs was not assignable so this is an error', $tp_ident_start, tok_getStop());\n}\nSCOPE_actuallyAddBinding(lexerFlags, scoop, $tp_ident_start, $tp_ident_stop, $tp_ident_canon, bindingType);\naddNameToExports(exportedNames, $tp_ident_start, $tp_ident_stop, $tp_ident_canon);\naddBindingToExports(exportedBindings, $tp_ident_canon);\nAST_setIdent('value', $tp_ident_start, $tp_ident_stop, $tp_ident_line, $tp_ident_column, $tp_ident_canon);\nlet rhsAssignable = parseExpressionFromOp(lexerFlags, $tp_ident_start, $tp_ident_stop, $tp_ident_line, $tp_ident_column, 32, 'value');\nreturn copyPiggies(0, rhsAssignable);\n}\nlet valueAssignable = parseValueAfterIdent(lexerFlags, $tp_ident_type, $tp_ident_start, $tp_ident_stop, $tp_ident_line, $tp_ident_column, $tp_ident_canon, bindingType, true, 'value');\nif (notAssignable(valueAssignable)) {\nlet rhsAssignable = parseExpressionFromOp(lexerFlags, $tp_ident_start, $tp_ident_stop, $tp_ident_line, $tp_ident_column, valueAssignable, 'value');\nreturn copyPiggies(1, rhsAssignable);\n}\nlet wasAssign = tok_getType() === 49264;\nlet rhsAssignable = parseExpressionFromOp(lexerFlags, $tp_ident_start, $tp_ident_stop, $tp_ident_line, $tp_ident_column, valueAssignable, 'value');\nif ((wasAssign || isAssignable(rhsAssignable))) {\nreturn copyPiggies(2, rhsAssignable);\n}\nreturn copyPiggies(1, rhsAssignable);\n}\nfunction parseObjectShorthand(lexerFlags, $tp_propLeadingIdent_type, $tp_propLeadingIdent_start, $tp_propLeadingIdent_stop, $tp_propLeadingIdent_line, $tp_propLeadingIdent_column, $tp_propLeadingIdent_canon, bindingType, scoop, exportedNames, exportedBindings, astProp) {\nlet report = nonFatalBindingIdentCheck($tp_propLeadingIdent_type, $tp_propLeadingIdent_start, $tp_propLeadingIdent_stop, $tp_propLeadingIdent_canon, bindingType, lexerFlags);\nif (((((report.length > 0) && ($tp_propLeadingIdent_type !== 2088))) && ($tp_propLeadingIdent_type !== 2072))) {\nreturn THROW_RANGE(report, $tp_propLeadingIdent_start, $tp_propLeadingIdent_stop);\n}\nSCOPE_actuallyAddBinding(lexerFlags, scoop, $tp_propLeadingIdent_start, $tp_propLeadingIdent_stop, $tp_propLeadingIdent_canon, bindingType);\naddNameToExports(exportedNames, $tp_propLeadingIdent_start, $tp_propLeadingIdent_stop, $tp_propLeadingIdent_canon);\naddBindingToExports(exportedBindings, $tp_propLeadingIdent_canon);\nif (babelCompat) {\nAST_open(astProp, {type:NODE_NAME_PROPERTY, loc:undefined, key:AST_getIdentNode($tp_propLeadingIdent_start, $tp_propLeadingIdent_stop, $tp_propLeadingIdent_line, $tp_propLeadingIdent_column, $tp_propLeadingIdent_canon), method:false, computed:false, value:AST_getIdentNode($tp_propLeadingIdent_start, $tp_propLeadingIdent_stop, $tp_propLeadingIdent_line, $tp_propLeadingIdent_column, $tp_propLeadingIdent_canon), shorthand:true, extra:{shorthand:true}});\n} else {\nAST_open(astProp, {type:NODE_NAME_PROPERTY, loc:undefined, key:AST_getIdentNode($tp_propLeadingIdent_start, $tp_propLeadingIdent_stop, $tp_propLeadingIdent_line, $tp_propLeadingIdent_column, $tp_propLeadingIdent_canon), kind:'init', method:false, computed:false, value:AST_getIdentNode($tp_propLeadingIdent_start, $tp_propLeadingIdent_stop, $tp_propLeadingIdent_line, $tp_propLeadingIdent_column, $tp_propLeadingIdent_canon), shorthand:true});\n}\nAST_close($tp_propLeadingIdent_start, $tp_propLeadingIdent_line, $tp_propLeadingIdent_column);\nif ($tp_propLeadingIdent_type === 2075) {\nreturn 64;\n}\nreturn ((report.length > 0)? 1 : 0);\n}\nfunction parseObjectShorthandWithInit(lexerFlags, $tp_propLeadingIdent_type, $tp_propLeadingIdent_start, $tp_propLeadingIdent_stop, $tp_propLeadingIdent_line, $tp_propLeadingIdent_column, $tp_propLeadingIdent_canon, bindingType, scoop, exportedNames, exportedBindings, astProp) {\nfatalBindingIdentCheck($tp_propLeadingIdent_type, $tp_propLeadingIdent_start, $tp_propLeadingIdent_stop, $tp_propLeadingIdent_canon, bindingType, lexerFlags);\nSCOPE_actuallyAddBinding(lexerFlags, scoop, $tp_propLeadingIdent_start, $tp_propLeadingIdent_stop, $tp_propLeadingIdent_canon, bindingType);\naddNameToExports(exportedNames, $tp_propLeadingIdent_start, $tp_propLeadingIdent_stop, $tp_propLeadingIdent_canon);\naddBindingToExports(exportedBindings, $tp_propLeadingIdent_canon);\nif (babelCompat) {\nAST_open(astProp, {type:NODE_NAME_PROPERTY, loc:undefined, key:AST_getIdentNode($tp_propLeadingIdent_start, $tp_propLeadingIdent_stop, $tp_propLeadingIdent_line, $tp_propLeadingIdent_column, $tp_propLeadingIdent_canon), method:false, computed:false, value:AST_getIdentNode($tp_propLeadingIdent_start, $tp_propLeadingIdent_stop, $tp_propLeadingIdent_line, $tp_propLeadingIdent_column, $tp_propLeadingIdent_canon), shorthand:true, extra:{shorthand:true}});\n} else {\nAST_open(astProp, {type:NODE_NAME_PROPERTY, loc:undefined, key:AST_getIdentNode($tp_propLeadingIdent_start, $tp_propLeadingIdent_stop, $tp_propLeadingIdent_line, $tp_propLeadingIdent_column, $tp_propLeadingIdent_canon), kind:'init', method:false, computed:false, value:AST_getIdentNode($tp_propLeadingIdent_start, $tp_propLeadingIdent_stop, $tp_propLeadingIdent_line, $tp_propLeadingIdent_column, $tp_propLeadingIdent_canon), shorthand:true});\n}\nAST_wrapClosedCustom('value', {type:'AssignmentExpression', loc:undefined, left:undefined, operator:'=', right:undefined}, 'left');\nskipToExpressionStart(lexerFlags);\nlet nowAssignable = parseExpression(lexerFlags, 'right');\nAST_close($tp_propLeadingIdent_start, $tp_propLeadingIdent_line, $tp_propLeadingIdent_column);\nAST_close($tp_propLeadingIdent_start, $tp_propLeadingIdent_line, $tp_propLeadingIdent_column);\nif ($tp_propLeadingIdent_type === 2075) {\nreturn copyPiggies(68, nowAssignable);\n}\nreturn copyPiggies(4, nowAssignable);\n}\nfunction parseObjectPartFromLiteral(lexerFlags, scoop, exportedNames, exportedBindings, bindingType, astProp) {\nlet $tp_lit_type = tok_getType();\nlet $tp_lit_line = tok_getLine();\nlet $tp_lit_column = tok_getColumn();\nlet $tp_lit_start = tok_getStart();\nlet $tp_lit_stop = tok_getStop();\nlet $tp_lit_canon = tok_getCanoN();\nskipToColonParenOpen(lexerFlags);\nAST_setLiteral(astProp, $tp_lit_type, $tp_lit_start, $tp_lit_stop, $tp_lit_line, $tp_lit_column, $tp_lit_canon);\nif (tok_getType() === 16489) {\nlet destructible_forPiggies = 0;\nif (((options_webCompat === true) && ($tp_lit_canon === '__proto__'))) {\ndestructible_forPiggies |= 512;\n}\nreturn destructible_forPiggies | parseObjectPropertyFromColon(lexerFlags, $tp_lit_start, $tp_lit_line, $tp_lit_column, scoop, exportedNames, exportedBindings, bindingType, false, astProp);\n}\nif (tok_getType() !== 16471) {\nreturn THROW_RANGE('Object literal keys that are strings or numbers must be a method or have a colon', tok_getStart(), tok_getStop());\n}\nreturn parseObjectMethod(lexerFlags, $tp_lit_start, $tp_lit_line, $tp_lit_column, 'init', false, true, 0, 0, 0, 0, astProp);\n}\nfunction parseObjectPartFromComputed(lexerFlags, scoop, exportedNames, exportedBindings, bindingType, astProp) {\nlet $tp_keyStart_line = tok_getLine();\nlet $tp_keyStart_column = tok_getColumn();\nlet $tp_keyStart_start = tok_getStart();\nskipToExpressionStart(lexerFlags);\nlet assignable_forPiggies = parseExpression(lexerFlags, astProp);\nif (tok_getType() !== 16510) {\nif (tok_getType() === 16480) {\nreturn THROW_RANGE('The expression of a computed property key can not be a comma expression', tok_getStart(), tok_getStop());\n}\nreturn THROW_RANGE(('Missing closing square bracket for computed property name, found `' + tok_sliceInput(tok_getStart(), tok_getStop())) + '` instead', tok_getStart(), tok_getStop());\n}\nskipToColonParenOpen(lexerFlags);\nlet $tp_afterKey_type = tok_getType();\nif ($tp_afterKey_type === 16489) {\nlet assignable = parseObjectPropertyFromColon(lexerFlags, $tp_keyStart_start, $tp_keyStart_line, $tp_keyStart_column, scoop, exportedNames, exportedBindings, bindingType, true, astProp);\nreturn copyPiggies(assignable, assignable_forPiggies);\n}\nif ($tp_afterKey_type === 16471) {\nlet assignable = parseObjectMethod(lexerFlags, $tp_keyStart_start, $tp_keyStart_line, $tp_keyStart_column, 'init', true, true, 0, 0, 0, 0, astProp);\nreturn copyPiggies(assignable, assignable_forPiggies);\n}\nTHROW_RANGE(('Object literal; computed property must be followed by a colon (property) paren (method), found `' + tok_sliceInput(tok_getStart(), tok_getStop())) + `' instead'`, tok_getStart(), tok_getStop());\n}\nfunction parseObjectRestSpread(lexerFlags, scoop, bindingType, exportedNames, exportedBindings, astProp) {\nif (((targetEsVersion < 9) && (targetEsVersion !== Infinity))) {\nreturn THROW_RANGE('Object spread/rest requires the requested version to be ES9+', tok_getStart(), tok_getStop());\n}\nreturn parseArrowableSpreadOrRest(lexerFlags, scoop, 16517, bindingType, 0, exportedNames, exportedBindings, astProp);\n}\nfunction parseObjectMethod(lexerFlags, $tp_methodStart_start, $tp_methodStart_line, $tp_methodStart_column, kind, isComputed, isRealMethod, $tp_async_type, $tp_star_type, $tf_getToken_type, $tf_setToken_type, astProp) {\nif (babelCompat) {\nAST_wrapClosedCustom(astProp, {type:NODE_NAME_METHOD_OBJECT, loc:undefined, key:undefined, method:isRealMethod, generator:undefined, async:undefined, id:undefined, params:[], kind:((kind === 'init')? 'method' : kind), computed:isComputed, body:undefined}, 'key');\n} else {\nAST_wrapClosedCustom(astProp, {type:NODE_NAME_METHOD_OBJECT, loc:undefined, key:undefined, kind:kind, method:isRealMethod, computed:isComputed, value:undefined, shorthand:false}, 'key');\n}\nif (acornCompat) {\nlet $tp_paren_line = tok_getLine();\nlet $tp_paren_column = tok_getColumn();\nlet $tp_paren_start = tok_getStart();\nparseFunctionAfterKeyword(lexerFlags, null, false, false, true, false, true, $tp_async_type, $tp_star_type, $tf_getToken_type, $tf_setToken_type, $tp_paren_start, $tp_paren_line, $tp_paren_column, 1, 'value');\n} else {\nparseFunctionAfterKeyword(lexerFlags, null, false, false, true, false, true, $tp_async_type, $tp_star_type, $tf_getToken_type, $tf_setToken_type, $tp_methodStart_start, $tp_methodStart_line, $tp_methodStart_column, 1, 'value');\n}\nAST_close($tp_methodStart_start, $tp_methodStart_line, $tp_methodStart_column);\nreturn 1;\n}\nfunction parsePatternAssignMaybe(lexerFlags, $tp_patternStart_start, $tp_patternStart_line, $tp_patternStart_column, destructible, astProp) {\nverifyDestructible(destructible);\nif (!isAnyAssignmentOp()) {\nreturn destructible;\n}\nif (tok_getType() !== 49264) {\nreturn THROW_RANGE('Cannot compound-assign to an array literal', tok_getStart(), tok_getStop());\n}\nif ((destructible & 1) === 1) {\nreturn THROW_RANGE('Tried to destructure something that is not destructible', tok_getStart(), tok_getStop());\n}\ndestructible = (destructible | 4) ^ 4;\nAST_destruct(astProp);\nAST_wrapClosedCustom(astProp, {type:'AssignmentExpression', loc:undefined, left:undefined, operator:'=', right:undefined}, 'left');\nskipToExpressionStart(lexerFlags);\ndestructible |= parseExpression(lexerFlags, 'right');\nAST_close($tp_patternStart_start, $tp_patternStart_line, $tp_patternStart_column);\nreturn destructible;\n}\nfunction parseClassDeclaration(lexerFlags, scoop, optionalIdent, isLabelled, fdState, astProp) {\nlet originalOuterLexerFlags = lexerFlags;\nlet $tp_class_line = tok_getLine();\nlet $tp_class_column = tok_getColumn();\nlet $tp_class_start = tok_getStart();\nlet $tp_class_stop = tok_getStop();\nif (((((isLabelled === true) || (fdState === 1))) || (fdState === 2))) {\nreturn THROW_RANGE('Cannot parse a class declaration here, only expecting statements here', $tp_class_start, $tp_class_stop);\n}\nlexerFlags = ((lexerFlags | 8192) | 6176) ^ 6176;\nskipToIdentCurlyOpen(lexerFlags);\nAST_open(astProp, {type:'ClassDeclaration', loc:undefined, id:undefined, superClass:undefined, body:undefined});\nlet $tp_name_canon = parseClassId(lexerFlags, optionalIdent, scoop);\n_parseClass(lexerFlags, originalOuterLexerFlags, 2);\nAST_close($tp_class_start, $tp_class_line, $tp_class_column);\nreturn $tp_name_canon;\n}\nfunction parseClassExpression(lexerFlags, $tp_class_start, $tp_class_line, $tp_class_column, astProp) {\nlet originalOuterLexerFlags = lexerFlags;\nlexerFlags = ((lexerFlags | 8192) | 6176) ^ 6176;\nAST_open(astProp, {type:'ClassExpression', loc:undefined, id:undefined, superClass:undefined, body:undefined});\nparseClassId(lexerFlags, true, null);\nlet assignable = _parseClass(lexerFlags, originalOuterLexerFlags, 1);\nAST_close($tp_class_start, $tp_class_line, $tp_class_column);\nreturn setNotAssignable(assignable);\n}\nfunction parseClassId(lexerFlags, optionalIdent, scoop) {\nlet $tp_bindingName_canon = '';\nif ((isIdentToken(tok_getType()) && (tok_getType() !== 2090))) {\nlet $tp_className_type = tok_getType();\nlet $tp_className_start = tok_getStart();\nlet $tp_className_stop = tok_getStop();\nlet $tp_className_canon = tok_getCanoN();\nfatalBindingIdentCheck($tp_className_type, $tp_className_start, $tp_className_stop, $tp_className_canon, 8, lexerFlags);\n$tp_bindingName_canon = $tp_className_canon;\nSCOPE_addLexBinding(scoop, $tp_className_start, $tp_className_stop, $tp_bindingName_canon, 8, 1);\nlet $tp_id_line = tok_getLine();\nlet $tp_id_column = tok_getColumn();\nlet $tp_id_start = tok_getStart();\nlet $tp_id_stop = tok_getStop();\nlet $tp_id_canon = tok_getCanoN();\nskipToIdentCurlyOpen(lexerFlags);\nAST_setIdent('id', $tp_id_start, $tp_id_stop, $tp_id_line, $tp_id_column, $tp_id_canon);\n} else if (optionalIdent === false) {\nreturn THROW_RANGE('Class decl missing required ident, `extends` is not a valid variable name', tok_getStart(), tok_getStop());\n} else {\nAST_set('id', null);\n}\nreturn $tp_bindingName_canon;\n}\nfunction _parseClass(outerLexerFlags, originalOuterLexerFlags, isExpression) {\nlet assignable = 8;\nlet innerLexerFlags = (outerLexerFlags | 16) ^ 16;\nif ((isIdentToken(tok_getType()) && (tok_getType() === 2090))) {\nskipToExpressionStart(outerLexerFlags);\nassignable = parseValue(outerLexerFlags, false, 4, true, 'superClass');\ninnerLexerFlags |= 16384;\n} else {\nAST_set('superClass', null);\ninnerLexerFlags = (innerLexerFlags | 16384) ^ 16384;\n}\nif (tok_getType() !== 16513) {\nreturn THROW_RANGE(('Expected the opening curly `{` of a class body, found `' + tok_sliceInput(tok_getStart(), tok_getStop())) + '` instead', tok_getStart(), tok_getStop());\n}\ninnerLexerFlags |= 32768;\nassignable |= parseClassBody(innerLexerFlags, outerLexerFlags, originalOuterLexerFlags, isExpression, 'body');\nreturn assignable;\n}\nfunction parseClassBody(lexerFlags, outerLexerFlags, originalOuterLexerFlags, isExpression, astProp) {\nlet $tp_curly_line = tok_getLine();\nlet $tp_curly_column = tok_getColumn();\nlet $tp_curly_start = tok_getStart();\nAST_open(astProp, {type:'ClassBody', loc:undefined, body:[]});\nlet assignable = _parseClassBody(lexerFlags, outerLexerFlags, originalOuterLexerFlags, isExpression, 'body');\nAST_close($tp_curly_start, $tp_curly_line, $tp_curly_column);\nreturn assignable;\n}\nfunction _parseClassBody(lexerFlags, outerLexerFlags, originalOuterLexerFlags, isExpression, astProp) {\nlet destructibleForPiggies = 1;\nskipAny(lexerFlags);\nwhile (tok_getType() === 16490) {\nskipAny(lexerFlags);\n}\nlet hasConstructor = false;\nwhile (tok_getType() !== 16517) {\nlet $tp_memberStart_start = tok_getStart();\nlet $tp_memberStart_stop = tok_getStop();\nlet destructNow = parseClassMethod(lexerFlags, outerLexerFlags, astProp);\nif ((destructNow & 256) !== 0) {\nif (hasConstructor) {\nreturn THROW_RANGE('Classes may only have one constructor', $tp_memberStart_start, $tp_memberStart_stop);\n}\nhasConstructor = true;\ndestructNow = (destructNow | 256) ^ 256;\n}\ndestructibleForPiggies |= destructNow;\nwhile (tok_getType() === 16490) {\nskipAny(lexerFlags);\n}\n}\nif (isExpression === 1) {\nskipDiv(originalOuterLexerFlags);\n} else {\nskipToStatementStart(originalOuterLexerFlags);\n}\nreturn destructibleForPiggies;\n}\nfunction parseClassMethod(lexerFlags, outerLexerFlags, astProp) {\nlet $tp_methodStart_line = tok_getLine();\nlet $tp_methodStart_column = tok_getColumn();\nlet $tp_methodStart_start = tok_getStart();\nlet isStatic = false;\nif (tok_getType() === 2113) {\nisStatic = true;\nlet $tp_static_line = tok_getLine();\nlet $tp_static_column = tok_getColumn();\nlet $tp_static_start = tok_getStart();\nlet $tp_static_stop = tok_getStop();\nlet $tp_static_canon = tok_getCanoN();\nskipAny(lexerFlags);\nif (tok_getType() === 16471) {\nreturn _parseClassMethodIdentKey(lexerFlags, $tp_methodStart_line, $tp_methodStart_column, $tp_methodStart_start, false, 0, 0, 0, 0, $tp_static_start, $tp_static_stop, $tp_static_line, $tp_static_column, $tp_static_canon, astProp);\n}\n}\nlet $tp_afterStaticMaybe_type = tok_getType();\nif (isIdentToken($tp_afterStaticMaybe_type)) {\nreturn parseClassMethodFromIdent(lexerFlags, outerLexerFlags, $tp_methodStart_line, $tp_methodStart_column, $tp_methodStart_start, isStatic, astProp);\n}\nif (isNumberStringToken($tp_afterStaticMaybe_type)) {\nreturn parseClassMethodLiteralKey(lexerFlags, $tp_methodStart_line, $tp_methodStart_column, $tp_methodStart_start, isStatic, 0, 0, 0, 0, astProp);\n}\nif ($tp_afterStaticMaybe_type === 16509) {\nreturn parseClassMethodComputedKey(lexerFlags, outerLexerFlags, $tp_methodStart_line, $tp_methodStart_column, $tp_methodStart_start, isStatic, 0, 0, 0, 0, astProp);\n}\nif ($tp_afterStaticMaybe_type === 82009) {\nskipToIdentStringNumberSquareOpen(lexerFlags);\nif (isIdentToken(tok_getType())) {\nreturn parseClassMethodIdentKey(lexerFlags, $tp_methodStart_line, $tp_methodStart_column, $tp_methodStart_start, isStatic, 0, 82009, 0, 0, astProp);\n}\nif (isNumberStringToken(tok_getType())) {\nreturn parseClassMethodLiteralKey(lexerFlags, $tp_methodStart_line, $tp_methodStart_column, $tp_methodStart_start, isStatic, 0, 82009, 0, 0, astProp);\n}\nif (tok_getType() === 16509) {\nreturn parseClassMethodComputedKey(lexerFlags, outerLexerFlags, $tp_methodStart_line, $tp_methodStart_column, $tp_methodStart_start, isStatic, 0, 82009, 0, 0, astProp);\n}\nreturn THROW_RANGE('Invalid objlit key character after generator star', $tp_methodStart_line, tok_getStop());\n}\nreturn THROW_RANGE('Unexpected token, wanted to parse a start of a property in an class literal/pattern', $tp_methodStart_line, tok_getStop());\n}\nfunction parseClassMethodFromIdent(lexerFlags, outerLexerFlags, $tp_methodStart_line, $tp_methodStart_column, $tp_methodStart_start, isStatic, astProp) {\nlet $tp_ident_type = tok_getType();\nlet $tp_ident_line = tok_getLine();\nlet $tp_ident_column = tok_getColumn();\nlet $tp_ident_start = tok_getStart();\nlet $tp_ident_stop = tok_getStop();\nlet $tp_ident_canon = tok_getCanoN();\nskipAny(lexerFlags);\nif (tok_getType() === 16471) {\nreturn _parseClassMethodIdentKey(lexerFlags, $tp_methodStart_line, $tp_methodStart_column, $tp_methodStart_start, isStatic, 0, 0, 0, 0, $tp_ident_start, $tp_ident_stop, $tp_ident_line, $tp_ident_column, $tp_ident_canon, astProp);\n}\nlet $tp_async_type = 0;\nlet $tp_star_type = 0;\nlet $tp_get_type = 0;\nlet $tp_set_type = 0;\nswitch ($tp_ident_type) {\ncase 2096:\n$tp_get_type = 2096;\nbreak;\ncase 2112:\n$tp_set_type = 2112;\nbreak;\ncase 2074:\nif (!allowAsyncFunctions) {\nreturn THROW_RANGE('Async methods are not supported in the currently targeted language version', $tp_methodStart_start, tok_getStop());\n}\nif (tok_getNlwas() === true) {\nreturn THROW_RANGE('Async methods are a restricted production and cannot have a newline following it', $tp_methodStart_line, tok_getStart());\n}\n$tp_async_type = 2074;\nif (tok_getType() === 82009) {\nif (!allowAsyncGenerators) {\nreturn THROW_RANGE('Async generator methods are not supported in the currently targeted language version', $tp_methodStart_start, tok_getStop());\n}\n$tp_star_type = 82009;\nskipToIdentStringNumberSquareOpen(lexerFlags);\n}\nbreak;\ndefault:\nreturn THROW_RANGE('Either the current modifier is unknown or the input that followed was unexpected', tok_getStart(), tok_getStop());\n}\nif (tok_getType() === 16509) {\nreturn parseClassMethodComputedKey(lexerFlags, outerLexerFlags, $tp_methodStart_line, $tp_methodStart_column, $tp_methodStart_start, isStatic, $tp_async_type, $tp_star_type, $tp_get_type, $tp_set_type, astProp);\n}\nif (isNumberStringToken(tok_getType())) {\nreturn parseClassMethodLiteralKey(lexerFlags, $tp_methodStart_line, $tp_methodStart_column, $tp_methodStart_start, isStatic, $tp_async_type, $tp_star_type, $tp_get_type, $tp_set_type, astProp);\n}\nif (isIdentToken(tok_getType())) {\nreturn parseClassMethodIdentKey(lexerFlags, $tp_methodStart_line, $tp_methodStart_column, $tp_methodStart_start, isStatic, $tp_async_type, $tp_star_type, $tp_get_type, $tp_set_type, astProp);\n}\nreturn THROW_RANGE('Expected to parse the modified key of a class method but could not parse one', tok_getStart(), tok_getStop());\n}\nfunction parseClassMethodIdentKey(lexerFlags, $tp_methodStart_line, $tp_methodStart_column, $tp_methodStart_start, isStatic, $tp_async_type, $tp_star_type, $tp_get_type, $tp_set_type, astProp) {\nlet $tp_key_line = tok_getLine();\nlet $tp_key_column = tok_getColumn();\nlet $tp_key_start = tok_getStart();\nlet $tp_key_stop = tok_getStop();\nlet $tp_key_canon = tok_getCanoN();\nskipToParenOpenOrDie(lexerFlags);\nreturn _parseClassMethodIdentKey(lexerFlags, $tp_methodStart_line, $tp_methodStart_column, $tp_methodStart_start, isStatic, $tp_async_type, $tp_star_type, $tp_get_type, $tp_set_type, $tp_key_start, $tp_key_stop, $tp_key_line, $tp_key_column, $tp_key_canon, astProp);\n}\nfunction _parseClassMethodIdentKey(lexerFlags, $tp_methodStart_line, $tp_methodStart_column, $tp_methodStart_start, isStatic, $tp_async_type, $tp_star_type, $tp_get_type, $tp_set_type, $tp_key_start, $tp_key_stop, $tp_key_line, $tp_key_column, $tp_key_canon, astProp) {\nAST_setIdent(astProp, $tp_key_start, $tp_key_stop, $tp_key_line, $tp_key_column, $tp_key_canon);\nif ((isStatic && ($tp_key_canon === 'prototype'))) {\nreturn THROW_RANGE('Static class methods can not be called `prototype`', $tp_methodStart_line, tok_getStop());\n}\nlet kind = 'method';\nlet isClassConstructor = false;\nif (((!isStatic) && ($tp_key_canon === 'constructor'))) {\nisClassConstructor = true;\nkind = 'constructor';\nif ($tp_async_type === 2074) {\nreturn THROW_RANGE('Class constructors can not be async', $tp_methodStart_line, tok_getStop());\n}\nif ($tp_star_type === 82009) {\nreturn THROW_RANGE('Class constructors can not be generators', $tp_methodStart_line, tok_getStop());\n}\nif ($tp_get_type === 2096) {\nreturn THROW_RANGE('Class constructors can not be getters', $tp_methodStart_line, tok_getStop());\n}\nif ($tp_set_type === 2112) {\nreturn THROW_RANGE('Class constructors can not be setters', $tp_methodStart_line, tok_getStop());\n}\n} else if ($tp_get_type === 2096) {\nkind = 'get';\n} else if ($tp_set_type === 2112) {\nkind = 'set';\n} else {\n\n}\nreturn parseClassMethodAfterKey(lexerFlags, $tp_methodStart_line, $tp_methodStart_column, $tp_methodStart_start, kind, isClassConstructor, false, isStatic, $tp_async_type, $tp_star_type, $tp_get_type, $tp_set_type, astProp);\n}\nfunction parseClassMethodLiteralKey(lexerFlags, $tp_methodStart_line, $tp_methodStart_column, $tp_methodStart_start, isStatic, $tp_async_type, $tp_star_type, $tp_get_type, $tp_set_type, astProp) {\nlet $tp_lit_type = tok_getType();\nlet $tp_lit_line = tok_getLine();\nlet $tp_lit_column = tok_getColumn();\nlet $tp_lit_start = tok_getStart();\nlet $tp_lit_stop = tok_getStop();\nlet $tp_lit_canon = tok_getCanoN();\nif ((isStatic && ($tp_lit_canon === 'prototype'))) {\nreturn THROW_RANGE('Static class methods can not be called `prototype`', $tp_methodStart_line, tok_getStop());\n}\nlet kind = 'method';\nlet isClassConstructor = false;\nif (((!isStatic) && ($tp_lit_canon === 'constructor'))) {\nisClassConstructor = true;\nkind = 'constructor';\nif ($tp_async_type === 2074) {\nreturn THROW_RANGE('Class constructors can not be async', $tp_methodStart_line, tok_getStop());\n}\nif ($tp_star_type === 82009) {\nreturn THROW_RANGE('Class constructors can not be generators', $tp_methodStart_line, tok_getStop());\n}\nif ($tp_get_type === 2096) {\nreturn THROW_RANGE('Class constructors can not be getters', $tp_methodStart_line, tok_getStop());\n}\nif ($tp_set_type === 2112) {\nreturn THROW_RANGE('Class constructors can not be setters', $tp_methodStart_line, tok_getStop());\n}\n} else if ($tp_get_type === 2096) {\nkind = 'get';\n} else if ($tp_set_type === 2112) {\nkind = 'set';\n} else {\n\n}\nskipToParenOpenOrDie(lexerFlags);\nAST_setLiteral(astProp, $tp_lit_type, $tp_lit_start, $tp_lit_stop, $tp_lit_line, $tp_lit_column, $tp_lit_canon);\nreturn parseClassMethodAfterKey(lexerFlags, $tp_methodStart_line, $tp_methodStart_column, $tp_methodStart_start, kind, isClassConstructor, false, isStatic, $tp_async_type, $tp_star_type, $tp_get_type, $tp_set_type, astProp);\n}\nfunction parseClassMethodComputedKey(lexerFlags, outerLexerFlags, $tp_methodStart_line, $tp_methodStart_column, $tp_methodStart_start, isStatic, $tp_async_type, $tp_star_type, $tp_get_type, $tp_set_type, astProp) {\nskipToExpressionStart(lexerFlags);\nlet assignable_forPiggies = parseExpression(outerLexerFlags, astProp);\nif (tok_getType() !== 16510) {\nreturn THROW_RANGE(('Missing right square bracket for computed member, found `' + tok_sliceInput(tok_getStart(), tok_getStop())) + '` instead', tok_getStart(), tok_getStop());\n}\nskipToParenOpenOrDie(lexerFlags);\nlet kind = 'method';\nif ($tp_get_type === 2096) {\nkind = 'get';\n} else if ($tp_set_type === 2112) {\nkind = 'set';\n} else {\n\n}\nparseClassMethodAfterKey(lexerFlags, $tp_methodStart_line, $tp_methodStart_column, $tp_methodStart_start, kind, false, true, isStatic, $tp_async_type, $tp_star_type, $tp_get_type, $tp_set_type, astProp);\nreturn assignable_forPiggies;\n}\nfunction parseClassMethodAfterKey(lexerFlags, $tp_methodStart_line, $tp_methodStart_column, $tp_methodStart_start, kind, isClassConstructor, isComputedKey, isStatic, $tp_async_type, $tp_star_type, $tp_get_type, $tp_set_type, astProp) {\nlet $tp_paren_line = tok_getLine();\nlet $tp_paren_column = tok_getColumn();\nlet $tp_paren_start = tok_getStart();\nif (babelCompat) {\nAST_wrapClosedCustom(astProp, {type:NODE_NAME_METHOD_CLASS, loc:undefined, key:undefined, static:isStatic, computed:isComputedKey, async:undefined, generator:undefined, id:undefined, params:[], kind:kind}, 'key');\n} else {\nAST_wrapClosedCustom(astProp, {type:NODE_NAME_METHOD_CLASS, loc:undefined, key:undefined, static:isStatic, computed:isComputedKey, kind:kind, value:undefined}, 'key');\n}\nparseFunctionAfterKeyword(lexerFlags, null, false, false, true, isClassConstructor, true, $tp_async_type, $tp_star_type, $tp_get_type, $tp_set_type, (acornCompat? $tp_paren_start : $tp_methodStart_start), (acornCompat? $tp_paren_line : $tp_methodStart_line), (acornCompat? $tp_paren_column : $tp_methodStart_column), 1, 'value');\nAST_close($tp_methodStart_start, $tp_methodStart_line, $tp_methodStart_column);\nif (isClassConstructor === true) {\nreturn 256;\n}\nreturn 1;\n}\nfunction verifyDestructible(destructible) {\nif ((((destructible & 1) === 1) && ((destructible & 4) === 4))) {\nreturn THROW_RANGE('Found a part that cant destruct and a part that must destruct so it is not destructible', tok_getStart(), tok_getStop());\n}\n}\nfunction verifyDestructibleForBinding(destructible, bindingType) {\nif ((destructible & 1) !== 0) {\nreturn THROW_RANGE('The binding pattern is not destructible', tok_getStart(), tok_getStop());\n}\nif (((bindingType !== 0) && ((destructible & 2) !== 0))) {\nreturn THROW_RANGE('This binding can not be used in function parameters because it is not destructible', tok_getStart(), tok_getStop());\n}\n}\nfunction parseOptionalDestructibleRestOfExpression(lexerFlags, $tp_valueStart_start, $tp_valueStart_stop, $tp_valueStart_line, $tp_valueStart_column, assignable, destructible, closingPuncType, astProp) {\nif (((tok_getType() === 16480) || (tok_getType() === closingPuncType))) {\nif (notAssignable(assignable)) destructible |= 1;\n} else if ((destructible & 4) === 4) {\nreturn THROW_RANGE('Found something that had to be a Pattern but had to parse more, which is an error', $tp_valueStart_start, tok_getStart());\n} else {\nassignable = parseValueTail(lexerFlags, $tp_valueStart_start, $tp_valueStart_line, $tp_valueStart_column, assignable, 4, false, astProp);\nif (isAssignable(assignable)) {\ndestructible = (destructible | 7) ^ 7;\n} else {\ndestructible |= 1;\n}\nlet firstOpNotAssign = tok_getType() !== 49264;\nif (((tok_getType() !== 16480) && (tok_getType() !== closingPuncType))) {\nassignable |= parseExpressionFromOp(lexerFlags, $tp_valueStart_start, $tp_valueStart_stop, $tp_valueStart_line, $tp_valueStart_column, assignable, astProp);\nif (firstOpNotAssign) {\ndestructible |= 1;\n} else {\n\n}\n} else if (firstOpNotAssign) {\nif (notAssignable(assignable)) {\ndestructible |= 1;\n} else {\ndestructible |= 2;\n}\n}\n}\nreturn copyPiggies(destructible, assignable);\n}\nfunction parseArrowableSpreadOrRest(lexerFlags, scoop, closingPuncType, bindingType, $tp_async_type, exportedNames, exportedBindings, astProp) {\nlet $tp_spread_line = tok_getLine();\nlet $tp_spread_column = tok_getColumn();\nlet $tp_spread_start = tok_getStart();\nskipToExpressionStart(lexerFlags);\nif (tok_getType() === 16486) {\nreturn THROW_RANGE('Can not rest twice', $tp_spread_start, tok_getStop());\n}\nAST_open(astProp, {type:'SpreadElement', loc:undefined, argument:undefined});\nlet destructible = _parseArrowableSpreadOrRest(lexerFlags, scoop, closingPuncType, bindingType, $tp_async_type, $tp_spread_start, exportedNames, exportedBindings, 'argument');\nAST_close($tp_spread_start, $tp_spread_line, $tp_spread_column);\nif (((tok_getType() !== closingPuncType) && (tok_getType() !== 16480))) {\nreturn THROW_RANGE('Encountered invalid input after spread/rest argument', tok_getStart(), tok_getStop());\n}\nreturn destructible;\n}\nfunction _parseArrowableSpreadOrRest(lexerFlags, scoop, closingPuncType, bindingType, $tp_async_type, $tt_spreadToken_start, exportedNames, exportedBindings, astProp) {\nlet $tp_argStart_line = tok_getLine();\nlet $tp_argStart_column = tok_getColumn();\nlet $tp_argStart_start = tok_getStart();\nlet $tp_argStart_stop = tok_getStop();\nlet destructible = 0;\nlet assignable = 32;\nif (isIdentToken(tok_getType())) {\nlet $tp_ident_type = tok_getType();\nlet $tp_ident_line = tok_getLine();\nlet $tp_ident_column = tok_getColumn();\nlet $tp_ident_start = tok_getStart();\nlet $tp_ident_stop = tok_getStop();\nlet $tp_ident_canon = tok_getCanoN();\nskipIdentSafeSlowAndExpensive(lexerFlags, false);\nlet assignBefore = tok_getType() === 49264;\nlet willBeSimple = ((((tok_getType() === closingPuncType) || (tok_getType() === 16480))) || assignBefore);\nif (willBeSimple) {\nlet assignableOrErrorMsg = nonFatalBindingIdentCheck($tp_ident_type, $tp_ident_start, $tp_ident_stop, $tp_ident_canon, bindingType, lexerFlags);\nif (assignableOrErrorMsg.length !== 0) {\ndestructible |= 1;\n}\n} else {\ndestructible |= 2;\n}\nassignable = parseValueAfterIdent(lexerFlags, $tp_ident_type, $tp_ident_start, $tp_ident_stop, $tp_ident_line, $tp_ident_column, $tp_ident_canon, bindingType, true, astProp);\nif (((tok_getType() !== 16480) && (tok_getType() !== closingPuncType))) {\nif (tok_getType() === 49264) {\nif (notAssignable(assignable)) {\nreturn THROW_RANGE('Tried to assign to a value that was not assignable in arr/obj lit/patt', tok_getStart(), tok_getStop());\n}\n}\ndestructible |= 1;\nassignable = parseExpressionFromOp(lexerFlags, $tp_argStart_start, $tp_argStart_stop, $tp_argStart_line, $tp_argStart_column, assignable, astProp);\n}\nif (notAssignable(assignable)) {\ndestructible |= 1;\n} else if (willBeSimple) {\nSCOPE_actuallyAddBinding(lexerFlags, scoop, $tp_ident_start, $tp_ident_stop, $tp_ident_canon, bindingType);\naddNameToExports(exportedNames, $tp_ident_start, $tp_ident_stop, $tp_ident_canon);\naddBindingToExports(exportedBindings, $tp_ident_canon);\n} else {\ndestructible |= 2;\n}\n} else if (tok_getType() === 16509) {\nlet nowDestruct = parseArrayLiteralPattern(lexerFlags, scoop, bindingType, false, exportedNames, exportedBindings, astProp);\nif (((((tok_getType() !== 49264) && (tok_getType() !== closingPuncType))) && (tok_getType() !== 16480))) {\ndestructible = parseOptionalDestructibleRestOfExpression(lexerFlags, $tp_argStart_start, $tp_argStart_stop, $tp_argStart_line, $tp_argStart_column, assignable, nowDestruct, closingPuncType, astProp);\n} else {\nif (((closingPuncType === 16517) && (tok_getType() !== 49264))) {\ndestructible |= nowDestruct | 1;\n} else {\ndestructible |= nowDestruct;\n}\n}\nassignable = (((destructible & 1) === 1)? 16 : 32);\nif (((closingPuncType === 16517) && notAssignable(assignable))) {\ndestructible |= 1;\n}\n} else if (tok_getType() === 16513) {\nlet $tp_curly_line = tok_getLine();\nlet $tp_curly_column = tok_getColumn();\nlet $tp_curly_start = tok_getStart();\nlet $tp_curly_stop = tok_getStop();\nlet nowDestruct = parseObjectAndAssign(lexerFlags, scoop, bindingType, false, exportedNames, exportedBindings, astProp);\nif (((((tok_getType() !== 49264) && (tok_getType() !== closingPuncType))) && (tok_getType() !== 16480))) {\ndestructible = parseOptionalDestructibleRestOfExpression(lexerFlags, $tp_curly_start, $tp_curly_stop, $tp_curly_line, $tp_curly_column, assignable, nowDestruct, closingPuncType, astProp);\n} else {\ndestructible |= nowDestruct;\nif (((closingPuncType === 16517) && (tok_getType() !== 49264))) {\ndestructible |= 1;\n}\n}\nassignable = (((destructible & 1) === 1)? 16 : 32);\nif (((closingPuncType === 16517) && notAssignable(assignable))) {\ndestructible |= 1;\n}\n} else if (tok_getType() === closingPuncType) {\nreturn THROW_RANGE('The rest/spread operator is missing an argument', $tt_spreadToken_start, tok_getStop());\n} else {\ndestructible |= 2;\nlet $tp_exprStart_line = tok_getLine();\nlet $tp_exprStart_column = tok_getColumn();\nlet $tp_exprStart_start = tok_getStart();\nlet $tp_exprStart_stop = tok_getStop();\nlet nowAssignable = parseValue(lexerFlags, true, 4, false, astProp);\nif (notAssignable(nowAssignable)) {\ndestructible = 1;\n}\nassignable = mergeAssignable(nowAssignable, assignable);\nif (((((tok_getType() === 49264) && (tok_getType() !== closingPuncType))) && (tok_getType() !== 16480))) {\nif (notAssignable(assignable)) {\nreturn THROW_RANGE('This `...` arg is invalid; rest only accepts idents, arrays, and objects and as spread the assignment is illegal because the lhs is not assignable', $tt_spreadToken_start, tok_getStop());\n}\nassignable = parseExpressionFromOp(lexerFlags, $tp_exprStart_start, $tp_exprStart_stop, $tp_exprStart_line, $tp_exprStart_column, assignable, astProp);\ndestructible |= 1;\n} else {\nif (tok_getType() === 16480) {\ndestructible |= 1;\n} else if (tok_getType() !== closingPuncType) {\nassignable = parseExpressionFromOp(lexerFlags, $tp_exprStart_start, $tp_exprStart_stop, $tp_exprStart_line, $tp_exprStart_column, assignable, astProp);\n} else {\n\n}\nif (isAssignable(assignable)) {\ndestructible |= 2;\n} else {\ndestructible |= 1;\n}\n}\nif (((closingPuncType === 16517) && (!isAssignable(assignable)))) destructible |= 1;\nreturn copyPiggies(destructible, assignable);\n}\nif (tok_getType() !== closingPuncType) {\nif (bindingType === 1) {\nif ($tp_async_type === 2074) {\ndestructible |= 1;\n} else {\ndestructible |= 2;\n}\n}\nif (tok_getType() === 49264) {\nverifyDestructible(destructible | 4);\ndestructible = 1;\nAST_destruct(astProp);\nAST_wrapClosedCustom(astProp, {type:'AssignmentExpression', loc:undefined, left:undefined, operator:'=', right:undefined}, 'left');\nskipToExpressionStart(lexerFlags);\nlet nowAssignable = parseExpression(lexerFlags, 'right');\nassignable = mergeAssignable(nowAssignable, assignable);\nAST_close($tp_argStart_start, $tp_argStart_line, $tp_argStart_column);\n} else {\nassignable = parseValueTail(lexerFlags, $tp_argStart_start, $tp_argStart_line, $tp_argStart_column, assignable, 4, false, astProp);\nassignable = parseExpressionFromOp(lexerFlags, $tp_argStart_start, $tp_argStart_stop, $tp_argStart_line, $tp_argStart_column, assignable, astProp);\n}\ndestructible |= 1;\n}\nreturn copyPiggies(destructible, assignable);\n}\nlet initialLexerFlags = ((260 | ((((options_strictMode || (goalMode === true)))? 8192 : 0))) | 4) ^ 4;\ninitLexer(initialLexerFlags);\nparseTopLevels(initialLexerFlags);\nif (tok_getType() !== 2097173) {\nreturn THROW_RANGE('Unexpected further input', tok_getStart(), tok_getStop());\n}\n_tree.loc = AST_getCloseLoc(0, 1, 0, tok_prevEndPointer(), tok_getLine(), tok_getColumn());\nreturn {ast:_tree, tokens:tok.tokens, tokenCountSolid:tok.getTokenCountSolid(), tokenCountAny:tok.getTokenCountAny()};\n}\nfunction isTemplateStart(type) {\nreturn ((((((type === 524308) || (type === 524305))) || (type === 1572884))) || (type === 1572881));\n}\nfunction D(d) {\nif (d === 0) {\nreturn 'D=MIGHT_DESTRUCT';\n}\nlet arr = [];\nif (d & 1) {\narr.push('CANT_DESTRUCT');\nd ^= 1;\n}\nif (d & 4) {\narr.push('MUST_DESTRUCT');\nd ^= 4;\n}\nif (d & 2) {\narr.push('DESTRUCT_ASSIGN_ONLY');\nd ^= 2;\n}\nif (d & 8) {\narr.push('(ASSIGNABLE_UNDETERMINED)');\nd ^= 8;\n}\nif (d & 16) {\narr.push('(NOT_ASSIGNABLE)');\nd ^= 16;\n}\nif (d & 32) {\narr.push('(IS_ASSIGNABLE)');\nd ^= 32;\n}\nd = P(d, arr);\nif (d !== 0) {\nconsole.log('Gathered flags so far:', arr.join(', '));\n}\nreturn 'D=' + arr.join(', ');\n}\nfunction A(a) {\nif (a === 0) {\nreturn 'A=ASSIGNABLE_UNDETERMINED';\n}\nlet arr = [];\nif (a & 8) {\narr.push('ASSIGNABLE_UNDETERMINED');\na ^= 8;\n}\nif (a & 16) {\narr.push('NOT_ASSIGNABLE');\na ^= 16;\n}\nif (a & 32) {\narr.push('IS_ASSIGNABLE');\na ^= 32;\n}\nif (a & 1) {\narr.push('(CANT_DESTRUCT)');\na ^= 1;\n}\nif (a & 4) {\narr.push('(MUST_DESTRUCT)');\na ^= 4;\n}\nif (a & 2) {\narr.push('(DESTRUCT_ASSIGN_ONLY)');\na ^= 2;\n}\na = P(a, arr);\nif (a !== 0) {\nconsole.log('Gathered flags so far:', arr.join(', '));\n}\nreturn 'A=' + arr.join(', ');\n}\nfunction B(b) {\nif (b === 0) return 'B=BINDING_TYPE_NONE';\nif (b === 1) return 'B=BINDING_TYPE_ARG';\nif (b === 2) return 'B=BINDING_TYPE_VAR';\nif (b === 6) return 'B=BINDING_TYPE_LET';\nif (b === 7) return 'B=BINDING_TYPE_CONST';\nif (b === 8) return 'B=BINDING_TYPE_CLASS';\nif (b === 9) return 'B=BINDING_TYPE_CATCH_IDENT';\nif (b === 10) return 'B=BINDING_TYPE_CATCH_OTHER';\nif (b === 3) return 'B=BINDING_TYPE_FUNC_VAR';\nif (b === 5) return 'B=BINDING_TYPE_FUNC_LEX';\nif (b === 4) return 'B=BINDING_TYPE_FUNC_STMT';\n}\nfunction S(s) {\nif (s === 0) return 'SCOPE_LAYER_GLOBAL';\nif (s === 1) return 'SCOPE_LAYER_FOR_HEADER';\nif (s === 2) return 'SCOPE_LAYER_BLOCK';\nif (s === 3) return 'SCOPE_LAYER_FUNC_PARAMS';\nif (s === 4) return 'SCOPE_LAYER_TRY';\nif (s === 5) return 'SCOPE_LAYER_CATCH_HEAD';\nif (s === 6) return 'SCOPE_LAYER_CATCH_BODY';\nif (s === 7) return 'SCOPE_LAYER_FINALLY';\nif (s === 8) return 'SCOPE_LAYER_SWITCH';\nif (s === 9) return 'SCOPE_LAYER_FUNC_ROOT';\nif (s === 10) return 'SCOPE_LAYER_FUNC_BODY';\nif (s === 11) return 'SCOPE_LAYER_ARROW_PARAMS';\nif (s === 12) return 'SCOPE_LAYER_FAKE_BLOCK';\n}\nfunction F(fdState) {\nif (fdState === 1) return 'F=FDS_ILLEGAL'; else if (fdState === 2) return 'F=FDS_IFELSE'; else if (fdState === 3) return 'F=FDS_LEX'; else if (fdState === 4) return 'F=FDS_VAR'; else ;\n}\n// </parser>\n\n\nlet Tenko = Parser;\n\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (Tenko); // Does dual export make sense? Default and as member. To each their own, eh\n\n  \n\n//# sourceURL=webpack:///./node_modules/tenko/build/tenko.prod.mjs?")}}]);